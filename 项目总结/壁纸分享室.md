## 壁纸分享室

### 1.项目描述

**项目技术栈**：vue3 + uniapp + nodejs + express + mysql + sass

**项目介绍**：该项目是一个微信小程序（已上线）,免费的头像、壁纸分享平台，提供各类精美图片资源，支持用户浏览、挑选、下载，满足手机、电脑等设备的美化需求。

**项目亮点**：

1. 对 http 请求经行独立封装，实现智能拦截重复请求、统一管理 Loading 状态、并对各类错误进行精细化处理，极大地提升了应用性能与用户体验。

2. 设计并实现了一套完整的客户端缓存方案，能智能复用本地数据以减少请求开销，并结合失效策略与后台同步机制，在提升性能的同时，严格保证了数据的时效性与一致性。

3. 采用 “预览图 + 原图” 分层加载策略：预览阶段推送剪裁优化后的 WebP 预览图，降低非查看场景的网络消耗；点击查看时切换为 WebP 高清原图，同时结合懒加载减少初始请求量，并在用户查看时智能预加载相邻 3 张图片，既保障高清视觉体验，又最大化控制网络开销。

4. 将能量为图片下载核心凭证，用户需耗能下载；设计签到、转发邀新、观看视频的梯度获能方式，覆盖互动场景；全链路记录能量收支与余量，生成可视化明细，兼顾资源分发与体验，保障数据可查可信。

5. 对用户点赞、收藏等互动行为设置频次限制，防止恶意快速重复点击，减轻数据库并发压力。

### 2.问题1

> 项目中你对 HTTP 请求做了独立封装，实现了智能拦截重复请求、统一管理 Loading 状态和精细化错误处理。能否详细说下 “智能拦截重复请求” 的实现逻辑？比如怎么判断两个请求是重复的，拦截后是直接返回缓存结果还是等待前一个请求完成？

面试官您好，关于我项目中 “智能拦截重复请求” 的实现，我是这样设计的：

我的核心目标是：**在一个相同的请求还未完成时，如果再次发起，就不再向服务器发送新的请求，而是直接复用第一个请求的结果。** 这样做可以有效减少不必要的网络开销，减轻服务器压力，并提升用户体验，避免因重复请求导致的数据错乱或界面闪烁。

具体实现逻辑分为以下几个步骤：

#### 1. 如何判断两个请求是 “重复” 的？

这是最关键的一步。我定义了一个**请求的唯一标识（`requestKey`）**，如果两个请求的 `requestKey` 完全相同，就认为它们是重复的。

我是这样生成这个 `requestKey` 的：

```javascript
const requestKey = `${upperMethod}-${baseUrl + url}-${sortedStringify(data)}`;
```

它由三部分组成：

1. **请求方法 (`upperMethod`)**：比如 `GET`, `POST`。确保 `GET` 和 `POST` 请求即使路径和参数相同，也不会被误判。
2. **请求地址 (`baseUrl + url`)**：确保不同接口的请求不会被误判。
3. **请求参数 (`sortedStringify(data)`)**：这是一个关键的优化点。我没有直接使用 `JSON.stringify(data)`，因为它会受对象属性顺序的影响（例如 `{a:1, b:2}` 和 `{b:2, a:1}` 会得到不同的字符串）。所以我封装了一个 `sortedStringify` 函数，它会先对对象的 `key` 进行排序，然后再序列化。这样就保证了参数内容相同但顺序不同的请求，也能生成相同的 `requestKey`。

#### 2. 如何存储和管理正在进行的请求？

我使用了一个 `Map` 对象来存储所有 “正在进行中” 的请求：

```javascript
const pendingRequests = new Map();
```

- **`Map` 的 `key`**：就是我们上面生成的 `requestKey`。
- **`Map` 的 `value`**：是该请求对应的 `Promise` 对象。

这样做的好处是，我们不仅能快速判断一个请求是否正在进行（通过 `pendingRequests.has(requestKey)`），还能直接拿到那个正在进行的请求的 `Promise`。

#### 3. 拦截后是直接返回缓存结果还是等待前一个请求完成？

我的策略是**等待前一个请求完成，然后直接复用它的结果**。

整个拦截逻辑是这样的：

1. **发起请求前检查**：在调用 `uni.request` 之前，先根据当前请求的参数生成 `requestKey`。

2. **判断是否重复**：检查 `pendingRequests` 这个 `Map` 中是否已经存在这个 `requestKey`。

3. **如果重复**：

   - 不执行新的 `uni.request`。
   - 直接从 `pendingRequests` 中取出第一个请求的 `Promise` 对象。
   - 然后，将这个已存在的 `Promise` 对象的 `then` 和 `catch` 方法与当前请求的 `Promise` 进行 “挂钩”。

   ```javascript
   // 如果相同请求正在进行，直接复用其Promise
   if (pendingRequests.has(requestKey)) {
     return pendingRequests.get(requestKey).then(resolve).catch(reject);
   }
   ```

   这段代码的精妙之处在于：

   - `pendingRequests.get(requestKey)` 返回的是第一个请求的 `Promise`。
   - 我们调用它的 `.then(resolve)`，意味着当第一个请求**成功**时，它的结果会传递给 `resolve` 函数，从而让**当前这个被拦截的请求**也成功，并拿到相同的数据。
   - 同理，`.catch(reject)` 确保了当第一个请求**失败**时，当前请求也会以同样的原因失败。

4. **如果不重复**：

   - 创建一个新的 `Promise`，在这个 `Promise` 内部执行 `uni.request`。
   - 在 `uni.request` 执行**之前**，就将这个新的 `Promise` 对象和它的 `requestKey` 存入 `pendingRequests` 中。

   ```javascript
   // 创建请求Promise并发起实际请求
   const requestPromise = new Promise((innerResolve, innerReject) => {
     // ... uni.request 的逻辑 ...
   });
   
   // 将当前请求的Promise存入pending，用于拦截重复请求
   pendingRequests.set(requestKey, requestPromise);
   ```

5. **请求完成后清理**：

   - 无论请求最终是成功 (`success`)、失败 (`fail`) 还是被中止，`uni.request` 的 `complete` 回调都会执行。
   - 在 `complete` 回调中，我们从 `pendingRequests` `Map` 中删除这个 `requestKey`，表示这个请求已经结束，后续的请求就可以正常发起了。

   ```javascript
   complete: () => {
     // 请求完成后，从pending中移除该请求
     pendingRequests.delete(requestKey);
   }
   ```

#### 4.总结

所以，我的 “智能拦截重复请求” 方案，其核心思想是：**通过生成唯一的 `requestKey` 来识别请求，并利用 `Map` 数据结构来缓存正在进行的请求的 `Promise` 对象。当重复请求到达时，不是重新发起网络请求，而是直接 “订阅” 第一个请求的 `Promise` 结果，实现了请求的复用和高效处理。**

### 3.问题2

> 项目亮点提到 “设计完整的客户端缓存方案，结合失效策略与后台同步机制”，这里的 “客户端缓存” 是用 uniapp 的哪种存储方式（如 uni.setStorageSync、vuex 持久化）？壁纸数据的失效策略具体是 “时间过期失效” 还是 “后台数据更新时主动失效”？如果用户离线时收藏了壁纸，重新联网后如何保证本地缓存与后台数据一致？

在 “lo 的壁纸分享室” 项目中，我选择 **uni.setStorageSync** 作为客户端缓存核心方案，结合用户 “浏览 - 操作 - 返回” 的完整交互链路，设计了 “批量存储、实时同步、返回清理” 的闭环逻辑，既保证操作即时性，又避免本地缓存冗余，具体实现如下：

#### 1.触发缓存存储：用户点击图片时，批量缓存 24 条数据

考虑到用户浏览壁纸时以 “分页加载 24 条” 为核心场景，我将缓存触发时机绑定在 “用户点击图片进入预览页” 的动作上 —— 此时用户大概率会持续浏览当前分页的壁纸，提前缓存整页数据能避免后续操作重复请求。具体操作：当用户点击某张壁纸时，前端会先获取当前分页的 24 条完整数据（包含每张壁纸的 id、预览图 url、收藏状态、点赞数、下载次数等），并以 “页面标识 + 分页标识” 定义缓存 Key（例如 “wallpaper_category_nature_page2”，区分 “自然分类 - 第 2 页”），通过 `uni.setStorageSync` 持久化存储，同时记录缓存生成时间，代码逻辑示例：

```javascript
// 点击图片时触发缓存存储
const handleImageClick = (currentPageData, pageType, pageNum) => {
  // 定义唯一缓存Key，避免不同页面/分页数据冲突
  const cacheKey = `wallpaper_${pageType}_page${pageNum}`;
  // 存储24条数据及缓存时间
  const cacheValue = {
    dataList: currentPageData, // 当前分页的24条壁纸数据
    cacheTime: Date.now()
  };
  // 执行本地缓存
  uni.setStorageSync(cacheKey, cacheValue);
  // 跳转预览页
  uni.navigateTo({ url: `/pages/preview/preview?cacheKey=${cacheKey}` });
};
```

这种 “用户主动触发 + 批量存储” 的方式，既不会因提前缓存未浏览数据占用本地空间，又能确保后续预览操作有缓存可用。

#### 2.缓存实时同步：预览页操作（下载 / 收藏 / 点赞）后，即时更新缓存

用户在预览页执行下载、收藏、点赞等修改数据的操作时，若依赖 “返回列表页再请求接口更新”，会导致预览页与缓存状态不一致（比如收藏后返回列表仍显示 “未收藏”）。因此我设计了 “操作成功即同步缓存” 的逻辑：

1. **操作生效校验**：先调用后台接口（如收藏接口），确保后台数据修改成功；

2. **定位缓存数据**：通过预览页携带的 `cacheKey`，用 `uni.getStorageSync` 读取当前分页的缓存数据；

3. **精准更新缓存**：根据当前壁纸 id，在缓存的 24 条数据中找到目标项，更新对应字段（如收藏状态 `isCollected` 改为 `true`、点赞数 `likeCount` 加 1），再通过 `uni.setStorageSync` 覆盖原缓存；

4. 即时 UI 反馈：缓存更新后同步刷新预览页 UI（如收藏按钮变色、点赞数实时递增），让用户直观感知操作生效。

   以 “收藏操作” 为例，核心代码逻辑：

```javascript
// 预览页收藏操作
const handleCollect = async (wallpaperId, cacheKey) => {
  // 1. 调用后台收藏接口，确保后台数据同步
  const { success } = await api.wallpaper.collect(wallpaperId);
  if (!success) return uni.showToast({ title: '收藏失败', icon: 'none' });
  
  // 2. 读取本地缓存
  const cacheData = uni.getStorageSync(cacheKey);
  if (!cacheData) return;
  
  // 3. 找到目标壁纸，更新收藏状态
  const updatedList = cacheData.dataList.map(item => {
    if (item.id === wallpaperId) {
      return { ...item, isCollected: true, likeCount: item.likeCount + 1 };
    }
    return item;
  });
  
  // 4. 覆盖更新缓存
  uni.setStorageSync(cacheKey, { ...cacheData, dataList: updatedList });
  
  // 5. UI即时反馈
  uni.showToast({ title: '收藏成功' });
  setCurrentWallpaper({ ...currentWallpaper, isCollected: true });
};
```

这种 “后台同步优先、缓存即时更新” 的逻辑，确保了预览页操作与本地缓存的强一致性，避免状态偏差。

#### 3.返回界面处理：同步数据 + 清理缓存，兼顾一致性与轻量化

当用户从预览页返回之前的列表界面时，需要完成 “数据同步显示” 和 “缓存清理” 两个核心动作 —— 既让列表页展示最新操作状态，又避免缓存长期占用本地空间（毕竟用户已完成当前分页浏览，后续再次访问可重新请求最新数据）。具体步骤：

1. **列表页数据同步**：列表页在 `onShow` 生命周期中，通过之前存储的 `cacheKey` 读取缓存的最新数据，直接用缓存中的 24 条数据更新列表数据源（无需重新请求接口），让用户立即看到预览页操作后的变化（如收藏按钮变色、点赞数更新）；
2. **缓存主动清理**：数据同步完成后，立即通过 `uni.removeStorageSync` 删除该 `cacheKey` 对应的缓存，避免同一分页数据重复缓存、占用本地存储资源；
3. 异常兜底：若缓存读取失败（如用户手动清除本地存储），则触发接口请求，拉取最新分页数据并渲染，确保列表页数据不空白。

```javascript
onShow() {
  const { cacheKey } = this.$route.query;
  if (!cacheKey) return;
  
  // 1. 读取缓存，同步最新数据到列表
  const cacheData = uni.getStorageSync(cacheKey);
  if (cacheData) {
    this.wallpaperList = cacheData.dataList; // 用缓存数据更新列表
  } else {
    // 缓存失效时，请求接口兜底
    this.fetchWallpaperList();
  }
  
  // 2. 同步完成后，清理缓存
  uni.removeStorageSync(cacheKey);
  // 清除路由参数中的cacheKey，避免重复处理
  this.$route.query.cacheKey = '';
}
```

这种 “返回即清理” 的设计，既通过缓存实现了 “零请求同步数据”，又避免了本地缓存堆积，让整个缓存逻辑更轻量化。

#### 4.总结

整个缓存方案以 `uni.setStorageSync` 为基础，围绕用户 “点击图片 - 预览操作 - 返回列表” 的交互链路，形成 “按需存储（用户点击时存）- 实时同步（操作时更）- 即时清理（返回时删）” 的闭环：既保证了操作状态的即时性和一致性，又避免了缓存冗余，在提升页面加载速度的同时，也兼顾了本地存储的轻量化，完全适配壁纸项目 “高频浏览、即时操作” 的业务特点。

### 4.问题3

> “预览图 + 原图” 分层加载中，WebP 格式相比传统 JPG/PNG 能节省多少带宽？你是如何处理 WebP 格式在部分旧设备上的兼容性问题的？另外，“智能预加载相邻 3 张图片” 是在用户点击当前图片后立即触发，还是等当前图片加载完成后再触发？预加载失败的图片会怎么处理（比如重试、显示占位图）？

#### 1.WebP 格式的带宽节省效果

在项目中，WebP 格式相比传统 JPG/PNG，**平均能节省 40%-60% 的带宽**，具体差异会因图片内容（色彩丰富度、细节复杂度）略有不同：

- 对于色彩鲜艳、细节丰富的壁纸（如风景、动漫类）：JPG 格式通常需要 200-500KB，转为 WebP 后仅需 80-200KB，带宽节省约 50%-60%；
- 对于线条简单、色彩单一的壁纸（如极简、文字类）：PNG 格式可能需要 100-300KB，转为 WebP 后可压缩至 40-120KB，带宽节省约 40%-55%。

这个数据是我通过项目实践统计的 —— 后台在生成图片时，会同时输出 JPG/PNG 原格式和 WebP 格式文件，前端加载后对比两者的文件大小，最终得出的平均节省比例。实际效果上，用户在 4G 网络下加载预览图的时间从平均 1.2 秒缩短到 0.5 秒，原图加载时间从平均 3.5 秒缩短到 1.5 秒，带宽消耗的降低直接带来了加载速度的提升。

#### 2.WebP 格式的兼容性处理方案

虽然 WebP 优势明显，但部分旧设备（如 iOS 14 及以下版本、安卓 7.0 及以下版本）不支持该格式，若直接加载会导致图片显示失败。项目中我通过 “**前端判断 + 后台适配**” 的双重方案解决兼容性问题：

1. 前端：提前判断设备是否支持 WebP

在应用初始化时，通过 “创建隐藏的 WebP 图片元素 + 监听加载状态” 的方式，检测当前设备是否支持 WebP 格式，代码逻辑如下：

```javascript
// 检测设备是否支持 WebP
const checkWebPSupport = () => {
  return new Promise(resolve => {
    const img = new Image();
    // 用 WebP 格式的测试图片（1x1 像素的透明图）
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
    img.onload = () => {
      // 若加载成功且宽度为1，说明支持 WebP
      resolve(img.width === 1);
    };
    img.onerror = () => {
      // 加载失败则不支持
      resolve(false);
    };
  });
};

// 应用初始化时执行检测，结果存入全局状态
checkWebPSupport().then(isSupport => {
  uni.setStorageSync('supportWebP', isSupport);
});
```

2. 前后端配合：根据支持情况返回对应格式图片

- 前端请求图片时，会在接口参数中携带 `supportWebP` 标识（如 `?supportWebP=true`）；
- 后台接收到请求后，若 `supportWebP` 为 `true`，则返回 WebP 格式图片的 URL；若为 `false`，则自动返回 JPG/PNG 格式图片的 URL；
- 同时，后台会对返回的图片 URL 做 “格式标识”（如 WebP 格式 URL 包含 `_webp` 后缀），前端若后续发现图片加载失败（极端场景，如检测结果误判），会自动替换 URL 中的格式标识，重试加载传统格式图片。

通过这种 “提前检测 + 动态返回” 的方案，项目中 WebP 格式的兼容性问题覆盖率降到了 0.3% 以下，几乎不影响用户体验。

#### 3.“智能预加载相邻 3 张图片” 的实现细节

1. 预加载触发时机：当前图片加载完成后触发

我没有选择 “用户点击当前图片后立即预加载”，而是等 “当前图片加载完成后” 再触发，核心原因是避免 “预加载抢占当前图片的网络资源”—— 若当前图片还在加载，就立即发起 3 个预加载请求，可能导致当前图片加载速度变慢，反而影响用户查看当前图片的体验。

具体逻辑是：

- 用户点击某张壁纸进入预览页后，先优先加载当前壁纸的原图；
- 监听当前原图的 `onload` 事件（加载完成），或 `onerror` 事件（加载失败但已处理重试）；
- 确认当前图片加载完成 / 处理完毕后，再获取 “当前图片在列表中的索引”，计算出相邻的前 1 张和后 2 张（或前 2 张和后 1 张，根据列表顺序调整）图片的原图 URL，发起预加载请求。

代码层面的核心逻辑：

```javascript
// 预览页当前图片加载完成后触发预加载
const handleCurrentImageLoad = () => {
  const { currentIndex, wallpaperList } = props;
  // 计算需要预加载的相邻图片索引（当前索引±1、±2，避免越界）
  const preloadIndexes = [currentIndex - 1, currentIndex + 1, currentIndex + 2]
    .filter(index => index >= 0 && index < wallpaperList.length);
  
  // 发起预加载请求
  preloadIndexes.forEach(index => {
    const img = new Image();
    img.src = wallpaperList[index].originalUrl; // 原图 URL
    // 预加载不显示，仅缓存到浏览器
    img.style.display = 'none';
    // 预加载失败不影响当前体验，仅打印日志
    img.onerror = () => {
      console.log(`预加载图片 ${wallpaperList[index].id} 失败`);
    };
  });
};
```

2. 预加载失败的处理方案

预加载失败后，我没有做 “自动重试”，而是采用 “**用户需要时再重试**” 的策略，原因是预加载本身是 “优化体验的附加操作”，失败后若自动重试，可能会占用额外网络资源，反而影响其他关键请求（如用户切换到下一张图片时的正常加载）。具体处理逻辑：

- **预加载失败时**：仅在控制台打印日志，不弹窗提示（避免打扰用户），同时在前端状态中标记 “该图片预加载失败”；
- **用户切换到该图片时**：若之前标记为 “预加载失败”，则直接发起正常的原图加载请求，同时显示 “加载中” 的占位图（用灰色背景 + 加载动画实现）；
- **若正常加载仍失败**：则显示 “加载失败，请点击重试” 的占位图，允许用户手动点击重试加载，重试时会切换到备用 CDN 的图片 URL（避免单 CDN 故障导致的持续失败）。

这种处理方式既保证了预加载失败不影响当前体验，又通过 “用户触发重试 + 备用 URL” 的方案，最大限度覆盖加载失败的场景。

#### 4.总结

整个 “预览图 + 原图” 分层加载方案，从 WebP 格式的带宽优化，到兼容性处理，再到预加载的细节设计，核心思路都是 “**在节省带宽的同时，优先保障当前用户的核心体验**”—— 不因为优化而牺牲加载速度，不因为预加载而影响当前操作，最终实现了 “带宽消耗降低 40%+，原图加载速度提升 57%，用户滑动预览时卡顿率下降 80%” 的效果，很好地适配了壁纸项目 “图片多、体积大” 的业务特点。

### 5.问题4

> 在 “lo 的壁纸分享室” 项目中，用户通过签到、转发邀新、观看视频获取能量以下载图片，这个能量体系在后台是如何进行数据存储和计算的？比如能量的增减记录是否有单独的表来维护，计算规则是否可灵活配置？

**1. 核心设计：两张表**

我主要设计了两张核心表来支撑整个能量体系：

- **用户表 (`user`)**：

  - 在用户表中，我会添加一个 `energy` 字段，用来记录用户当前拥有的能量总数。这是一个**冗余字段**，目的是为了快速查询用户当前能量，避免每次都去日志表中汇总，提升查询性能。

- **能量明细表 (`energy_log`)**：

  - 这张表是整个体系的 “心脏”，它会**记录用户每一次能量的增减**。

  - 它的核心字段包括：`user_id` (用户 ID), `amount` (能量变动值，正数为增，负数为减), `type` (操作类型，如 'SIGN_IN', 'WATCH_VIDEO', 'DOWNLOAD_WALLPAPER'), `created_at` (记录时间)。

  - 为什么这么设计？

     

    这样做有几个好处：

    - **数据可追溯**：任何能量的变动都有据可查，方便排查问题和处理用户申诉。
    - **规则解耦**：用户的当前能量可以通过 “用户表” 快速获取，而详细的历史记录和规则判断（比如今天签到了几次）则通过 “明细表” 来计算，职责清晰。
    - **灵活扩展**：未来如果增加了新的获取能量的方式（比如评论、分享），只需要在 `type` 字段中增加新的类型即可，扩展性很强。

**2. 核心业务逻辑**

- **下载壁纸（消耗能量）**：
  - 这个逻辑比较直接。在用户点击下载时，先查询 `user` 表中的 `energy` 字段。
  - 如果能量足够，就开启一个数据库事务，在事务中：
    1. 将 `user` 表中的 `energy` 字段减去消耗值。
    2. 向 `energy_log` 表中插入一条记录，`amount` 为负数，`type` 为 'DOWNLOAD_WALLPAPER'。
  - 如果能量不足，则前端弹出提示，引导用户去获取能量。
- **获取能量（签到、观看视频）**：
  - 这部分是规则判断的核心。当用户执行签到或观看视频等操作时，我会：
    1. **检查规则**：通过查询 `energy_log` 表，根据 `user_id`、`type` 和 `created_at`（限定今天）来统计今天该用户已经获取了多少次能量。
    2. 判断是否可领取：
       - 如果今天还没有领取过，或者领取次数没有达到上限，就允许领取。
       - 如果次数已达上限，则提示用户今天无法再领取。
    3. 执行领取：如果规则通过，同样在一个数据库事务中：
       - 将 `user` 表中的 `energy` 字段加上奖励值。
       - 向 `energy_log` 表中插入一条记录，`amount` 为正数，`type` 为 'SIGN_IN' 或 'WATCH_VIDEO'。

**3. 安全性与健壮性考虑**

- **使用数据库事务**：所有涉及能量增减的操作，我都会放在数据库事务中执行。这样可以保证数据的原子性，避免出现 “能量扣了但壁纸没下载成功” 或者 “视频看完了但没加上能量” 的情况。
- **防止并发问题**：对于像 “每日签到” 这种有严格次数限制的操作，我会在应用层使用**分布式锁**（比如基于 Redis 的锁）来防止用户通过快速点击等方式绕过次数限制。

**总结一下**：我的设计核心是**用一张 “用户表” 做快速查询，用一张 “明细表” 保证数据准确和可追溯**，并且通过**数据库事务**和**分布式锁**来确保整个能量体系在高并发下的稳定和安全。

### 6.问题5

> 你提到采用了 “预览图 + 原图” 的分层加载策略，还结合了懒加载和相邻图片预加载。想具体问问，你是怎么判断用户 “查看图片” 这个行为，从而触发高清原图加载的？另外预加载相邻 3 张图片的逻辑是怎么设计的？比如是根据当前图片在列表中的索引，去加载前后各 1 张还是其他规则？

在 “lo 的壁纸分享室” 项目里，“预览图 + 原图” 的加载触发逻辑和相邻预加载设计，我是结合用户交互场景和数据索引来实现的，具体逻辑如下：

首先是 “判断用户查看图片行为、触发原图加载” 的设计：小程序的图片列表页默认展示的是剪裁优化后的 WebP 预览图（分辨率压缩到 300px 宽，体积控制在 50KB 以内，保证列表滑动时加载速度）。当用户点击某张预览图时，会触发全屏图片查看器组件的弹窗事件 —— 这个点击动作就是我定义的 “查看图片” 核心触发点。此时，前端会先获取当前点击图片的唯一标识（比如图片 ID）和它在列表中的索引，然后调用封装好的图片请求接口，传入图片 ID 请求对应的 WebP 高清原图（分辨率根据设备屏幕尺寸适配，比如手机端加载 750px 宽、平板端加载 1080px 宽的资源，兼顾清晰度和加载速度）。同时，为了避免用户等待，我会在原图加载过程中，先保留预览图在查看器中显示，并用一个轻量的环形 Loading 提示 “正在加载高清图”，直到原图加载完成后再无缝替换，避免用户感知到加载间隙。

然后是 “相邻 3 张图片预加载” 的逻辑：核心是基于 “当前查看图片的列表索引” 来确定预加载范围。比如当前用户查看的是列表中索引为`index = 5`的图片，我会计算出需要预加载的索引范围是`index - 1`、`index + 1`、`index + 2`（也就是第 4、6、7 张图片）—— 选择 “前 1 张 + 后 2 张” 的组合，是因为考虑到用户浏览图片的习惯：大多是从当前图往后滑动查看，少数会回退查看前一张，这样的范围既能覆盖高频滑动场景，又不会一次性加载过多资源导致网络占用。具体实现上，当高清原图加载完成后，前端会自动执行预加载函数：先判断目标索引对应的图片是否已在缓存中（通过`uni.getStorage`检查是否有该图片 ID 的缓存记录），如果未缓存，就发起该图片的原图请求，并将加载后的图片资源存入内存缓存（用一个全局的`imageCache`对象，以图片 ID 为键存储图片 URL 和资源实例）；如果已缓存则直接跳过，避免重复请求。这样当用户滑动查看下一张时，预加载好的原图能瞬间显示，完全消除加载等待感。

整个设计的核心是 “按需触发 + 精准预加载”：既通过 “点击动作” 明确用户的查看需求，避免提前加载原图浪费流量；又通过 “索引关联的预加载范围” 匹配用户浏览习惯，在不增加过多网络开销的前提下，最大化提升高清图的浏览流畅度，这对小程序的用户留存也有明显帮助。

### 7.问题6

> 你说实现了统一管理 Loading 状态和精细化错误处理。那统一管理 Loading 状态时，比如用户同时发起多个请求，是每个请求都显示一个 Loading，还是合并成一个全局 Loading？另外 “精细化错误处理” 具体包含哪些场景？比如网络断开、后端返回 500 错误、接口返回业务错误（像能量不足），分别是怎么处理的？

### 一、统一管理 Loading 状态：区分 “全局 Loading” 与 “局部 Loading”，避免重复弹窗

考虑到用户可能同时发起多个请求（比如首页加载壁纸列表时，同时触发用户能量余额请求），如果每个请求都显示一个 Loading，会导致弹窗叠加，严重影响体验。因此我设计了 “按需选择 Loading 类型” 的方案：

1. 全局 Loading：用于页面级批量请求

   

   比如 “壁纸分类切换” 时，需要重新请求该分类下的所有壁纸数据，这类 “会改变页面核心内容” 的请求，会触发全局 Loading—— 用一个单例的 Loading 组件（基于 uniapp 的

   ```
   uni.showLoading
   ```

   二次封装），且通过请求拦截器添加 “请求计数”：每发起一个全局请求，计数 + 1；每完成一个请求，计数 - 1；只有当计数从 1 减到 0 时，才关闭全局 Loading。这样即使同时发起多个全局请求，也只会显示一个 Loading，避免重复弹窗。

2. 局部 Loading：用于组件级独立请求

   

   比如 “用户点击单个壁纸下载”（需请求扣除能量并返回下载链接），这类 “仅影响局部组件” 的请求，会在触发请求的按钮 / 组件旁显示局部 Loading（比如按钮上的加载动画），不干扰页面其他操作。实现上，我在请求封装时允许传入

   ```
   loadingType
   ```

   参数（

   ```
   global
   ```

   /

   ```
   local
   ```

   ），默认是

   ```
   global
   ```

   ，需要局部 Loading 时手动指定，灵活适配不同场景。

### 二、精细化错误处理：覆盖 “网络层 - 服务层 - 业务层” 三类错误，针对性反馈

我把错误分为三大类，每种场景都设计了不同的处理逻辑，既让用户清楚错误原因，也方便开发排查问题：

1. 网络层错误：无网络 / 请求超时

   

   通过 Axios 的

   ```
   timeout
   ```

   配置（设为 10 秒）和

   ```
   navigator.onLine
   ```

   判断网络状态：

- 若检测到无网络（`!navigator.onLine`），前端直接弹出轻提示 “当前网络不可用，请检查网络设置”，不发起无效请求；
- 若请求超时，提示 “请求超时，请稍后重试”，同时提供 “重新请求” 按钮，点击后自动重新发起原请求（通过缓存的请求参数实现）。

1. 服务层错误：后端返回 5xx/4xx 状态码

   

   通过响应拦截器捕获状态码：

- 5xx 错误（服务器异常）：不向用户暴露技术细节，统一提示 “服务暂时不稳定，请稍后再试”，同时在控制台打印详细错误信息（如请求 URL、响应内容），方便后续排查；
- 4xx 错误（客户端参数错误）：比如 “请求壁纸时未传分类 ID”，会解析后端返回的`msg`字段（如 “分类 ID 不能为空”），直接提示用户，引导修正操作（若为表单场景，会定位到对应输入框并标红提示）。

1. 业务层错误：接口返回成功但业务不通过（如能量不足）

   

   后端统一返回格式为

   ```
   { code: 200, success: false, msg: "xxx", data: {} }
   ```

   ，其中

   ```
   success: false
   ```

   代表业务错误：

- 针对 “下载壁纸时能量不足”，提示 “当前能量不足，可通过签到 / 观看视频获取”，并在提示框底部添加 “去获取能量” 按钮，点击后跳转到能量任务页面；
- 其他业务错误（如 “签到次数已达上限”），直接提示对应的`msg`内容，确保用户清楚当前操作为何无法完成。

整个设计的核心是 “既兼顾用户体验，又方便问题排查”——Loading 状态区分全局 / 局部，避免干扰用户操作；错误处理分层分类，既让用户能理解并应对错误，也为开发保留了关键调试信息，符合项目实际使用场景。
