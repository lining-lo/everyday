## 八股总结

### 回流与重绘

**回流**是浏览器重新计算元素几何属性、布局等，像改变元素尺寸、位置会触发；**重绘**是重新绘制元素视觉样式，如改颜色、背景等，只改样式不影响布局时发生，回流必定会导致重绘，重绘不一定引发回流。

> 一、回流（Reflow/Layout）
>
> 1. 概念
>
> 回流是指浏览器**重新计算元素的几何属性（位置、大小、尺寸等）并重新布局页面**的过程。当元素的布局信息（如宽高、边距、位置）发生变化时，浏览器需要重新计算整个页面或部分页面的布局，这个过程就是回流。
>
> 2. 触发条件
>
> 任何会改变元素几何属性或页面布局的操作都会触发回流，常见场景包括：
>
> - 页面首次加载（初始化渲染）；
> - 改变元素的宽高、边距、边框、内边距；
> - 改变元素的位置（如`top`/`left`、浮动、定位）；
> - 改变元素的显示状态（`display: none`/`block`）；
> - 改变窗口大小（`resize`事件）；
> - 滚动页面（部分浏览器会对固定定位元素触发回流）；
> - 修改 DOM 结构（添加 / 删除元素、修改元素层级）；
> - 读取某些布局属性（如`offsetWidth`/`offsetHeight`/`getBoundingClientRect()`）—— 浏览器为了获取准确值，会强制触发回流。
>
> 二、重绘（Repaint/Paint）
>
> 1. 概念
>
> 重绘是指浏览器**重新绘制元素的视觉样式（颜色、背景、阴影等），但不改变元素几何属性和布局**的过程。重绘只涉及样式的更新，不影响元素的位置和大小，因此开销比回流小。
>
> 2. 触发条件
>
> 仅改变元素的视觉样式，不影响布局时触发重绘，常见场景包括：
>
> - 修改元素的颜色（`color`）、背景（`background`）；
> - 修改元素的阴影（`box-shadow`/`text-shadow`）；
> - 修改元素的透明度（`opacity`）；
> - 修改元素的`outline`、`visibility`（`visibility: hidden`仅触发重绘，不触发回流）。
>
> 三、回流与重绘的关系
>
> - **回流必然导致重绘**：因为布局改变后，元素的视觉样式也需要重新绘制；
> - **重绘不一定导致回流**：仅修改视觉样式时，无需重新计算布局。
>
> **性能开销**：回流 > 重绘（回流涉及几何计算和布局，重绘仅涉及像素渲染）。
>
> 四、优化策略
>
> 减少回流和重绘的频率与范围，可显著提升页面性能：
>
> 1. 批量修改 DOM
>
> - 先将元素脱离文档流（如设置`display: none`），修改后再恢复；
> - 使用 DocumentFragment 暂存 DOM 操作，最后一次性插入页面；
> - 克隆元素（`cloneNode`），修改克隆体后替换原元素。
>
> 2. 避免频繁读取布局属性
>
> - 集中读取布局属性（如`offsetWidth`），避免在循环中反复读取（会强制触发多次回流）；
> - 缓存布局属性的值，后续复用。
>
> 3. 优化 CSS 样式
>
> - 使用`transform`（位移、缩放）代替直接修改`top`/`left`（`transform`由 GPU 加速，仅触发合成，不触发回流 / 重绘）；
> - 使用`opacity`代替`visibility`（`opacity`可通过 GPU 合成优化）；
> - 避免使用`table`布局（`table`的单元格修改易触发大面积回流）。
>
> 4. 减少元素层级
>
> 复杂的 DOM 层级会增加回流的计算量，尽量简化页面结构。
>
> 5. 使用 CSS 硬件加速
>
> 对频繁动画的元素，通过`transform: translateZ(0)`或`will-change: transform`开启 GPU 加速，将元素提升为独立图层，避免影响其他元素的回流 / 重绘。

### 浏览器加载css样式的过程

主要有加载、解析、渲染三个阶段。加载时发起请求获取CSS文件并并行下载；解析时构建CSSOM、DOM树，再结合二者计算样式；渲染时生成布局确定元素位置大小，绘制为像素，最后合成展示在页面 。 

> 浏览器将 CSS 加载并应用为页面可视样式的过程，是一个从**资源加载**到**最终渲染**的流水线式流程，涉及解析、建模、计算、布局、绘制等多个核心阶段。以下是详细拆解：
>
> 一、CSS 资源加载
>
> 浏览器解析 HTML 时，会触发 CSS 资源的获取：
>
> 1. **发现 CSS 资源**：遇到`<link rel="stylesheet">`（外部 CSS）、`<style>`标签（内联 CSS）或元素的`style`属性（行内样式）时，启动加载流程；
> 2. **外部 CSS 加载**：对`<link>`引用的外部 CSS，浏览器发起 HTTP 请求获取资源（可通过缓存、预加载等策略优化）；
> 3. **资源优先级**：CSS 属于 “渲染阻塞资源”，浏览器会优先加载 CSS（避免页面 “无样式闪烁”），若`<link>`设置`media="print"`等非当前媒体类型，不会阻塞渲染。
>
> 二、CSS 解析与 CSSOM 构建
>
> 加载完成的 CSS 文本会被解析为结构化的**CSS 对象模型（CSSOM）**，为后续样式计算提供基础：
>
> 1. **词法分析**：将 CSS 代码拆分为 “令牌（Token）”，例如`body`、`{`、`color`、`:`、`red`、`;`等；
>
> 2. **语法分析**：按 CSS 语法规则将令牌组装为**CSS 规则**（包含选择器和声明块）；
>
> 3. **构建 CSSOM 树**：以树形结构组织 CSS 规则，体现元素的继承关系和样式优先级。例如：
>
>    ```css
>    body { font-size: 16px; }
>    p { color: blue; }
>    ```
>
>    会生成如下 CSSOM 结构：
>
>    ```plaintext
>    CSSOM根节点
>    └── body
>        ├── font-size: 16px
>        └── p
>            └── color: blue
>    ```
>
>    CSSOM 的特点是**只读**且**包含继承规则**，子节点默认继承父节点的可继承样式（如`color`、`font-size`）。
>
> 三、样式计算（Computed Style）
>
> 结合 DOM 树和 CSSOM 树，为每个 DOM 节点计算**最终样式**：
>
> 1. **匹配 CSS 规则**：遍历 DOM 树节点，根据 CSSOM 中的选择器（类、ID、标签、伪类等），匹配该节点对应的所有 CSS 规则；
> 2. **解决样式冲突**：通过**优先级**、**层叠顺序**、**继承**确定最终样式：
>    - **优先级**：`!important` > 行内样式 > ID 选择器 > 类 / 伪类选择器 > 标签选择器 > 通配符；
>    - **层叠顺序**：同优先级下，后定义的规则覆盖先定义的规则；
>    - **继承**：子节点继承父节点的可继承属性（如`font-family`），不可继承属性（如`width`）需显式设置；
> 3. **单位转换**：将相对单位（`em`、`rem`、`%`）转为绝对像素值（`px`），例如`1.2em`（父元素`16px`）→ `19.2px`。
>
> 四、布局（Layout/Reflow）
>
> 计算 DOM 节点的几何属性（位置、大小），确定元素在页面中的布局：
>
> 1. **构建布局树**：基于 DOM 树生成，仅包含**可见元素**（`display: none`的元素被排除，`visibility: hidden`保留）；
> 2. 计算几何属性：从根节点开始递归计算每个元素的：
>    - 盒模型属性（`width`、`height`、`margin`、`padding`、`border`）；
>    - 位置属性（`top`、`left`、`float`、`position`）；
>    - 排版规则（`flex`、`grid`、`table`布局等）；
> 3. **处理布局规则**：如外边距合并、浮动清除、BFC（块格式化上下文）等，最终确定每个元素的精确位置和大小。
>
> 五、绘制（Paint）
>
> 将元素的视觉样式渲染为像素：
>
> 1. **生成绘制列表**：遍历布局树，为每个元素生成绘制指令（如 “绘制背景色”“绘制文本”“绘制边框”），并按**层叠顺序**（`z-index`、层叠上下文）排序；
> 2. **栅格化**：将绘制指令转换为屏幕像素。现代浏览器会将页面划分为多个**图层**（如`transform`、`opacity`动画元素会被提升为独立图层），每个图层单独栅格化，提升效率。
>
> 六、合成（Composite）
>
> 将所有图层按正确顺序合并为最终页面图像，显示在屏幕上：
>
> - 由浏览器的合成线程处理，避免主线程阻塞；
> - 若仅修改图层属性（如`transform`、`opacity`），可直接合成无需重排重绘，提升动画流畅性。
>
> 总结：完整流程
>
> ```plaintext
> CSS加载 → CSS解析 → 构建CSSOM → 样式计算（匹配规则+解决冲突）→ 布局（计算几何属性）→ 绘制（生成像素）→ 合成（图层合并）→ 页面展示
> ```
>
> 这一过程中，CSSOM 与 DOM 需同时构建完成才能生成渲染树，因此 CSS 加载会阻塞渲染（可通过`media`属性、异步加载等优化）；而布局和绘制的性能开销较大，开发中需减少不必要的回流（布局）和重绘。

### 事件循环

事件循环是 JS 实现异步编程的核心机制。JS 是单线程语言，主线程执行同步任务，遇到异步任务时，其回调函数会被分发到对应的任务队列（宏任务队列或微任务队列）。执行栈为空时，事件循环先检查微任务队列，执行所有微任务，再从宏任务队列取一个任务执行，如此循环。

> JavaScript 处理异步任务的核心依赖于**事件循环（Event Loop）**、**任务队列（Task Queue** 以及 **执行栈（Call Stack）** 的协作机制，结合不同类型的异步任务分类（宏任务 / 微任务）来实现非阻塞执行。下面详细拆解整个过程：
>
> 一、JS 的执行模型基础
>
> JavaScript 是**单线程**语言（只有一个主线程执行代码），但通过异步机制避免了阻塞。关键概念包括：
>
> - **执行栈（Call Stack）**：同步代码的执行场所，遵循 “后进先出” 原则，函数调用会压入栈，执行完弹出。
> - **任务队列（Task Queue）**：存放异步任务的回调函数，分为**宏任务队列（Macrotask Queue）\**和\**微任务队列（Microtask Queue）**。
> - **事件循环（Event Loop）**：持续监控执行栈和任务队列，当执行栈为空时，按规则将队列中的任务压入栈执行。
>
> 二、异步任务的分类
>
> 异步任务被分为两类，优先级不同：
>
> 1. 宏任务（Macrotask）
>
> - 常见类型：`setTimeout`/`setInterval`、`setImmediate`（Node.js）、I/O 操作（文件 / 网络请求）、UI 渲染、`script`标签中的整体代码。
> - 特点：优先级较低，每次事件循环仅执行一个宏任务。
>
> 2. 微任务（Microtask）
>
> - 常见类型：`Promise.then/catch/finally`、`async/await`（本质是 Promise 语法糖）、`queueMicrotask()`、`MutationObserver`（浏览器）、`process.nextTick`（Node.js，优先级更高）。
> - 特点：优先级高于宏任务，执行栈为空时会**清空所有微任务**后再执行宏任务。
>
> 三、事件循环的执行流程
>
> 1. **执行同步代码**：主线程执行执行栈中的同步代码，遇到异步任务时，不会立即执行其回调，而是将回调函数分发到对应的任务队列。
> 2. 执行栈为空时处理任务队列：
>    - 先检查**微任务队列**，将队列中所有微任务依次压入执行栈执行，直到微任务队列为空；
>    - 再从**宏任务队列**中取出**一个**宏任务压入执行栈执行；
> 3. **重复事件循环**：执行栈再次为空后，回到步骤 2，循环往复。
>
> 四、具体异步任务处理示例
>
> 以常见的异步场景为例，拆解执行步骤：
>
> ```javascript
> console.log('同步代码1'); // 同步任务
> 
> setTimeout(() => { // 宏任务
>   console.log('setTimeout回调');
> }, 0);
> 
> Promise.resolve().then(() => { // 微任务
>   console.log('Promise.then回调');
> });
> 
> console.log('同步代码2'); // 同步任务
> ```
>
> 执行过程：
>
> 1. 执行同步代码`console.log('同步代码1')`，输出→**同步代码 1**；
> 2. 遇到`setTimeout`，将回调加入**宏任务队列**；
> 3. 遇到`Promise.resolve().then`，将回调加入**微任务队列**；
> 4. 执行同步代码`console.log('同步代码2')`，输出→**同步代码 2**；
> 5. 执行栈为空，处理**微任务队列**：取出`Promise.then`回调执行，输出→**Promise.then 回调**（微任务队列清空）；
> 6. 处理**宏任务队列**：取出`setTimeout`回调执行，输出→**setTimeout 回调**；
> 7. 事件循环结束。
>
> 最终输出顺序：`同步代码1` → `同步代码2` → `Promise.then回调` → `setTimeout回调`
>
> 五、特殊情况：async/await 的处理
>
> `async/await`是 Promise 的语法糖，`await`后的代码会被包裹为`Promise.then`的微任务：
>
> ```javascript
> async function fn() {
>   console.log('async同步代码');
>   await Promise.resolve(); // 此处中断，后续代码转为微任务
>   console.log('await后代码');
> }
> 
> fn();
> console.log('外部同步代码');
> ```
>
> 执行过程：
>
> 1. 执行`fn()`，输出→**async 同步代码**；
> 2. 遇到`await`，暂停函数执行，将`await`后的代码（`console.log('await后代码')`）加入微任务队列；
> 3. 执行外部同步代码`console.log('外部同步代码')`，输出→**外部同步代码**；
> 4. 执行栈为空，处理微任务队列，输出→**await 后代码**。
>
> 六、浏览器与 Node.js 的差异
>
> - **浏览器**：微任务队列优先于宏任务，微任务包括`Promise.then`、`MutationObserver`等；
> - **Node.js**：微任务分为`process.nextTick`（优先级最高）和其他微任务（`Promise.then`等），宏任务还包括`setImmediate`、I/O 回调等，执行顺序细节略有不同（如`timer`阶段→`I/O`阶段→`check`阶段），但核心逻辑一致。
>
> 总结
>
> JS 通过**单线程 + 事件循环 + 任务队列**的机制处理异步：同步任务优先执行，异步任务按 “微任务优先于宏任务” 的规则进入队列等待，执行栈为空时依次处理，从而实现非阻塞的异步编程。这一机制是理解回调地狱、Promise、async/await 等异步模式的基础。

### promise 的原理

Promise 是异步处理的一种解决方案。它有三种状态：pending（进行中）、fulfilled（已解决，成功）、rejected（已解决，失败）。创建 Promise 时会传入一个执行器，里面有 resolve 和 reject 函数。当异步操作成功，调用 resolve，Promise 状态变为 fulfilled；失败就调用 reject，状态变成 rejected。可以用 then、catch、finally 等方法处理不同状态的结果。

> Promise 的原理核心围绕**状态机模型**、**回调队列管理**和**链式调用设计**展开，旨在解决异步操作的回调嵌套问题，提供可预测的异步流程控制。下面从核心机制、状态管理、回调处理、链式调用等维度详细拆解：
>
> 一、核心机制：状态机模型
>
> Promise 本质是一个**有限状态机**，通过状态的不可逆转换来管理异步操作的结果：
>
> - 三种状态：
>   - `pending`（等待中）：初始状态，异步操作未完成；
>   - `fulfilled`（已成功）：异步操作完成，产生成功值（`value`）；
>   - `rejected`（已失败）：异步操作出错，产生失败原因（`reason`）。
> - 状态转换规则：
>   - 只能从 `pending` → `fulfilled` 或 `pending` → `rejected`；
>   - 状态一旦改变，永久固定（不可逆），后续操作无法修改状态。
>
> 这种设计保证了异步操作的结果**唯一且可追溯**，避免回调多次执行的问题。
>
> 二、核心设计：回调延迟绑定与队列化
>
> Promise 解决了传统回调的 “回调地狱” 问题，关键在于**回调的延迟绑定和队列化管理**：
>
> 1. **回调延迟绑定**：异步操作的结果不会立即触发回调，而是在调用 `.then()`/`.catch()` 时才绑定回调函数；
> 2. **回调队列**：若 Promise 仍处于 `pending` 状态，`.then()` 绑定的回调会被存入队列；当状态变为 `fulfilled`/`rejected` 时，队列中的回调会按顺序执行；
> 3. **异步执行回调**：即使 Promise 状态已确定（非 `pending`），`.then()` 的回调仍会异步执行（浏览器中加入微任务队列），保证执行顺序的一致性。
>
> 三、链式调用的实现原理
>
> Promise 的链式调用是其核心优势，本质是**每次 `.then()` 都返回一个新的 Promise**，新 Promise 的状态由前一个回调的返回值决定：
>
> 1. **返回普通值**：新 Promise 立即进入 `fulfilled` 状态，将该值作为成功值；
> 2. **返回 Promise**：新 Promise 会 “继承” 该 Promise 的状态（等待其状态改变后同步结果）；
> 3. **抛出异常**：新 Promise 立即进入 `rejected` 状态，将异常作为失败原因。
>
> 例如：
>
> ```javascript
> Promise.resolve(1)
>   .then(v => v + 1) // 返回普通值2 → 新Promise状态fulfilled，value=2
>   .then(v => Promise.resolve(v * 2)) // 返回Promise → 新Promise状态fulfilled，value=4
>   .then(v => { throw new Error('err') }) // 抛异常 → 新Promise状态rejected
>   .catch(err => console.log(err)); // 捕获异常
> ```
>
> 四、简易实现：手写 Promise 理解原理
>
> 通过简化版 Promise 实现，可更直观理解底层逻辑：
>
> ```javascript
> class MyPromise {
>   constructor(executor) {
>     // 初始化状态和结果
>     this.state = 'pending';
>     this.value = undefined; // 成功值
>     this.reason = undefined; // 失败原因
>     // 回调队列：存储.then绑定的回调
>     this.onFulfilledCallbacks = [];
>     this.onRejectedCallbacks = [];
> 
>     // resolve函数：状态转为fulfilled，执行成功回调
>     const resolve = (value) => {
>       if (this.state === 'pending') {
>         this.state = 'fulfilled';
>         this.value = value;
>         // 异步执行回调（模拟微任务）
>         this.onFulfilledCallbacks.forEach(cb => queueMicrotask(() => cb(value)));
>       }
>     };
> 
>     // reject函数：状态转为rejected，执行失败回调
>     const reject = (reason) => {
>       if (this.state === 'pending') {
>         this.state = 'rejected';
>         this.reason = reason;
>         this.onRejectedCallbacks.forEach(cb => queueMicrotask(() => cb(reason)));
>       }
>     };
> 
>     // 执行executor，捕获同步异常
>     try {
>       executor(resolve, reject);
>     } catch (err) {
>       reject(err);
>     }
>   }
> 
>   // .then方法：绑定回调并返回新Promise
>   then(onFulfilled, onRejected) {
>     // 处理回调缺省（值穿透）
>     onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
>     onRejected = typeof onRejected === 'function' ? onRejected : r => { throw r };
> 
>     const newPromise = new MyPromise((resolve, reject) => {
>       // 状态已完成：直接执行回调
>       if (this.state === 'fulfilled') {
>         queueMicrotask(() => {
>           try {
>             const result = onFulfilled(this.value);
>             this._resolvePromise(newPromise, result, resolve, reject);
>           } catch (err) {
>             reject(err);
>           }
>         });
>       }
> 
>       if (this.state === 'rejected') {
>         queueMicrotask(() => {
>           try {
>             const result = onRejected(this.reason);
>             this._resolvePromise(newPromise, result, resolve, reject);
>           } catch (err) {
>             reject(err);
>           }
>         });
>       }
> 
>       // 状态pending：存入回调队列
>       if (this.state === 'pending') {
>         this.onFulfilledCallbacks.push((value) => {
>           try {
>             const result = onFulfilled(value);
>             this._resolvePromise(newPromise, result, resolve, reject);
>           } catch (err) {
>             reject(err);
>           }
>         });
> 
>         this.onRejectedCallbacks.push((reason) => {
>           try {
>             const result = onRejected(reason);
>             this._resolvePromise(newPromise, result, resolve, reject);
>           } catch (err) {
>             reject(err);
>           }
>         });
>       }
>     });
> 
>     return newPromise;
>   }
> 
>   // 处理回调返回值，衔接新Promise状态
>   _resolvePromise(newPromise, result, resolve, reject) {
>     // 避免循环引用
>     if (newPromise === result) {
>       return reject(new TypeError('Chaining cycle detected'));
>     }
>     // 若返回Promise，继承其状态
>     if (result instanceof MyPromise) {
>       result.then(resolve, reject);
>     } else {
>       // 普通值直接resolve
>       resolve(result);
>     }
>   }
> 
>   // .catch语法糖：等价于then(null, onRejected)
>   catch(onRejected) {
>     return this.then(null, onRejected);
>   }
> }
> ```
>
> 五、关键特性总结
>
> 1. **状态不可逆**：保证异步结果的唯一性；
> 2. **微任务执行**：`.then()` 回调加入微任务队列，优先级高于宏任务（如 `setTimeout`）；
> 3. **值穿透**：缺省回调时自动传递结果，简化链式调用；
> 4. **异常冒泡**：链式调用中异常可被后续 `.catch()` 捕获，无需每层单独处理。

### 0.1+0.2 !== 0.3

原因：JavaScript 采用 IEEE 754 标准存储数值，0.1 和 0.2 转二进制是无限循环小数，存储时截断导致非精确值，计算有精度丢失。方法：用 toFixed () 方法；使用 Number.EPSILON 设置误差范围判断；引入 math.js 或 bigNumber.js ；先乘 10 的倍数再除 10 。

> 一、为什么`0.1 + 0.2 !== 0.3`？
>
> 这是因为 JavaScript 采用**IEEE 754 标准的双精度浮点数**存储数值，而二进制无法精确表示`0.1`和`0.2`这样的十进制小数，导致计算时产生精度丢失。
>
> 具体原因：
>
> 1. **十进制转二进制的精度问题**：
>    - `0.1`的二进制是无限循环小数：`0.0001100110011...`
>    - `0.2`的二进制也是无限循环小数：`0.001100110011...`
>    - 双精度浮点数只能存储 64 位（其中 52 位存有效数字），因此会对这些无限循环的二进制数进行**舍入截断**，导致存储的`0.1`和`0.2`并非精确值。
> 2. **计算后的精度偏差**：截断后的`0.1`和`0.2`相加，结果是`0.30000000000000004`（而非精确的`0.3`），因此`0.1 + 0.2 !== 0.3`。
>
> 二、让`0.1 + 0.2 === 0.3`的解决办法
>
> 1. 四舍五入（常用）
>
> 通过`toFixed()`或手动四舍五入，保留合适的小数位数：
>
> ```javascript
> console.log((0.1 + 0.2).toFixed(1) === 0.3.toFixed(1)); // true
> console.log(Math.round((0.1 + 0.2) * 10) / 10 === 0.3); // true
> ```
>
> - `toFixed(n)`：保留`n`位小数（返回字符串，需注意类型转换）；
> - 乘以 10 的幂次后取整再除回：避免字符串操作，更灵活。
>
> 2. 转换为整数计算
>
> 将小数放大为整数（如乘以 10、100 等），计算后再缩小，避免浮点运算：
>
> ```javascript
> console.log((0.1 * 10 + 0.2 * 10) / 10 === 0.3); // true
> ```
>
> 3. 使用`Number.EPSILON`判断误差
>
> 利用 JavaScript 的最小精度值`Number.EPSILON`（约`2.22e-16`），判断两数差值是否小于该阈值：
>
> ```javascript
> const isEqual = (a, b) => Math.abs(a - b) < Number.EPSILON;
> console.log(isEqual(0.1 + 0.2, 0.3)); // true
> ```
>
> 4. 使用第三方库（复杂场景）
>
> 若涉及高精度计算（如金融场景），可使用`decimal.js`、`big.js`等库：
>
> ```javascript
> import Decimal from 'decimal.js';
> console.log(new Decimal(0.1).plus(0.2).equals(0.3)); // true
> ```

### http 协议

HTTP是超文本传输协议，是应用层协议，用于客户端和服务器通信。它无连接、无状态，工作在请求 - 响应模式，常见版本有HTTP/1.1、HTTP/2、HTTP/3 。 

> HTTP（HyperText Transfer Protocol，超文本传输协议）是**客户端与服务器之间进行数据通信的应用层协议**，是万维网（WWW）的核心协议。它定义了客户端（如浏览器）如何向服务器请求资源（如 HTML、图片、API 数据），以及服务器如何响应这些请求的规则。
>
> 以下从**核心特性、协议结构、请求 / 响应流程、版本演进、状态码、常见方法**等维度，系统性梳理 HTTP 协议的核心知识：
>
> 一、HTTP 的核心特性
>
> 1. **无连接**：
>    - 传统 HTTP/1.1 之前的版本是 “无连接” 的：每次请求 - 响应完成后，TCP 连接会关闭（后来通过`Connection: keep-alive`实现长连接优化）；
>    - 核心目的：减少服务器资源占用（早期 Web 以静态资源为主，短连接足够）。
> 2. **无状态**：
>    - 服务器不保存客户端的会话状态（如登录状态、浏览记录），每次请求都是独立的，客户端需通过`Cookie`、`Token`等方式携带身份信息；
>    - 优点：服务器设计简单、可扩展性强；缺点：需额外机制维护会话（如 Session+Cookie）。
> 3. **基于请求 - 响应模型**：
>    - 只有客户端发起请求，服务器才会响应（HTTP/2.0 的 Server Push 是例外，可主动推送关联资源）；
>    - 请求由客户端发送，响应由服务器返回，一一对应。
> 4. **可扩展**：
>    - 支持自定义头部（如`X-Requested-With: XMLHttpRequest`标识 AJAX 请求）、方法、状态码；
>    - 可通过 HTTPS（HTTP+TLS）实现加密传输，通过代理服务器扩展功能（如缓存、负载均衡）。
>
> 二、HTTP 的协议结构
>
> HTTP 协议的通信内容由**请求报文**和**响应报文**组成，两者结构相似，均为 “文本格式”（HTTP/2.0 改为二进制帧，但逻辑结构兼容）。
>
> 1. 请求报文结构（客户端→服务器）
>
> ```plaintext
> 请求行（Request Line） → 方法 路径 协议版本（如：GET /index.html HTTP/1.1）
> 请求头（Request Headers） → 键值对形式，多个头部（如：Host: www.example.com、User-Agent: Chrome/120.0.0.0）
> 空行（CRLF） → 分隔请求头和请求体
> 请求体（Request Body） → 可选，用于POST/PUT等方法传递数据（如表单数据、JSON字符串）
> ```
>
> **示例（GET 请求，无请求体）**：
>
> ```plaintext
> GET /api/users HTTP/1.1
> Host: www.example.com
> User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
> Accept: application/json
> Cookie: sessionId=abc123
> ```
>
> **示例（POST 请求，有请求体）**：
>
> ```plaintext
> POST /api/login HTTP/1.1
> Host: www.example.com
> Content-Type: application/json
> Content-Length: 43
> 
> {"username": "admin", "password": "123456"}
> ```
>
> 2. 响应报文结构（服务器→客户端）
>
> ```plaintext
> 状态行（Status Line） → 协议版本 状态码 状态描述（如：HTTP/1.1 200 OK）
> 响应头（Response Headers） → 键值对形式，多个头部（如：Content-Type: text/html、Cache-Control: max-age=3600）
> 空行（CRLF） → 分隔响应头和响应体
> 响应体（Response Body） → 可选，返回客户端请求的资源（如HTML、JSON、图片二进制数据）
> ```
>
> **示例（成功响应）**：
>
> ```plaintext
> HTTP/1.1 200 OK
> Content-Type: application/json
> Content-Length: 52
> Date: Wed, 20 Nov 2024 10:00:00 GMT
> 
> {"code": 200, "msg": "success", "data": {"id": 1, "name": "admin"}}
> ```
>
> **示例（错误响应）**：
>
> ```plaintext
> HTTP/1.1 404 Not Found
> Content-Type: text/html
> Content-Length: 150
> 
> <html>
>   <body>
>     <h1>404 Not Found</h1>
>     <p>The requested resource does not exist.</p>
>   </body>
> </html>
> ```
>
> 三、HTTP 的请求 / 响应流程
>
> 以 “浏览器访问网页” 为例，完整流程如下：
>
> 1. **DNS 解析**：客户端将域名（如[www.example.com](https://www.example.com/)）解析为服务器 IP 地址；
> 2. **TCP 连接**：客户端与服务器建立 TCP 连接（三次握手）；
> 3. **发送 HTTP 请求**：客户端构造请求报文，通过 TCP 连接发送给服务器；
> 4. **服务器处理请求**：服务器解析请求报文，执行业务逻辑（如查询数据库、读取文件）；
> 5. **返回 HTTP 响应**：服务器构造响应报文，通过 TCP 连接返回给客户端；
> 6. **关闭 TCP 连接**：若为短连接，响应完成后关闭 TCP 连接（四次挥手）；若为长连接（`Connection: keep-alive`），连接可复用；
> 7. **客户端渲染**：浏览器解析响应体（如 HTML、CSS、JS），展示页面。
>
> 四、HTTP 的版本演进（核心差异）
>
> HTTP 协议自 1991 年诞生以来，经历了多次重大版本更新，核心差异如下：
>
> | 版本     | 发布时间 | 核心特性                                                     | 局限性                                                       |
> | -------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | HTTP/0.9 | 1991     | 仅支持 GET 方法，无请求头 / 响应头，仅返回 HTML 文本         | 功能极简，不支持图片、表单、状态码                           |
> | HTTP/1.0 | 1996     | 支持 GET/POST/PUT 等方法，新增请求头 / 响应头（如 Content-Type），支持多类型数据 | 无长连接，每次请求需建立 TCP 连接，效率低                    |
> | HTTP/1.1 | 1999     | 支持长连接（keep-alive）、管道化请求、Chunked 编码、Host 头部（虚拟主机） | 队头阻塞（同一连接串行执行请求）、头部冗余、无多路复用       |
> | HTTP/2.0 | 2015     | 二进制帧、单连接多路复用、头部压缩（HPACK）、服务器推送、流级流量控制 | 依赖 TLS（主流浏览器仅支持加密传输），仍基于 TCP（存在 TCP 队头阻塞） |
> | HTTP/3.0 | 2022     | 基于 QUIC 协议（UDP 之上），彻底解决队头阻塞、0-RTT 握手、连接迁移 | 生态尚未完全成熟，部分服务器 / 中间件支持不足                |
>
> **当前主流**：HTTP/1.1（兼容性最好）和 HTTP/2.0（性能更优，主流网站已广泛采用）。
>
> 五、HTTP 的核心概念
>
> 1. 常见请求方法（Method）
>
> 请求方法定义了客户端对服务器资源的操作意图，HTTP/1.1 支持的核心方法如下：
>
> | 方法    | 作用                                    | 特点                                       |
> | ------- | --------------------------------------- | ------------------------------------------ |
> | GET     | 获取服务器资源（如网页、API 数据）      | 幂等（多次请求结果一致）、可缓存、无请求体 |
> | POST    | 向服务器提交数据（如表单、上传文件）    | 非幂等、不可缓存、有请求体                 |
> | PUT     | 替换服务器资源（全量更新）              | 幂等、可缓存（需配合 ETag）                |
> | DELETE  | 删除服务器资源                          | 幂等、不可缓存                             |
> | HEAD    | 仅获取响应头（不返回响应体）            | 与 GET 功能一致，仅无响应体                |
> | OPTIONS | 询问服务器支持的方法 / 头部             | 用于跨域预检（CORS）                       |
> | PATCH   | 部分更新服务器资源（HTTP/1.1 后续扩展） | 非幂等、不可缓存                           |
>
> **幂等性**：多次执行同一请求，服务器状态不变（如 GET、PUT、DELETE，POST 非幂等）。
>
> 2. 状态码（Status Code）
>
> 状态码用于表示服务器对请求的处理结果，分为 5 大类：
>
> | 类别 | 状态码范围 | 含义                               | 常见状态码                                                   |
> | ---- | ---------- | ---------------------------------- | ------------------------------------------------------------ |
> | 1xx  | 100-199    | 信息性响应（请求已接收，继续处理） | 100 Continue（预检后继续）                                   |
> | 2xx  | 200-299    | 成功响应（请求已处理完成）         | 200 OK（成功）、204 No Content（无响应体）                   |
> | 3xx  | 300-399    | 重定向（需客户端进一步操作）       | 301 永久重定向、302 临时重定向、304 Not Modified（缓存命中） |
> | 4xx  | 400-499    | 客户端错误（请求无效）             | 400 Bad Request（请求参数错误）、401 未授权、403 禁止访问、404 资源不存在 |
> | 5xx  | 500-599    | 服务器错误（服务器处理失败）       | 500 内部服务器错误、502 网关错误、503 服务不可用、504 网关超时 |
>
> 3. 核心头部字段（Headers）
>
> 头部字段是 HTTP 报文的关键，用于传递请求 / 响应的元信息，常见核心头部如下：
>
> | 类别     | 常见头部                                           | 作用                                                     |
> | -------- | -------------------------------------------------- | -------------------------------------------------------- |
> | 通用头部 | Date、Connection、Cache-Control                    | 日期、连接状态、缓存控制                                 |
> | 请求头部 | Host、User-Agent、Accept、Cookie、Authorization    | 目标主机、客户端标识、可接收数据类型、会话信息、身份认证 |
> | 响应头部 | Content-Type、Content-Length、Location、Set-Cookie | 响应体类型、响应体长度、重定向地址、设置 Cookie          |
> | 实体头部 | ETag、Last-Modified、Expires                       | 资源标识、最后修改时间、过期时间                         |
>
> **示例**：
>
> - `Cache-Control: max-age=3600`：响应体缓存 1 小时；
> - `Content-Type: application/json; charset=utf-8`：响应体为 JSON 格式，编码 UTF-8；
> - `Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`：JWT 令牌认证。
>
> 4. 缓存机制
>
> HTTP 缓存是优化性能的核心手段，通过减少网络请求提升响应速度，核心机制如下：
>
> - **强缓存**：客户端直接从本地缓存读取资源，不发送请求到服务器（如`Expires`、`Cache-Control: max-age`）；
> - **协商缓存**：客户端发送请求到服务器，服务器判断资源是否更新，未更新则返回 304（客户端使用本地缓存），已更新则返回新资源（如`Last-Modified/If-Modified-Since`、`ETag/If-None-Match`）。
>
> 六、HTTPS：HTTP 的安全版本
>
> HTTP 协议默认明文传输，存在数据被窃听、篡改、伪造的风险，因此诞生了 HTTPS（HTTP over TLS）：
>
> - **原理**：在 HTTP 和 TCP 之间增加 TLS（Transport Layer Security）加密层，对数据进行加密、身份认证、完整性校验；
> - **核心优势**：数据加密（防窃听）、身份认证（防伪造）、完整性校验（防篡改）；
> - **通信流程**：TCP 三次握手 → TLS 握手（协商加密算法、交换密钥） → HTTP 通信 → TLS 关闭 → TCP 四次挥手。
>
> 现在主流网站均已采用 HTTPS（浏览器地址栏显示小锁图标），HTTP 协议逐渐被淘汰。
>
> 七、总结
>
> HTTP 协议是 Web 的基石，核心是 “请求 - 响应” 模型，通过文本（或二进制）报文传递数据。其发展趋势是**更高效、更安全、更低延迟**（从 HTTP/1.1 到 HTTP/3.0）。
>
> 对于前端开发者而言，需重点掌握：
>
> - 请求 / 响应报文结构；
> - 常见方法、状态码、头部字段；
> - 缓存机制（优化首屏加载）；
> - HTTPS 的安全特性；
> - 版本演进的核心优化点（如 HTTP/2.0 的多路复用）。
>
> 理解 HTTP 协议的底层逻辑，能帮助你更好地排查接口问题、优化网络性能、设计可靠的前后端交互方案。

### HTTP1.1 和 HTTP2 的区别

HTTP2用二进制格式传输，支持多路复用，能压缩头部，还可服务器推送，安全性更高；HTTP1.1是文本格式传输，不支持这些，且有队头阻塞问题。

- 把数据压缩成二进制帧起了一个什么样的效果？

  便于计算机高效解析，减少歧义，实现多路复用，降低延迟，提高连接利用率，还能减少传输数据量和带宽消耗。

- HTTP2.0 有没有彻底解决队头阻塞问题？

  没有彻底解决。HTTP2.0 虽通过多路复用解决了应用层队头阻塞，但因仍基于 TCP 协议，若 TCP 数据包丢失或延迟，会导致传输层队头阻塞，使同一连接上所有请求被阻塞 。

> HTTP/1.1 和 HTTP/2 的核心差异集中在 **性能优化** 上 ——HTTP/2 针对 HTTP/1.1 在现代 Web 场景下的瓶颈（如队头阻塞、冗余开销）进行了根本性重构，以下是结构化对比和关键细节解析：
>
> 一、核心差异总览表
>
> | 对比维度                 | HTTP/1.1                                     | HTTP/2.0                                         |
> | ------------------------ | -------------------------------------------- | ------------------------------------------------ |
> | 传输方式                 | 基于文本（ASCII 编码），明文传输             | 基于二进制帧（Binary Framing），二进制编码       |
> | 并发机制                 | 单连接串行传输，依赖多 TCP 连接（6-8 个）    | 单连接多路复用（Multiplexing）                   |
> | 队头阻塞（HOL Blocking） | 存在（同一连接中请求排队，前一个阻塞后一个） | 不存在（帧独立传输，互不影响）                   |
> | 头部传输                 | 明文重复传输，无压缩                         | 头部压缩（HPACK 算法），减少冗余                 |
> | 服务器推送               | 不支持（只能被动响应请求）                   | 支持（Server Push），主动推送关联资源            |
> | 流量控制                 | 基于 TCP 流量控制（连接级）                  | 基于流的流量控制（帧级、双向）                   |
> | 安全性                   | 可选 HTTPS（默认明文）                       | 推荐 HTTPS（主流浏览器仅支持 TLS 加密的 HTTP/2） |
> | 兼容性                   | 所有客户端 / 服务器均支持                    | 需浏览器、服务器、中间件（如 Nginx）支持         |
> | 优先级控制               | 无（仅依赖多连接顺序）                       | 支持流优先级（关键资源优先传输）                 |
>
> 二、关键差异深度解析
>
> 1. 传输方式：文本 vs 二进制（性能基石）
>
> - HTTP/1.1：协议头和数据都是 **明文文本格式**，解析时需要处理换行符、空格等歧义字符，效率低；且文本传输易被中间设备（如代理）篡改，容错性差。
> - HTTP/2.0：采用 **二进制帧（Binary Frame）** 作为最小传输单位，所有数据（头部、正文）都拆分为帧：
>   - 帧包含 `类型`（头部 / 数据）、`长度`、`流 ID`（标识所属请求）等元信息；
>   - 二进制编码无歧义，计算机解析速度比文本快 10 倍以上；
>   - 为多路复用、头部压缩等核心优化奠定基础。
>
> 2. 并发机制：多连接 vs 单连接多路复用（核心优化）
>
> 这是两者最核心的区别，直接解决了 HTTP/1.1 的 “队头阻塞” 问题：
>
> - HTTP/1.1：同一 TCP 连接中，请求必须 **串行执行**（先发送请求 A，等待响应后再发送请求 B）。若请求 A 阻塞（如大文件传输、网络延迟），后续请求都会排队（队头阻塞）。为解决并发，浏览器会建立 **6-8 个 TCP 连接**，但多连接带来额外开销：
>
>   - TCP 三次握手、四次挥手的连接成本；
>   - TCP 慢启动（初始传输速率低）；
>   - 带宽竞争（多连接抢占同一网络带宽）。
>
> - HTTP/2.0：基于 **单 TCP 连接** 实现 **多路复用**：
>
>   - 每个请求 / 响应封装为独立的 “流（Stream）”，分配唯一流 ID；
>
>   - 多个流的帧在同一 TCP 连接中 **并行传输**，接收方通过流 ID 重组数据；
>
>   - 支持流优先级（如 CSS/JS 优先于图片传输），进一步优化首屏加载。
>
>     优势：彻底解决队头阻塞，减少 TCP 连接数，降低 30%-50% 网络延迟。
>
> 3. 头部传输：重复明文 vs HPACK 压缩（带宽优化）
>
> HTTP/1.1 的头部存在严重冗余：
>
> - 每次请求都会重复传输 `Host`、`User-Agent`、`Cookie` 等固定头部，占请求体积的 40%-60%；
>
> - 明文传输无压缩，浪费带宽（尤其移动端）。
>
> - **HTTP/2.0** 引入 **HPACK 压缩算法**：
>
>   - 静态字典：预定义常见头部（如 `GET`、`Host`），用 1 字节索引替代完整字段；
>
>   - 动态字典：记录当前连接中频繁出现的自定义头部（如 `Token`），实时更新；
>
>   - 哈夫曼编码：对头部值进行压缩（如长 Cookie 字符串）。
>
>     实测：头部体积减少 50%-90%，移动端场景带宽节省效果显著。
>
> 4. 服务器推送（Server Push）：被动响应 vs 主动推送
>
> - **HTTP/1.1**：“请求 - 响应” 模型，服务器只能被动响应。例如：
>
>   1. 客户端请求 `index.html`；
>   2. 服务器返回 `index.html`；
>   3. 客户端解析后，再请求 `style.css`、`app.js`（额外 2 次网络往返）。
>
> - **HTTP/2.0** 支持 **Server Push**：
>
>   服务器响应 `index.html` 时，可主动推送 `style.css`、`app.js` 等关联资源，无需客户端额外请求，减少 1-2 次网络往返，首屏加载速度提升 20%-30%。
>
>   注意：推送资源需是客户端真正需要的，否则会浪费带宽（可通过 `SETTINGS_ENABLE_PUSH` 禁用）。
>
> 5. 流量控制：连接级 vs 流级（精细控制）
>
> - **HTTP/1.1**：依赖 TCP 流量控制（滑动窗口），但 TCP 是 “连接级” 控制，无法区分不同请求的优先级（如大文件传输会占用整个连接带宽）。
>
> - **HTTP/2.0**：实现 **基于流的流量控制**：
>
>   - 每个流有独立的流量控制窗口（接收方告知发送方 “最多能处理多少帧”）；
>
>   - 双向控制（客户端→服务器、服务器→客户端均可调节）；
>
>   - 支持暂停 / 恢复流（如客户端缓存已满时，暂停接收非关键资源）。
>
>     优势：避免单个大请求占用所有带宽，保证关键资源优先传输。
>
> 6. 安全性：可选 HTTPS vs 强制 HTTPS（生态趋势）
>
> - **HTTP/1.1**：默认明文传输，HTTPS 是可选配置（需额外部署 TLS 证书）。
>
> - **HTTP/2.0**：协议本身不强制加密，但主流浏览器（Chrome、Firefox、Safari）仅支持 “TLS 加密的 HTTP/2”（即 `https://`），不支持明文 `http://` 协议。
>
>   原因：二进制帧易被中间设备篡改，TLS 加密能保证协议稳定性和数据安全，目前所有主流网站的 HTTP/2 均基于 HTTPS 部署。
>
> 三、实际应用场景对比
>
> | 场景                  | HTTP/1.1 表现                   | HTTP/2.0 表现                         |
> | --------------------- | ------------------------------- | ------------------------------------- |
> | 复杂页面（多资源）    | 多连接串行，首屏加载慢          | 单连接多路复用 + 推送，加载快         |
> | 移动端 / 弱网环境     | 头部冗余 + 多连接，带宽浪费严重 | HPACK 压缩 + 单连接，省带宽           |
> | 大文件传输（视频）    | 阻塞其他请求，体验差            | 流级优先级 + 流量控制，不影响其他请求 |
> | 高并发接口请求（API） | 多连接竞争，响应延迟高          | 多路复用，并发无阻塞                  |
>
> 四、开发者关心的兼容性与迁移
>
> 1. **向下兼容**：HTTP/2 兼容 HTTP/1.1 的 API（如请求方法、状态码、头部字段），无需修改业务代码；
> 2. **迁移成本低**：只需服务器和中间件支持（如 Nginx 1.9.5+、Apache 2.4.17+），客户端自动协商版本（通过 TLS 握手时的 ALPN 协议）；
> 3. **常见问题**：
>    - 中间件（如代理、CDN）需支持 HTTP/2，否则会降级为 HTTP/1.1；
>    - 部分老旧浏览器（如 IE11）不支持 HTTP/2，需做好降级兼容。
>
> 五、总结
>
> HTTP/2 的核心目标是 **“更高效、更省带宽、更低延迟”**，通过二进制帧、多路复用、头部压缩、服务器推送四大核心特性，解决了 HTTP/1.1 在现代 Web 场景（多资源、移动优先、高并发）下的性能瓶颈。
>
> - 对于用户：页面加载更快、响应更流畅，弱网环境体验提升明显；
> - 对于开发者：无需修改代码，仅需服务器升级即可享受性能提升；
> - 对于企业：降低带宽成本，提升用户留存率（加载速度每快 1 秒，转化率提升 7%）。
>
> 补充：HTTP/3 已推出（基于 QUIC 协议，UDP 之上），进一步解决 TCP 队头阻塞，但 HTTP/2 仍是目前生产环境的主流选择（兼容性和稳定性更优）。

### DNS域名解析的过程

先查本地缓存，没有就找本地 DNS 服务器，它若没有就向根域名服务器请求，根域名服务器告知顶级域名服务器地址，接着找顶级域名服务器，它再给出权威域名服务器地址，最后从权威域名服务器获取域名对应的 IP 地址。

> DNS（Domain Name System，域名系统）的核心作用是**将人类易记的域名（如 [www.google.com](https://www.google.com/)）转换为计算机可识别的 IP 地址（如 142.250.185.142）**，是互联网通信的 “地址簿”。其解析过程是一个**递归查询 + 迭代查询**结合的分布式查询流程，具体步骤如下：
>
> 一、DNS 解析的核心概念铺垫
>
> 在理解过程前，需先明确几个关键角色：
>
> 1. **本地 DNS 服务器**：由你的网络服务商（ISP，如电信、联通）或企业 / 路由器提供的 DNS 服务器（如 114.114.114.114、8.8.8.8），是解析的 “中间人”；
> 2. **根 DNS 服务器**：全球共 13 组（逻辑上），是 DNS 系统的 “顶层”，只存储顶级域名服务器（如 .com、.cn）的 IP 地址；
> 3. **顶级域名服务器（TLD Server）**：负责管理顶级域名（如 .com、.org、.cn），存储二级域名服务器的 IP 地址；
> 4. **权威 DNS 服务器**：域名的 “官方服务器”，存储该域名的最终 IP 地址（由域名服务商如阿里云、腾讯云提供）；
> 5. **本地缓存**：包括浏览器缓存、操作系统缓存、路由器缓存，用于加速重复解析。
>
> 二、DNS 解析的完整过程（以访问 [www.google.com](https://www.google.com/) 为例）
>
> 步骤 1：检查本地缓存（最快路径）
>
> 当浏览器输入 `www.google.com` 后，会按以下顺序检查缓存，若命中则直接返回 IP，无需后续步骤：
>
> 1. **浏览器缓存**：浏览器会缓存近期解析过的域名（如 Chrome 缓存 1 分钟 - 1 小时，可通过 `chrome://net-internals/#dns` 查看）；
> 2. **操作系统缓存**：若浏览器缓存未命中，会查询操作系统的 DNS 缓存（如 Windows 的 `hosts` 文件、Linux 的 `/etc/hosts`，可手动配置域名 - IP 映射）；
> 3. **路由器缓存**：操作系统缓存未命中，会查询路由器的 DNS 缓存（路由器会缓存常用域名解析结果）。
>
> 步骤 2：向本地 DNS 服务器发起递归查询
>
> 若本地缓存未命中，浏览器会向 **本地 DNS 服务器** 发送解析请求（递归查询：本地 DNS 服务器需返回最终 IP，而非中间结果）。例如：你的本地 DNS 服务器是 ISP 提供的 `223.5.5.5`（阿里云 DNS）。
>
> 步骤 3：本地 DNS 服务器查询根 DNS 服务器（迭代查询）
>
> 本地 DNS 服务器若自身缓存无结果，会向 **根 DNS 服务器** 发起查询（迭代查询：根服务器仅返回下一级服务器地址，而非最终结果）：
>
> 1. 本地 DNS 服务器向根 DNS 服务器（如 `198.41.0.4`）发送请求：“请告诉我 `www.google.com` 的 IP 地址”；
> 2. 根 DNS 服务器识别到域名的顶级域是 `.com`，返回 **.com 顶级域名服务器** 的 IP 地址（如 `192.5.6.30`）。
>
> 步骤 4：本地 DNS 服务器查询顶级域名服务器
>
> 本地 DNS 服务器向 `.com 顶级域名服务器` 发送请求：“请告诉我 `www.google.com` 的 IP 地址”；
>
> - 顶级域名服务器识别到二级域是 `google.com`，返回 **[google.com](https://google.com/) 权威 DNS 服务器** 的 IP 地址（如 `ns1.google.com`）。
>
> 步骤 5：本地 DNS 服务器查询权威 DNS 服务器
>
> 本地 DNS 服务器向 `google.com` 的权威 DNS 服务器发送请求：“请告诉我 `www.google.com` 的 IP 地址”；
>
> - 权威 DNS 服务器存储了 `www.google.com` 的域名解析记录（A 记录：IPv4 地址，AAAA 记录：IPv6 地址），返回最终 IP 地址（如 `142.250.185.142`）。
>
> 步骤 6：本地 DNS 服务器缓存并返回结果
>
> 1. 本地 DNS 服务器将权威 DNS 服务器返回的 IP 地址 **缓存**（默认缓存时间由域名的 TTL（Time To Live）决定，通常为几分钟到几小时）；
> 2. 本地 DNS 服务器将 IP 地址返回给浏览器。
>
> 步骤 7：浏览器发起 HTTP 请求
>
> 浏览器拿到 IP 地址后，与目标服务器建立 TCP 连接，后续发起 HTTP/HTTPS 请求，加载网页资源。
>
> 三、DNS 解析的关键细节
>
> 1. 递归查询 vs 迭代查询
>
> - 递归查询：客户端（浏览器 / 本地 DNS 服务器）向服务器发送请求后，服务器需返回 “最终结果”（IP 地址或 “不存在”），客户端无需后续操作；
>   - 场景：浏览器 → 本地 DNS 服务器（递归）；
> - 迭代查询：客户端向服务器发送请求后，服务器仅返回 “下一级服务器地址”，客户端需自行向下一级服务器查询，直到拿到最终结果；
>   - 场景：本地 DNS 服务器 → 根服务器 → 顶级域名服务器 → 权威服务器（迭代）。
>
> 2. TTL（Time To Live）：缓存有效期
>
> - 每个 DNS 解析记录都有 TTL 值（单位：秒），表示缓存的有效期；
> - 本地 DNS 服务器、浏览器等会在 TTL 过期后，重新发起解析请求，保证 IP 地址的时效性（如域名更换服务器后，解析结果能及时更新）。
>
> 3. 解析记录类型
>
> - **A 记录**：将域名映射到 IPv4 地址（最常用）；
> - **AAAA 记录**：将域名映射到 IPv6 地址；
> - **CNAME 记录**：将域名映射到另一个域名（如 `www.google.com` → `google.com`），需二次解析；
> - **MX 记录**：用于邮件服务，映射到邮件服务器地址；
> - **NS 记录**：指定该域名的权威 DNS 服务器地址。
>
> 4. DNS 负载均衡
>
> - 权威 DNS 服务器可返回多个 IP 地址（对应同一域名的不同服务器节点）；
> - 本地 DNS 服务器会按一定策略（如轮询、就近原则）选择一个 IP 返回给客户端，实现负载均衡（如 `www.taobao.com` 会解析到不同地区的服务器 IP）。
>
> 5. DNS 劫持与污染
>
> - **DNS 劫持**：本地 DNS 服务器被篡改，返回错误的 IP 地址（如将 `www.baidu.com` 解析到恶意网站）；
> - **DNS 污染**：在 DNS 查询过程中，中间网络设备（如路由器、网关）篡改查询结果，强制解析到指定 IP；
> - 解决方案：使用可信的公共 DNS（如 8.8.8.8、1.1.1.1）、开启 DNS-over-TLS（DoT）或 DNS-over-HTTPS（DoH）加密解析。
>
> 四、DNS 解析的优化方式
>
> 1. **缩短 TTL**：若域名 IP 频繁变更，可缩短 TTL（如 1 分钟），保证解析结果及时更新；
> 2. **开启 DNS 预解析**：浏览器可通过 `<link rel="dns-prefetch" href="https://www.google.com">` 提前解析域名，减少后续请求延迟；
> 3. **使用 CDN**：CDN 会将域名解析到就近的节点 IP，同时 CDN 厂商的 DNS 服务器响应更快；
> 4. **避免 CNAME 嵌套**：CNAME 记录需二次解析，嵌套过多会增加解析时间，尽量直接使用 A 记录；
> 5. **加密解析**：使用 DoT/DoH 协议，防止 DNS 查询被窃听或篡改。
>
> 五、总结
>
> DNS 解析的核心流程是 **“本地缓存 → 本地 DNS 服务器递归查询 → 根 / 顶级 / 权威服务器迭代查询 → 返回 IP 并缓存”**，本质是一个分布式的地址查询系统。理解其过程有助于排查网络问题（如域名无法访问、解析延迟高），同时通过优化手段（如预解析、CDN）提升网页加载速度。

### vue2 和 vue3 的区别

`Vue2`使用的是`optionsAPI `，`Vue3`使用`composition API`，更好的组织代码，提高代码可维护性。

`Vue3`使用`Proxy`代理实现了新的响应式系统，比`Vue2`有着更好的性能和更准确的数据变化追踪能力。

`Vue3`引入了Teleprot组件，可以将DOM元素渲染到DOM数的其他位置，用于创建模态框、弹出框等。

`Vue3`全局API名称发生了变化，同时新增了`watchEffect`、`Hooks`等功能

`Vue3`对`TypeScript`的支持更加友好

`Vue3`核心库的依赖更少，减少打包体积

`Vue3`支持更好的`Tree Shanking`，可以更加精确的按需要引入模块

> Vue3（Vue.js 3.x）是 Vue2（Vue.js 2.x）的重大升级版本，在**性能、架构、语法、类型支持**等方面均有突破性改进，同时保持了对 Vue2 的大部分兼容性。以下是两者的核心区别：
>
> 一、核心架构与性能优化
>
> 1. 响应式系统重构
>
> - **Vue2**：基于`Object.defineProperty`实现响应式，存在以下局限：
>   - 无法监听对象新增属性 / 删除属性（需`Vue.set`/`Vue.delete`）；
>   - 无法监听数组索引和长度变化（需重写数组方法）；
>   - 响应式初始化时需递归遍历对象，性能开销大。
> - **Vue3**：基于`Proxy`+`Reflect`实现响应式，优势明显：
>   - 原生支持监听对象新增 / 删除属性、数组索引 / 长度变化；
>   - 非侵入式监听（无需修改原对象），初始化性能更高；
>   - 支持监听`Map`/`Set`等复杂数据结构。
>
> 2. 虚拟 DOM 与编译优化
>
> - **Vue2**：虚拟 DOM 全量对比，编译阶段无优化，复杂组件更新性能较差。
>
> - **Vue3**：
>
>   - **PatchFlag（补丁标记）**：编译时标记动态节点（如动态文本、动态 class），更新时只对比标记节点，减少无用对比；
>
>   - **静态提升**：将静态节点（如固定文本、静态标签）提升到渲染函数外，避免每次渲染重新创建；
>
>   - **缓存事件处理函数**：避免每次渲染生成新的函数引用，减少不必要的更新。
>
>     实测：Vue3 的渲染性能比 Vue2 提升约 55%，内存占用减少约 54%。
>
> 二、语法与 API 设计
>
> 1. 组合式 API（Composition API）vs 选项式 API（Options API）
>
> - **Vue2**：主要使用 Options API，按`data`/`methods`/`computed`/`watch`等选项组织代码，复杂组件易出现 “选项碎片化”（相关逻辑分散在不同选项中）。
>
> - **Vue3**：新增 Composition API（基于`setup`函数），可按功能逻辑组织代码，优势：
>
>   - 逻辑复用更灵活（替代 Vue2 的 mixins，避免命名冲突）；
>   - 复杂组件代码更易维护（相关逻辑聚合）；
>   - 更好的 TypeScript 支持。
>
>   示例（Vue3 组合式 API）：
>
>   ```vue
>   <script setup>
>   import { ref, computed } from 'vue';
>   const count = ref(0);
>   const doubleCount = computed(() => count.value * 2);
>   const increment = () => count.value++;
>   </script>
>   ```
>
> 2. 生命周期钩子变化
>
> - **Vue2**：选项式生命周期（如`created`/`mounted`/`updated`）。
> - **Vue3**：
>   - 组合式 API 中使用`onMounted`/`onUpdated`等钩子函数（需从`vue`导入）；
>   - 新增`onRenderTracked`/`onRenderTriggered`用于调试响应式依赖；
>   - 移除`beforeDestroy`/`destroyed`，替换为`onBeforeUnmount`/`onUnmounted`。
>
> 3. 模板语法增强
>
> - Vue3新增特性：
>   - **多根节点组件**：Vue2 组件模板必须有唯一根节点，Vue3 支持多根节点（片段）；
>   - **Teleport（传送门）**：可将组件内容渲染到 DOM 树的任意位置（如模态框渲染到`body`下）；
>   - **Suspense**：支持异步组件的加载状态（如`fallback`展示加载中）；
>   - **v-model 增强**：支持自定义 v-model 参数（如`v-model:title`），替代 Vue2 的`.sync`修饰符。
>
> 三、TypeScript 支持
>
> - **Vue2**：对 TypeScript 支持有限，需通过`Vue.extend`或类组件（`vue-class-component`）实现，类型推断不友好。
> - Vue3：源码用 TypeScript 重写，原生支持 TypeScript：
>   - `defineProps`/`defineEmits`提供完整的类型推导；
>   - 组合式 API 与 TypeScript 结合更自然；
>   - 类型定义更完善，开发时智能提示更精准。
>
> 四、全局 API 与实例
>
> - **Vue2**：全局 API 挂载在`Vue`对象上（如`Vue.component`/`Vue.directive`），易导致全局污染，测试困难。
>
> - **Vue3**：重构全局 API 为模块化导出，通过`createApp`创建应用实例，实现隔离：
>
>   ```javascript
>   // Vue2
>   import Vue from 'vue';
>   Vue.component('my-component', { /* ... */ });
>   new Vue({ el: '#app' });
>       
>   // Vue3
>   import { createApp } from 'vue';
>   const app = createApp({});
>   app.component('my-component', { /* ... */ });
>   app.mount('#app');
>   ```
>
>   优势：多个应用实例可独立配置，互不干扰。
>
> 五、体积与生态
>
> - **Vue3**：通过**Tree-Shaking**优化，未使用的 API（如`transition`、`keep-alive`）会被打包工具剔除，生产环境体积比 Vue2 小约 30%。
> - **生态兼容**：
>   - Vue3 支持大多数 Vue2 的生态库（如 Vue Router 4.x、Vuex 4.x/Pinia）；
>   - 部分老旧库（如依赖 Vue2 内部 API 的插件）需适配 Vue3。
>
> 六、其他细节差异
>
> | 特性                  | Vue2                         | Vue3                                                  |
> | --------------------- | ---------------------------- | ----------------------------------------------------- |
> | 过滤器（Filters）     | 支持                         | 移除（推荐用计算属性 / 方法替代）                     |
> | 自定义指令钩子        | `bind`/`inserted`/`update`等 | 调整为与组件生命周期对齐（如`mounted`替代`inserted`） |
> | 事件总线（Event Bus） | 依赖`new Vue()`实现          | 推荐用`mitt`等第三方库替代                            |
> | 数组响应式            | 重写 7 个数组方法            | 原生 Proxy 监听，无需重写                             |
>
> 七、总结
>
> Vue3 在**性能、响应式系统、语法灵活性、类型支持**上全面优于 Vue2，适合新项目开发；Vue2 仍有大量存量项目，且维护团队会提供长期支持（LTS）。选择时：
>
> - 新项目优先选 Vue3（尤其是需要 TypeScript 或复杂逻辑复用的场景）；
> - 存量项目若无强需求，可继续使用 Vue2，或逐步迁移至 Vue3。

### vue3如何实现一个自定义指令

有全局和局部两种注册方式。全局注册在`main.js`用`app.directive`，如`app.directive('focus', { mounted(el) { el.focus(); } })`；局部注册在组件内用`directives`选项，比如`<script setup> const vFocus = { mounted(el) { el.focus() } } </script>`，还可利用钩子函数实现不同阶段功能 。 

> 在 Vue3 中，自定义指令的实现主要分为**全局注册**和**局部注册**两种方式，核心是通过指令的钩子函数来操作 DOM。以下是详细的实现步骤和示例：
>
> 一、自定义指令的钩子函数
>
> Vue3 为自定义指令提供了以下钩子函数（可选）：
>
> - `created`：元素创建后（属性 / 事件监听器应用前）调用。
> - `beforeMount`：指令绑定到元素后、挂载前调用。
> - `mounted`：元素挂载到 DOM 后调用（最常用）。
> - `beforeUpdate`：组件更新前调用。
> - `updated`：组件更新后调用。
> - `beforeUnmount`：元素卸载前调用。
> - `unmounted`：元素卸载后调用。
>
> 每个钩子函数接收以下参数：
>
> - `el`：指令绑定的 DOM 元素（可直接操作）。
> - `binding`：包含指令信息的对象（`value`/`oldValue`/`arg`/`modifiers` 等）。
> - `vnode`：Vue 虚拟节点。
> - `prevVnode`：上一个虚拟节点（仅在 `beforeUpdate`/`updated` 中可用）。
>
> 二、全局注册自定义指令
>
> 通过 `app.directive()` 全局注册，所有组件均可使用。
>
> 示例：实现一个 “自动聚焦” 指令 `v-focus`
>
> ```javascript
> // main.js
> import { createApp } from 'vue'
> import App from './App.vue'
> 
> const app = createApp(App)
> 
> // 全局注册自定义指令 v-focus
> app.directive('focus', {
>   // 挂载后自动聚焦
>   mounted(el) {
>     el.focus()
>   }
> })
> 
> app.mount('#app')
> ```
>
> 使用：
>
> ```vue
> <!-- 组件中直接使用 -->
> <template>
>   <input v-focus placeholder="自动聚焦" />
> </template>
> ```
>
> 三、局部注册自定义指令
>
> 在组件内通过 `directives` 选项注册，仅当前组件可用。
>
> 示例：实现一个 “拖拽” 指令 `v-draggable`
>
> ```vue
> <template>
>   <div v-draggable class="box">可拖拽的盒子</div>
> </template>
> 
> <script setup>
> // 局部注册自定义指令 v-draggable
> const directives = {
>   draggable: {
>     mounted(el) {
>       el.style.position = 'absolute'
>       el.onmousedown = (e) => {
>         // 计算鼠标与元素左上角的偏移量
>         const disX = e.clientX - el.offsetLeft
>         const disY = e.clientY - el.offsetTop
> 
>         // 鼠标移动时更新元素位置
>         document.onmousemove = (e) => {
>           el.style.left = e.clientX - disX + 'px'
>           el.style.top = e.clientY - disY + 'px'
>         }
> 
>         // 鼠标松开时停止拖拽
>         document.onmouseup = () => {
>           document.onmousemove = null
>           document.onmouseup = null
>         }
>       }
>     }
>   }
> }
> </script>
> 
> <style scoped>
> .box {
>   width: 100px;
>   height: 100px;
>   background: skyblue;
>   cursor: move;
> }
> </style>
> ```
>
> 四、带参数 / 修饰符的自定义指令
>
> 通过 `binding.arg` 获取指令参数，`binding.modifiers` 获取修饰符。
>
> 示例：实现一个 “颜色设置” 指令 `v-color`
>
> ```vue
> <template>
>   <!-- 使用参数和修饰符 -->
>   <div v-color:[color].warning>带参数的指令</div>
>   <button @click="color = 'red'">切换颜色</button>
> </template>
> 
> <script setup>
> import { ref } from 'vue'
> 
> const color = ref('blue')
> 
> // 局部注册 v-color
> const directives = {
>   color: {
>     mounted(el, binding) {
>       // binding.arg 是参数（如 blue/red）
>       el.style.color = binding.arg
>       // binding.modifiers 是修饰符（如 warning）
>       if (binding.modifiers.warning) {
>         el.style.fontWeight = 'bold'
>         el.style.border = '1px solid red'
>       }
>     },
>     // 更新时触发
>     updated(el, binding) {
>       el.style.color = binding.arg
>     }
>   }
> }
> </script>
> ```
>
> 五、函数式简写
>
> 如果只需要 `mounted` 和 `updated` 钩子，可以直接传入一个函数：
>
> ```javascript
> // 全局注册 v-color 简写
> app.directive('color', (el, binding) => {
>   el.style.color = binding.value
> })
> 
> // 组件内使用
> <input v-color="'red'" />
> ```
>
> 六、注意事项
>
> 1. 操作 DOM 应在 `mounted`/`updated` 中进行，避免操作未挂载的元素。
> 2. 全局指令需在 `app.mount()` 前注册。
> 3. 指令名称建议使用**kebab-case**（短横线命名），如 `v-drag-item`，避免驼峰命名（Vue3 对指令名称大小写不敏感，但模板中推荐短横线）。

### vite常见配置

> Vite 的配置通过项目根目录下的 `vite.config.js`（或 `.ts`）文件实现，支持开发服务器、构建优化、插件配置等核心功能。以下是 Vite 的常见配置项及使用场景：
>
> 一、基础配置
>
> 1. 项目根目录与基础路径
>
> ```javascript
> import { defineConfig } from 'vite'
> 
> export default defineConfig({
>   // 项目根目录（默认：process.cwd()）
>   root: './src',
>   // 部署基础路径（如：GitHub Pages 需设为 '/repo-name/'）
>   base: '/my-app/',
> })
> ```
>
> 2. 开发服务器配置
>
> ```javascript
> export default defineConfig({
>   server: {
>     // 开发服务器端口（默认：5173）
>     port: 3000,
>     // 自动打开浏览器
>     open: true,
>     // 允许外部访问（局域网可访问）
>     host: '0.0.0.0',
>     // 跨域代理（解决接口请求跨域）
>     proxy: {
>       '/api': {
>         target: 'http://localhost:8080', // 后端接口地址
>         changeOrigin: true, // 开启跨域
>         rewrite: (path) => path.replace(/^\/api/, '') // 重写路径
>       }
>     },
>     // 热更新（默认开启）
>     hmr: true,
>     // 禁用 HTTPS（默认：false，如需开启可配置证书）
>     https: false
>   }
> })
> ```
>
> 二、构建配置
>
> 1. 输出目录与产物优化
>
> ```javascript
> export default defineConfig({
>   build: {
>     // 输出目录（默认：dist）
>     outDir: 'build',
>     // 静态资源目录（默认：assets）
>     assetsDir: 'static',
>     // 产物哈希（用于缓存）
>     assetsInlineLimit: 4096, // 小于4kb的资源内联为base64
>     // 压缩配置
>     minify: 'esbuild', // 默认：esbuild（更快），可选 'terser'（更彻底）
>     // 拆分代码（默认：true）
>     rollupOptions: {
>       output: {
>         // 手动拆分 chunk（如：将第三方库单独打包）
>         manualChunks: {
>           vendor: ['vue', 'axios'],
>           utils: ['lodash']
>         }
>       }
>     },
>     // 禁用 sourcemap
>     sourcemap: false
>   }
> })
> ```
>
> 2. 环境变量配置
>
> ```javascript
> export default defineConfig(({ mode }) => {
>   // 根据环境（development/production）加载不同配置
>   return {
>     // 环境变量文件目录（默认：根目录）
>     envDir: './env',
>     // 环境变量前缀（默认：VITE_）
>     envPrefix: 'APP_',
>   }
> })
> ```
>
> - 环境文件需命名为 `.env.development`/`.env.production`，变量需以 `envPrefix` 开头（如 `APP_API_URL`）。
>
> 三、插件与依赖配置
>
> 1. 插件配置（如 Vue、React 支持）
>
> ```javascript
> import vue from '@vitejs/plugin-vue'
> import react from '@vitejs/plugin-react'
> 
> export default defineConfig({
>   plugins: [
>     vue(), // 支持 Vue 单文件组件
>     react() // 支持 React
>   ]
> })
> ```
>
> 2. 依赖预构建
>
> ```javascript
> export default defineConfig({
>   optimizeDeps: {
>     // 强制预构建指定依赖
>     include: ['axios', 'lodash-es'],
>     // 排除预构建依赖
>     exclude: ['some-large-lib']
>   }
> })
> ```
>
> 四、别名与路径配置
>
> ```javascript
> import { defineConfig } from 'vite'
> import path from 'path'
> 
> export default defineConfig({
>   resolve: {
>     // 路径别名（简化导入）
>     alias: {
>       '@': path.resolve(__dirname, './src'),
>       '@components': path.resolve(__dirname, './src/components'),
>       // 支持 npm 包别名
>       'vue': 'vue/dist/vue.esm-bundler.js'
>     },
>     // 导入时省略的扩展名
>     extensions: ['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json']
>   }
> })
> ```
>
> - 使用别名后，可通过 `import xxx from '@/xxx'` 替代相对路径。
>
> 五、CSS 配置
>
> ```javascript
> export default defineConfig({
>   css: {
>     // CSS 模块化配置
>     modules: {
>       scopeBehaviour: 'local', // 默认：local
>       generateScopedName: '[name]__[local]___[hash:base64:5]' // 自定义类名格式
>     },
>     // CSS 预处理器配置
>     preprocessorOptions: {
>       scss: {
>         // 全局注入变量/混合
>         additionalData: '@import "@/styles/variables.scss";'
>       },
>       less: {
>         javascriptEnabled: true // 支持 Less 内联 JavaScript
>       }
>     },
>     // 开启 CSS 源码映射
>     devSourcemap: true
>   }
> })
> ```
>
> 六、其他常用配置
>
> 1. 模式与条件配置
>
> ```javascript
> export default defineConfig(({ mode, command }) => {
>   // mode：环境（development/production）
>   // command：命令（serve/build）
>   return {
>     // 开发环境配置
>     ...(mode === 'development' ? { server: { port: 3000 } } : {}),
>     // 生产环境配置
>     ...(command === 'build' ? { build: { minify: 'terser' } } : {})
>   }
> })
> ```
>
> 2. 日志与调试
>
> ```javascript
> export default defineConfig({
>   // 日志级别（info/warn/error/silent）
>   logLevel: 'warn',
>   // 禁用 Vite 内置的优化提示
>   clearScreen: false
> })
> ```
>
> 七、完整示例配置
>
> ```javascript
> import { defineConfig } from 'vite'
> import vue from '@vitejs/plugin-vue'
> import path from 'path'
> 
> export default defineConfig(({ mode }) => {
>   return {
>     base: mode === 'production' ? '/my-app/' : '/',
>     plugins: [vue()],
>     resolve: {
>       alias: {
>         '@': path.resolve(__dirname, 'src')
>       }
>     },
>     server: {
>       port: 3000,
>       proxy: {
>         '/api': {
>           target: 'http://localhost:8080',
>           changeOrigin: true,
>           rewrite: (path) => path.replace(/^\/api/, '')
>         }
>       }
>     },
>     build: {
>       outDir: 'dist',
>       rollupOptions: {
>         output: {
>           manualChunks: {
>             vendor: ['vue', 'axios']
>           }
>         }
>       }
>     },
>     css: {
>       preprocessorOptions: {
>         scss: {
>           additionalData: '@import "@/styles/variables.scss";'
>         }
>       }
>     }
>   }
> })
> ```
>
> 八、常用插件推荐
>
> - **`@vitejs/plugin-vue`**：Vue 3 单文件组件支持。
> - **`@vitejs/plugin-vue-jsx`**：Vue JSX 语法支持。
> - **`vite-plugin-pwa`**：PWA 离线功能支持。
> - **`vite-plugin-eslint`**：ESLint 集成。
> - **`rollup-plugin-visualizer`**：构建产物分析。
>
> 通过以上配置，可满足绝大多数项目的开发、构建需求，Vite 还支持自定义插件和更细粒度的优化，具体可参考[官方文档](https://vitejs.dev/config/)。

### Vite 和 Webpack 核心优缺点对比

- Vite：
  - 优点：**开发环境启动极快**（基于原生 ES 模块，无需打包），热更新响应迅速，配置简洁直观，对 TypeScript、Vue3 等现代框架支持友好。
  - 缺点：生态相对 Webpack 较新，部分老旧插件兼容性不足，生产环境仍需依赖 Rollup 打包（功能成熟但定制化灵活度稍弱）。
- Webpack：
  - 优点：**生态庞大且成熟**，插件 /loader 丰富（几乎支持所有场景），配置灵活可深度定制，生产环境优化（代码分割、tree-shaking 等）稳定可靠。
  - 缺点：开发环境启动和热更新较慢（需全量打包），配置复杂，学习成本较高。

> Vite 和 Webpack 是目前前端工程化中最主流的构建工具，二者的设计理念、底层实现和适用场景差异显著。以下从**核心原理**、**优缺点对比**、**适用场景**三方面详细分析：
>
> 一、核心原理差异
>
> - **Vite**：基于**原生 ES 模块（ESM）** 实现，开发环境下不打包，直接通过浏览器解析 ESM，生产环境使用 Rollup 打包（更轻量高效）。
> - **Webpack**：基于**打包器**设计，无论开发 / 生产环境均需先打包所有模块，再输出 bundle 文件。
>
> 二、优缺点对比
>
> 1. Vite 的优点
>
> - **开发启动速度极快**：无需打包，冷启动通常秒级（大型项目优势更明显）。
> - **热更新（HMR）效率高**：仅重新编译修改的模块，而非全量打包，更新反馈毫秒级。
> - **内置优化更友好**：原生支持 ESM、TypeScript、JSX，无需额外配置；内置 Rollup 生产打包，体积更小。
> - **配置简洁**：默认配置满足大多数场景，学习成本低，支持插件扩展。
> - **依赖预构建**：开发时预构建第三方依赖（如 node_modules）为 ESM，避免浏览器请求瀑布流。
>
> 2. Vite 的缺点
>
> - **生态兼容性略逊**：部分 Webpack 插件无法直接使用，需适配 Vite 生态（如 `vite-plugin-*`）。
> - **生产打包灵活性稍弱**：虽然基于 Rollup，但复杂场景（如多入口、动态分包）配置不如 Webpack 成熟。
> - **对旧浏览器支持有限**：开发环境依赖原生 ESM，需额外配置兼容方案（如 `@vitejs/plugin-legacy`）。
> - **大型项目自定义配置深度不足**：极端复杂的构建需求（如多阶段打包、自定义 chunk 策略）不如 Webpack 灵活。
>
> 3. Webpack 的优点
>
> - **生态成熟丰富**：海量插件（如 `html-webpack-plugin`、`webpack-chain`）和 loader，覆盖所有场景。
> - **高度可定制化**：支持复杂的构建逻辑（如多入口、代码分割、资源处理），适合大型 / 复杂项目。
> - **兼容性强**：支持旧浏览器（如 IE），可通过 `babel`、`polyfill` 适配各种环境。
> - **功能全面**：内置代码分割、Tree-shaking、缓存等，无需额外插件即可实现复杂需求。
>
> 4. Webpack 的缺点
>
> - **开发启动 / 热更新慢**：大型项目打包时间长（分钟级），HMR 反馈延迟明显。
> - **配置复杂**：学习曲线陡峭，需手动配置 loader、插件、优化项等。
> - **性能开销大**：全量打包机制导致内存占用高，对机器性能要求较高。
> - **默认配置冗余**：初始化项目需配置大量基础项（如 `entry`、`output`、`module.rules`）。
>
> 三、关键维度对比表
>
> | **维度**     | **Vite**                           | **Webpack**                     |
> | ------------ | ---------------------------------- | ------------------------------- |
> | 启动速度     | 极快（秒级）                       | 较慢（大型项目分钟级）          |
> | 热更新效率   | 毫秒级（仅更新修改模块）           | 较慢（全量 / 部分打包）         |
> | 配置复杂度   | 低（默认配置够用）                 | 高（需手动配置大量细节）        |
> | 生态丰富度   | 中等（快速增长中）                 | 极高（成熟插件体系）            |
> | 生产打包     | 基于 Rollup，体积更小              | 基于自身打包，灵活性更强        |
> | 兼容性       | 现代浏览器优先，需插件兼容旧环境   | 原生支持多环境，兼容性更好      |
> | 适用项目规模 | 中小型项目、Vue/React 现代框架项目 | 大型 / 复杂项目、全栈工程化项目 |
>
> 四、适用场景
>
> - 选 Vite：现代框架项目（Vue3/React18+）、中小型应用、追求开发体验的团队、需要快速迭代的项目。
> - 选 Webpack：大型 / 复杂项目（如企业级应用、多入口 / 多页面）、需兼容旧浏览器、深度定制构建流程、依赖 Webpack 专属插件的项目。
>
> 总结
>
> Vite 以**开发体验**为核心优势，适合现代前端项目；Webpack 以**通用性和灵活性**见长，适合复杂工程化场景。二者并非替代关系，而是根据项目需求选择 —— 多数新项目可优先选 Vite，复杂场景仍需 Webpack 兜底。

### 垂直居中

> CSS 实现垂直居中的方法有很多，需根据元素类型（行内元素 / 块级元素）、是否固定宽高、兼容性要求等选择方案。以下是常用的垂直居中技巧及适用场景：
>
> 一、行内 / 行内块元素垂直居中
>
> 1. 单行文本：`line-height` 等于父元素高度
>
> ```css
> .parent {
>   height: 100px;
>   line-height: 100px; /* 与height相等 */
>   border: 1px solid #000;
> }
> ```
>
> **适用**：单行文本、行内元素（如 `<span>`/`<img>`）。
>
> 2. 多行文本 / 行内块：`vertical-align: middle` + 伪元素
>
> ```css
> .parent {
>   height: 200px;
>   border: 1px solid #000;
>   text-align: center; /* 水平居中配合 */
> }
> .parent::before {
>   content: '';
>   display: inline-block;
>   height: 100%;
>   vertical-align: middle;
> }
> .child {
>   display: inline-block;
>   vertical-align: middle;
> }
> ```
>
> **适用**：多行文本、图片、按钮等行内块元素。
>
> 二、块级元素垂直居中
>
> 1. Flex 布局（推荐，现代浏览器首选）
>
> ```css
> .parent {
>   display: flex;
>   align-items: center; /* 垂直居中 */
>   justify-content: center; /* 水平居中（可选） */
>   height: 200px;
>   border: 1px solid #000;
> }
> ```
>
> **优势**：无需固定宽高，支持多元素居中，兼容性好（IE11+）。
>
> 2. Grid 布局（更简洁，适合单元素居中）
>
> ```css
> .parent {
>   display: grid;
>   place-items: center; /* 同时垂直+水平居中 */
>   height: 200px;
>   border: 1px solid #000;
> }
> ```
>
> **适用**：现代浏览器，代码极简。
>
> 3. 绝对定位 + `transform`（不固定宽高）
>
> ```css
> .parent {
>   position: relative;
>   height: 200px;
>   border: 1px solid #000;
> }
> .child {
>   position: absolute;
>   top: 50%;
>   left: 50%;
>   transform: translate(-50%, -50%); /* 自身宽高的-50% */
> }
> ```
>
> **适用**：元素宽高不固定，兼容性好（IE9+）。
>
> 4. 绝对定位 + `margin: auto`（需固定宽高）
>
> ```css
> .parent {
>   position: relative;
>   height: 200px;
>   border: 1px solid #000;
> }
> .child {
>   position: absolute;
>   top: 0;
>   bottom: 0;
>   left: 0;
>   right: 0;
>   width: 100px;
>   height: 50px;
>   margin: auto; /* 自动分配空间 */
> }
> ```
>
> **适用**：元素宽高固定，兼容性好（IE8+）。
>
> 5. `table-cell` 布局（模拟表格）
>
> ```css
> .parent {
>   display: table-cell;
>   vertical-align: middle;
>   height: 200px;
>   border: 1px solid #000;
> }
> ```
>
> **适用**：需兼容旧浏览器（IE8+），结构类似表格。
>
> 三、特殊场景：弹性盒多元素居中
>
> ```css
> .parent {
>   display: flex;
>   flex-direction: column; /* 垂直排列 */
>   justify-content: center; /* 垂直居中 */
>   align-items: center; /* 水平居中 */
>   height: 300px;
>   border: 1px solid #000;
> }
> ```
>
> **适用**：子元素垂直排列时的居中。
>
> 四、总结：方案选择建议
>
> | 场景                 | 推荐方案                               |
> | -------------------- | -------------------------------------- |
> | 现代浏览器、简单布局 | Flex/Grid 布局                         |
> | 兼容旧浏览器（IE8+） | `table-cell` 或绝对定位 +`margin:auto` |
> | 元素宽高不固定       | Flex 或绝对定位 +`transform`           |
> | 单行文本             | `line-height` 等于父元素高度           |
>
> Flex 布局是最通用的方案，代码简洁且适配性强，优先推荐使用；如需兼容低版本浏览器，可选择 `table-cell` 或绝对定位方案。

### pc和h5适配怎么做

> PC 和 H5 适配的核心目标是让网页在不同设备（桌面端、移动端）上都能正常显示且交互友好，主要通过**响应式设计**、**移动端适配方案**和**跨端兼容处理**实现。以下是具体的实现方法和关键细节：
>
> 一、视口设置（H5 基础）
>
> 移动端首先需要配置视口，让页面宽度适配设备屏幕：
>
> ```html
> <!-- 核心视口标签：宽度=device-width（适配设备宽度），初始缩放1，禁止用户缩放 -->
> <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
> ```
>
> - `width=device-width`：视口宽度等于设备宽度（如手机 375px、414px）。
> - `initial-scale=1.0`：初始缩放比例为 1，避免页面默认缩放。
> - `user-scalable=no`：禁止用户手动缩放（可选，根据需求调整）。
>
> 二、响应式布局（PC+H5 通用）
>
> 通过**媒体查询**、**弹性布局（Flex）**、**网格布局（Grid）** 等技术，让页面布局随屏幕宽度自适应。
>
> 1. 媒体查询（Media Query）
>
> 根据不同屏幕宽度设置不同样式，是响应式的基础：
>
> ```css
> /* 基础样式（默认PC） */
> .container {
>   width: 1200px;
>   margin: 0 auto;
> }
> 
> /* 平板设备（768px~1024px） */
> @media (max-width: 1024px) {
>   .container {
>     width: 90%;
>   }
> }
> 
> /* 移动端（≤767px） */
> @media (max-width: 767px) {
>   .container {
>     width: 100%;
>     padding: 0 15px;
>   }
>   /* 移动端隐藏PC端元素 */
>   .pc-only {
>     display: none;
>   }
> }
> 
> /* PC端隐藏移动端元素 */
> @media (min-width: 768px) {
>   .h5-only {
>     display: none;
>   }
> }
> ```
>
> - 常用断点（Breakpoint）：
>   - 移动端：≤767px
>   - 平板：768px~1024px
>   - PC：≥1025px
>
> 2. 弹性布局（Flex）
>
> 通过`display: flex`实现自适应排列，适合导航、卡片列表等：
>
> ```css
> /* 导航栏：PC端横向排列，移动端纵向排列 */
> .nav {
>   display: flex;
> }
> 
> @media (max-width: 767px) {
>   .nav {
>     flex-direction: column; /* 移动端纵向排列 */
>   }
> }
> 
> /* 卡片列表：自动换行，适配不同宽度 */
> .card-list {
>   display: flex;
>   flex-wrap: wrap; /* 超出换行 */
>   gap: 20px; /* 间距 */
> }
> 
> .card {
>   flex: 1 1 250px; /* 最小宽度250px，自动拉伸 */
> }
> ```
>
> 3. 网格布局（Grid）
>
> 适合复杂的多列布局，比如商品列表、仪表盘：
>
> ```css
> /* PC端4列，移动端2列 */
> .grid-container {
>   display: grid;
>   grid-template-columns: repeat(4, 1fr); /* PC端4列 */
>   gap: 20px;
> }
> 
> @media (max-width: 767px) {
>   .grid-container {
>     grid-template-columns: repeat(2, 1fr); /* 移动端2列 */
>   }
> }
> ```
>
> 三、移动端适配方案
>
> 1. 单位选择
>
> - **rem**：基于根元素（`<html>`）的字体大小，适合移动端整体适配：
>
>   ```css
>   /* 根元素字体大小 = 设备宽度 / 10（如375px设备→37.5px） */
>   html {
>     font-size: calc(100vw / 10);
>   }
>   /* 元素尺寸用rem（如设计稿375px下的100px→100/37.5≈2.666rem） */
>   .box {
>     width: 2.666rem;
>     height: 1.333rem;
>   }
>   ```
>
>   - 配合`lib-flexible`库可自动设置根字体大小（已逐渐被 vw 替代）。
>
> - **vw/vh**：视口单位（1vw = 视口宽度的 1%），无需依赖根字体大小，更简洁：
>
>   ```css
>   /* 设计稿375px下的100px → 100/3.75 ≈26.666vw */
>   .box {
>     width: 26.666vw;
>     height: 13.333vw;
>   }
>   ```
>
> - **px**：固定单位，适合 PC 端固定尺寸元素（如按钮高度、边框），移动端结合媒体查询使用。
>
> 2. 交互适配
>
> - **触摸事件**：移动端支持`touchstart`/`touchmove`/`touchend`，替代 PC 端的`mouse`事件：
>
>   ```javascript
>   // 兼容PC和移动端的点击事件
>   const el = document.querySelector('.btn');
>   el.addEventListener('click', handleClick); // PC点击
>   el.addEventListener('touchstart', (e) => {
>     e.preventDefault(); // 阻止默认行为（如滚动）
>     handleClick();
>   });
>   ```
>
> - **点击穿透问题**：移动端`click`事件有 300ms 延迟，可通过`fastclick`库解决，或用`touchstart`替代。
>
> - **手势适配**：移动端支持双击、捏合缩放等手势，可通过`hammer.js`等库实现。
>
> 四、PC 端适配细节
>
> - **最小宽度限制**：避免 PC 端窗口过小时布局错乱，设置最小宽度：
>
>   ```css
>   body {
>     min-width: 1200px; /* PC端最小宽度 */
>   }
>   ```
>
> - **滚动条适配**：PC 端滚动条可能影响布局，可自定义样式：
>
>   ```css
>   ::-webkit-scrollbar {
>     width: 8px;
>     height: 8px;
>   }
>   ::-webkit-scrollbar-thumb {
>     background: #ccc;
>     border-radius: 4px;
>   }
>   ```
>
> - **鼠标悬浮效果**：PC 端添加`hover`样式，移动端隐藏：
>
>   ```css
>   .btn:hover {
>     background: #f0f0f0;
>   }
>   @media (max-width: 767px) {
>     .btn:hover {
>       background: inherit; /* 移动端取消hover效果 */
>     }
>   }
>   ```
>
> 五、工具与框架辅助
>
> - **CSS 框架**：使用 Bootstrap、Tailwind CSS 等，内置响应式类（如`col-md-6`、`md:flex`），快速实现适配。
>
>   ```html
>   <!-- Tailwind CSS示例：PC端4列，移动端2列 -->
>   <div class="grid grid-cols-4 md:grid-cols-2 gap-4">
>     <div class="card">1</div>
>     <div class="card">2</div>
>     <div class="card">3</div>
>     <div class="card">4</div>
>   </div>
>   ```
>
> - **JS 适配库**：使用`matchMedia`检测屏幕尺寸，动态调整逻辑：
>
>   ```javascript
>   const isMobile = window.matchMedia('(max-width: 767px)').matches;
>   if (isMobile) {
>     // 移动端逻辑
>     console.log('移动端');
>   } else {
>     // PC端逻辑
>     console.log('PC端');
>   }
>   ```
>
> 六、测试与调试
>
> - **Chrome 开发者工具**：切换设备模拟器（Ctrl+Shift+M），测试不同屏幕尺寸。
> - **真机测试**：在不同手机、平板上验证显示效果。
> - **兼容性测试**：PC 端兼容 IE11+（如需），移动端兼容主流浏览器（Chrome、Safari）。

### promise.all和promise.allsellted差别

`Promise.all`和`Promise.allSettled`都用于并行处理多个Promise，但关键区别在于对结果的处理方式。`Promise.all`需要所有Promise都成功，才会返回所有成功结果组成的数组；一旦有一个Promise失败，就会立即返回那个失败的结果，其他未完成的Promise会被忽略。而`Promise.allSettled`会等待所有Promise都执行完毕，无论成功还是失败，都会返回一个包含每个Promise结果的数组，每个结果对象会标明该Promise是成功（status为fulfilled）还是失败（status为rejected），并且保持与输入数组相同的顺序。

> `Promise.all` 和 `Promise.allSettled` 是 JavaScript 中处理多个 Promise 并行执行的常用方法，核心差异在于**对失败 Promise 的处理逻辑**和**返回结果的格式**，具体区别如下：
>
> 一、核心行为差异
>
> 1. `Promise.all`：“全成则成，一败则败”
>
> - **执行逻辑**：接收一个 Promise 数组，等待**所有 Promise 都成功**，或**任意一个 Promise 失败**时立即结束。
> - **失败处理**：如果有一个 Promise 被 `reject`，`Promise.all` 会**立即抛出该错误**，且忽略其他未完成的 Promise。
> - **返回结果**：成功时返回**所有 Promise 结果组成的数组**（顺序与输入 Promise 数组一致）；失败时返回第一个 `reject` 的错误。
>
> **示例**：
>
> ```javascript
> const p1 = Promise.resolve(1);
> const p2 = Promise.reject('error');
> const p3 = Promise.resolve(3);
> 
> Promise.all([p1, p2, p3])
>   .then(res => console.log(res)) // 不会执行
>   .catch(err => console.log(err)); // 输出：error
> ```
>
> 2. `Promise.allSettled`：“等待所有结果，无论成败”
>
> - **执行逻辑**：接收一个 Promise 数组，等待**所有 Promise 都完成**（无论成功或失败）后才结束。
> - **失败处理**：不会因某个 Promise 失败而中断，会等待所有 Promise 执行完毕。
> - **返回结果**：始终返回一个**包含每个 Promise 结果的对象数组**（顺序与输入一致），每个对象包含：
>   - 成功时：`{ status: 'fulfilled', value: 结果 }`
>   - 失败时：`{ status: 'rejected', reason: 错误 }`
>
> **示例**：
>
> ```javascript
> const p1 = Promise.resolve(1);
> const p2 = Promise.reject('error');
> const p3 = Promise.resolve(3);
> 
> Promise.allSettled([p1, p2, p3])
>   .then(res => console.log(res)); 
> // 输出：
> // [
> //   { status: 'fulfilled', value: 1 },
> //   { status: 'rejected', reason: 'error' },
> //   { status: 'fulfilled', value: 3 }
> // ]
> ```
>
> 二、适用场景对比
>
> | 方法                 | 适用场景                                                     |
> | -------------------- | ------------------------------------------------------------ |
> | `Promise.all`        | 需要**所有操作都成功**才能继续的场景（如：同时获取多个接口数据，缺一不可）。 |
> | `Promise.allSettled` | 需要**收集所有操作结果**（无论成败）的场景（如：批量操作后统计成功 / 失败数量）。 |
>
> 三、其他细节差异
>
> 1. **返回状态**：
>    - `Promise.all` 只有所有 Promise 成功时才会 `fulfilled`，否则 `rejected`。
>    - `Promise.allSettled` 始终是 `fulfilled`（除非传入的参数不是可迭代对象）。
> 2. **结果处理**：
>    - `Promise.all` 直接返回结果值数组，使用更简洁。
>    - `Promise.allSettled` 返回带状态的对象数组，需手动遍历判断成功 / 失败。
>
> 总结
>
> - 若需**全部成功**才继续，选 `Promise.all`；
> - 若需**所有结果**（无论成败），选 `Promise.allSettled`。

### promise和async/await怎么捕获错误

处理Promise相关的错误，主要有两种方式。第一种是直接使用Promise的`.catch()`方法，它能捕获到前面所有Promise链中抛出的错误，包括`reject`和同步异常。第二种是在`async/await`语法中，用`try...catch`语句包裹`await`操作，这样可以同步的方式处理异步错误，代码更直观。另外，这两种方式还能配合使用，比如在调用`async`函数时，用`.catch()`兜底，确保不会遗漏错误。

> 一、Promise 的错误捕获
>
> Promise 本身通过**链式调用的 `catch` 方法**或 **`then` 的第二个参数 ** 捕获错误，主要有两种方式：
>
> 1. `catch` 方法捕获（推荐）
>
> Promise 链中任何一个环节抛出错误（`reject`），都会被后续的 `catch` 捕获：
>
> ```javascript
> // 单个 Promise
> Promise.reject("出错了")
>   .then(res => console.log(res))
>   .catch(err => console.log("捕获错误：", err)); // 输出：捕获错误：出错了
> 
> // Promise 链
> Promise.resolve(1)
>   .then(res => { throw new Error("手动抛出错误"); })
>   .then(res => console.log(res))
>   .catch(err => console.log("捕获错误：", err.message)); // 输出：捕获错误：手动抛出错误
> ```
>
> 2. `then` 的第二个参数捕获
>
> `then` 方法的第二个参数专门处理当前 Promise 的失败情况（但无法捕获前面 Promise 链的错误，不如 `catch` 灵活）：
>
> ```javascript
> Promise.reject("出错了")
>   .then(
>     res => console.log(res), 
>     err => console.log("捕获错误：", err) // 输出：捕获错误：出错了
>   );
> ```
>
> 3. `Promise.all`/`Promise.race` 的错误捕获
>
> 通过链式 `catch` 捕获首个失败的 Promise 错误：
>
> ```javascript
> Promise.all([Promise.resolve(1), Promise.reject("失败了")])
>   .then(res => console.log(res))
>   .catch(err => console.log("捕获错误：", err)); // 输出：捕获错误：失败了
> ```
>
> 二、async/await 的错误捕获
>
> `async/await` 是 Promise 的语法糖，需通过 **`try/catch` 块 ** 捕获错误（也可结合 Promise 的 `catch`）：
>
> 1. 基本 `try/catch` 捕获
>
> 将可能出错的 `await` 操作包裹在 `try` 中，`catch` 捕获错误：
>
> ```javascript
> async function fetchData() {
>   try {
>     const res = await Promise.reject("请求失败");
>     console.log(res); // 不会执行
>   } catch (err) {
>     console.log("捕获错误：", err); // 输出：捕获错误：请求失败
>   }
> }
> fetchData();
> ```
>
> 2. 多个 `await` 的错误捕获
>
> - **统一捕获**：多个 `await` 放在同一个 `try` 中，任意一个出错都会触发 `catch`：
>
>   ```javascript
>   async function fetchData() {
>     try {
>       const res1 = await Promise.resolve(1);
>       const res2 = await Promise.reject("res2 失败"); // 此处出错
>       const res3 = await Promise.resolve(3); // 不会执行
>     } catch (err) {
>       console.log("捕获错误：", err); // 输出：捕获错误：res2 失败
>     }
>   }
>   ```
>
> - **单独捕获**：给每个 `await` 加 `catch`，避免一个错误阻断所有操作：
>
>   ```javascript
>   async function fetchData() {
>     const res1 = await Promise.resolve(1).catch(err => console.log("res1 错误：", err));
>     const res2 = await Promise.reject("res2 失败").catch(err => console.log("res2 错误：", err)); // 输出：res2 错误：res2 失败
>     const res3 = await Promise.resolve(3).catch(err => console.log("res3 错误：", err));
>     console.log(res1, res2, res3); // 输出：1 undefined 3
>   }
>   ```
>
> 3. 结合 `Promise.all` 的错误捕获
>
> ```javascript
> async function fetchAll() {
>   try {
>     const res = await Promise.all([
>       Promise.resolve(1), 
>       Promise.reject("all 失败")
>     ]);
>     console.log(res);
>   } catch (err) {
>     console.log("捕获错误：", err); // 输出：捕获错误：all 失败
>   }
> }
> ```
>
> 三、特殊场景：`async` 函数的未捕获错误
>
> 若 `async` 函数未用 `try/catch` 或 `catch` 捕获错误，会返回一个 `rejected` 状态的 Promise，需手动捕获：
>
> ```javascript
> async function test() {
>   await Promise.reject("未捕获错误");
> }
> 
> // 方式1：调用时加 catch
> test().catch(err => console.log("最终捕获：", err)); // 输出：最终捕获：未捕获错误
> 
> // 方式2：在函数内部捕获（推荐）
> async function test() {
>   try {
>     await Promise.reject("未捕获错误");
>   } catch (err) {
>     console.log("内部捕获：", err);
>   }
> }
> ```
>
> 四、总结
>
> | 方式        | 错误捕获手段                       | 适用场景                      |
> | ----------- | ---------------------------------- | ----------------------------- |
> | Promise     | `catch` 方法 / `then` 第二个参数   | 链式调用、单独 Promise 处理   |
> | async/await | `try/catch` 块 / 结合 `catch` 方法 | 同步风格代码、多个 await 操作 |
>
> **最佳实践**：
>
> - Promise 优先用 `catch` 链式捕获；
> - async/await 优先用 `try/catch` 包裹核心逻辑，必要时给单个 await 加 `catch` 兜底。

### 做个购物车确认下单按钮该考虑些什么

用户点击下单后，首先前端会校验商品状态，看是否过期、限购，接着检查用户是否登录，以及收货地址是否完善。这时候会把确认按钮禁用，避免重复点击。之后调用后端的校验接口，确认库存、价格、会员权益等是否符合要求。校验通过后，再调用创建订单接口，生成唯一订单。如果成功，就带着订单号跳转到支付页面；失败的话，会明确提示失败原因，方便用户修改。

> 购物车的 “确认下单” 按钮是电商流程的核心节点，需兼顾**功能完整性**、**用户体验**、**安全性**和**异常处理**，具体考量如下：
>
> 一、功能逻辑层面
>
> 1. 前置校验
>
> - 商品状态校验：
>   - 检查购物车商品是否仍在售（避免已下架 / 删除商品）；
>   - 校验商品库存（库存不足时禁用按钮并提示）；
>   - 确认商品规格 / 属性是否有效（如尺码、颜色是否可选）。
> - 用户状态校验：
>   - 未登录用户需引导登录 / 注册；
>   - 校验用户收货地址是否存在（无地址时跳转地址管理页）；
>   - 验证用户支付方式是否绑定（如未绑卡提示绑定）。
> - 订单信息完整性：
>   - 确认商品数量是否超出限购（如秒杀商品每人限 1 件）；
>   - 检查优惠券 / 满减活动是否仍有效（过期则自动失效并更新价格）。
>
> 2. 按钮状态控制
>
> - **正常状态**：可点击，显示 “确认下单”/“去结算” 等文案。
> - **加载状态**：点击后立即置灰并显示加载动画（如转圈图标 +“处理中...”），防止重复点击。
> - **禁用状态**：前置校验不通过时禁用（如库存不足、无地址），并给出明确提示（如 “商品库存不足”）。
>
> 二、用户体验层面
>
> 1. 交互反馈
>
> - 点击反馈：
>   - 按钮添加点击动效（如按压样式），提升交互感；
>   - 加载状态清晰告知用户 “正在处理”，避免用户误以为未触发操作。
> - 异常提示：
>   - 校验失败时通过 Toast / 弹窗清晰说明原因（如 “您选择的商品已售罄”）；
>   - 跳转延迟时显示过渡动画，减少用户焦虑。
> - 文案设计：
>   - 按钮文案简洁明确（如 “确认下单” 优于 “下一步”）；
>   - 移动端适配按钮尺寸（建议≥44px×44px，符合触控规范）。
>
> 2. 流程衔接
>
> - 点击后平滑跳转到订单确认页（或支付页），避免页面卡顿；
> - 若网络异常导致跳转失败，提供 “重试” 按钮，而非直接报错。
>
> 三、技术实现层面
>
> 1. 防重复提交
>
> - **前端**：点击后立即禁用按钮或添加 loading 状态，直至请求完成 / 失败；
> - **后端**：通过**幂等性设计**（如订单号 + 用户 ID 唯一标识）防止重复创建订单。
>
> 2. 性能优化
>
> - 提前预加载订单确认页所需数据（如用户地址、支付方式），减少跳转后的加载时间；
> - 按钮点击事件绑定采用防抖 / 节流（如限制 1 秒内仅触发 1 次）。
>
> 3. 异常处理
>
> - **网络异常**：请求超时 / 失败时，提示用户 “网络异常，请重试” 并允许重新操作；
> - **后端错误**：捕获接口返回的业务错误（如 “库存锁定失败”），转化为用户可理解的提示；
> - **页面跳转异常**：若跳转失败，保留购物车状态，避免用户需重新选择商品。
>
> 4. 兼容性
>
> - 按钮样式兼容不同设备 / 浏览器（如移动端适配、IE 浏览器兼容）；
> - 触控 / 点击事件兼容 PC 端（鼠标）和移动端（触屏）。
>
> 四、业务安全层面
>
> 1. 数据校验
>
> - 前端校验仅作体验优化，**后端必须二次校验**（防止前端参数篡改，如修改商品价格 / 数量）；
> - 敏感操作（如创建订单）需验证用户身份（如 token 有效性）。
>
> 2. 防攻击
>
> - 防止 CSRF 攻击（通过 token 验证请求合法性）；
> - 限制按钮点击频率（防止恶意刷接口）。
>
> 五、特殊场景处理
>
> 1. 多商品购物车
>
> - 部分商品失效时，弹窗提示 “以下商品已失效，请确认是否删除”，并提供 “继续结算有效商品” 选项；
> - 跨店铺商品需拆分订单时，提前告知用户 “将拆分为 N 个订单结算”。
>
> 2. 促销活动
>
> - 按钮旁可展示优惠信息（如 “立减 20 元”），强化下单动机；
> - 活动倒计时商品需提示 “距离活动结束还有 X 分钟”，营造紧迫感。
>
> 六、可访问性设计
>
> - 按钮添加键盘焦点样式（便于键盘操作）；
> - 按钮文案与背景色对比度符合 WCAG 标准（如深色文案 + 浅色背景）；
> - 支持屏幕阅读器（添加 aria-label 属性，如 “确认下单按钮”）。
>
> 总结
>
> 确认下单按钮的设计需围绕 **“安全、流畅、清晰”** 展开：前置校验确保订单有效性，状态控制避免操作失误，异常处理提升容错性，用户体验设计降低操作门槛。同时，前后端协同保障数据安全，最终实现从购物车到支付的无缝衔接。
