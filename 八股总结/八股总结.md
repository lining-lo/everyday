## 八股总结

### js数据类型

`JavaScript`有着八种数据类型`String`、`Number`、`Boolean`、`Null`、`Undefined`、`Symbol`、`BigInt`、`Object`，前七种为基本数据类型，`Object`为引用类型。

其中 **Symbol** 和 **BigInt** 是ES6 中新增的数据类型：

- **Symbol**代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的**全局变量冲突**的问题。
- **BigInt** 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经**超出了 Number** 能够表示的安全整数范围。

**基本数据类型**直接存储在 **栈**内存 中，**引用数据类型** **栈**内存中仅存储 指向堆内存的**地址**，实际存储在堆内存中。

### 如何判断数组

1.`Array.isArray()`：ES5新增用来**专门为判断数组**的方法。

```js
Array.isArray([1, 2]); // true
```

2.`Object.prototype.toString.call()`：利用 **Object 原型的 toString 方法**，返回一个表示对象类型的字符串 [object Type]，数组会返回 [object Array]。

```js
Object.prototype.toString.call([]) === '[object Array]'  //  true
```

3.`instanceof` 运算符：判断一个对象是否是某个**构造函数的实例**（数组的构造函数是 Array）。

```js
[1, 2] instanceof Array; // true
```

4.`value.constructor === Array`：通过对象的 constructor 属性**判断其构造函数是否为 Array**。

```js
[].constructor === Array; // true
```

### 深浅拷贝

`Js`包含基本数据类型与引用数据类型两种不同的数据类型的值，深拷贝与浅拷贝的概念**只存在于引用数据类型**。

对于引用类型，**浅拷贝**是拷贝了指向这个对象堆内存的指针，是**拷贝了对原对象引用**，**深拷贝**是**拷贝了该对象的所有属性到一个新的对象**，若是原对象的**某属性依然引用了其他对象**，那么需要将原对象引用的其他对象**一并进行深拷贝**，并不断递归进行。

对于**基本数据类型**是不存在深拷贝与浅拷贝的概念的，如果将一个基本数据类型**变量的值赋值到另一个变量**，那么新变量的值是对于原变量值的**复制而不是引用**，如果必须要按照深浅拷贝的概念理解的话，对于基本数据类型的复制可以理解为**按值深拷贝**。

### 事件循环

JavaScript 设计为**单线程**（同一时间只能执行一段代码），但需处理异步任务（如定时器、网络请求、DOM 事件），事件循环就是**协调同步任务与异步任务执行顺序**的机制。

关键概念

1. **执行栈（Call Stack）**：存放正在执行的同步代码，遵循 “后进先出” 规则。
2. **任务队列**（Task Queue）：存放异步任务完成后的回调函数，分为两种：
   - 宏任务（Macro Task）：script 整体代码、setTimeout、setInterval、DOM 事件、I/O、postMessage 等。
   - 微任务（Micro Task）：Promise.then/catch/finally、process.nextTick（Node 环境）、MutationObserver 等。
3. **主线程**：执行栈为空时，从任务队列中读取任务执行的线程。

事件循环执行流程（浏览器环境）

1. 先执行执行栈中的**所有同步代码**，直到执行栈为空。
2. 执行**所有微任务队列**中的任务，按队列顺序依次执行，直到微任务队列为空。
3. 从**宏任务队列**中取出第一个任务，推入执行栈执行。
4. 重复步骤 1-3，形成循环（即 “事件循环”）。

代码示例：

```js
console.log('1'); // 同步代码

setTimeout(() => {
  console.log('2'); // 宏任务回调
}, 0);

new Promise((resolve) => {
  console.log('3'); // Promise 构造函数内是同步代码
  resolve();
}).then(() => {
  console.log('4'); // 微任务回调
});

console.log('5'); // 同步代码
```

执行结果：1 → 3 → 5 → 4 → 2

解析

1. 同步代码 `console.log('1')`「3」「5」依次执行，执行栈为空。
2. 执行微任务队列中的 `console.log('4')`，微任务队列为空。
3. 执行宏任务队列中的 `console.log('2')`，完成一次循环。
