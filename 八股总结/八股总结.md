# 八股总结

## CSS盒模型

CSS 盒模型（Box Model）是网页布局的核心概念，它定义了元素在页面中占据空间的方式。每个 HTML 元素都可以看作一个矩形的 “盒子”，这个盒子由四个部分组成，从内到外依次是：**内容区（Content）**、**内边距（Padding）**、**边框（Border）**、**外边距（Margin）**。

### 盒模型的组成部分

1. **内容区（Content）**盒子的核心区域，用于显示文本、图像等内容。尺寸由 `width`（宽度）和 `height`（高度）控制（默认仅适用于块级元素）。
2. **内边距（Padding）**内容区与边框之间的空白区域，会影响盒子的总大小。通过 `padding-top`、`padding-right`、`padding-bottom`、`padding-left` 或简写 `padding` 控制。
3. **边框（Border）**包裹内容区和内边距的线条，会增加盒子的总大小。通过 `border` 相关属性（如 `border-width`、`border-style`、`border-color`）控制。
4. **外边距（Margin）**盒子与其他元素之间的空白区域，不影响盒子自身大小，但会影响盒子在页面中的位置和与其他元素的间距。通过 `margin-top`、`margin-right`、`margin-bottom`、`margin-left` 或简写 `margin` 控制。

### 两种盒模型模式

CSS 中有两种盒模型计算方式，由 `box-sizing` 属性控制：

1. **标准盒模型（W3C 盒模型）**
   - 默认模式（`box-sizing: content-box`）。
   - 盒子的总宽度 = `width` + `padding-left` + `padding-right` + `border-left-width` + `border-right-width`。
   - 盒子的总高度 = `height` + `padding-top` + `padding-bottom` + `border-top-width` + `border-bottom-width`。
   - 即 `width` 和 `height` 仅作用于内容区，内边距和边框会额外增加盒子的总尺寸。
2. **怪异盒模型（IE 盒模型）**
   - 通过 `box-sizing: border-box` 启用。
   - 盒子的总宽度 = `width`（已包含内容区、左右内边距、左右边框）。
   - 盒子的总高度 = `height`（已包含内容区、上下内边距、上下边框）。
   - 即 `width` 和 `height` 直接表示盒子的总尺寸，内边距和边框不会超出这个范围（会压缩内容区的空间）。

## BFC块级格式化上下文

BFC（Block Formatting Context，块级格式化上下文）是 CSS 中一个重要的渲染概念，它决定了元素如何对其内容进行布局，以及与其他元素之间的关系和相互作用。简单来说，**BFC 是一个独立的渲染区域，区域内的元素布局不受外部影响，同时区域内的布局也不会干扰外部元素**。

### BFC 的特性（核心作用）

1. **内部元素垂直方向依次排列**（符合块级元素的默认布局）。
2. **内部元素的外边距（margin）会发生折叠**（垂直方向相邻元素的 margin 取最大值，而非相加）。
3. **BFC 区域不会与浮动元素重叠**（可用于清除浮动影响）。
4. **BFC 是一个独立的容器**，容器内的子元素不会影响外部元素，反之亦然。
5. **计算 BFC 高度时，浮动元素也会参与计算**（可用于解决浮动导致的父元素高度塌陷问题）。

### 如何触发 BFC？

满足以下条件之一的元素会创建 BFC：

- 根元素（`<html>` 标签，默认创建 BFC）。
- 浮动元素（`float: left` 或 `float: right`，非 `none`）。
- 绝对定位 / 固定定位元素（`position: absolute` 或 `position: fixed`）。
- 块级元素且 `overflow` 值为 `auto`、`scroll`、`hidden`（非 `visible`）。
- 弹性容器（`display: flex` 或 `display: inline-flex` 的直接子元素）。
- 网格容器（`display: grid` 或 `display: inline-grid` 的直接子元素）。
- `display` 值为 `flow-root`（CSS3 新增，专门用于创建 BFC，无副作用）。

### BFC 的实际应用场景

**1. 解决浮动导致的父元素高度塌陷**

当父元素的子元素设置浮动后，父元素会失去高度（因为浮动元素脱离文档流）。触发父元素的 BFC 后，父元素会包含浮动元素，从而恢复高度。

```html
<div class="parent"> <!-- 父元素 -->
  <div class="child"></div> <!-- 浮动子元素 -->
</div>

<style>
.parent {
  /* 触发 BFC，解决高度塌陷 */
  overflow: hidden; /* 或其他触发条件 */
  border: 1px solid #000;
}
.child {
  float: left;
  width: 100px;
  height: 100px;
  background: red;
}
</style>
```

**2.阻止元素被浮动元素覆盖**

当一个元素不浮动，而相邻元素浮动时，非浮动元素可能会被浮动元素覆盖。给非浮动元素触发 BFC 可避免这种情况（常用于两栏布局）。

```html
<div class="float-box"></div> <!-- 浮动元素 -->
<div class="normal-box"></div> <!-- 非浮动元素 -->

<style>
.float-box {
  float: left;
  width: 100px;
  height: 100px;
  background: red;
}
.normal-box {
  /* 触发 BFC，避免被浮动元素覆盖 */
  overflow: hidden;
  height: 200px;
  background: blue;
}
</style>
```

**3.阻止垂直方向的 margin 折叠**

相邻元素（或父子元素）的垂直 margin 会自动折叠（取最大值）。将它们放入不同的 BFC 中，可阻止折叠。

```html
<div class="box1"></div>
<div class="container"> <!-- 容器创建 BFC -->
  <div class="box2"></div>
</div>

<style>
.box1, .box2 {
  height: 50px;
  margin: 20px 0; /* 垂直 margin */
  background: red;
}
.container {
  /* 触发 BFC，阻止与外部 box1 的 margin 折叠 */
  overflow: hidden;
}
</style>
```

- 若不触发 `container` 的 BFC，`box1` 和 `box2` 的 margin 会折叠（总间距为 20px）；
- 触发后，两者的 margin 不折叠（总间距为 40px）。

## CSS权重

CSS 权重（Specificity）是浏览器用于判断多个 CSS 规则对同一元素的样式声明哪个更优先生效的机制。当多个规则应用于同一元素时，权重高的规则会覆盖权重低的规则。

### 权重的计算规则

CSS 权重采用 “四元组” 表示：`(a, b, c, d)`，优先级从高到低依次为 `a > b > c > d`，数值越大权重越高。具体计算方式如下：

1. **`a`（内联样式）**：元素标签内的 `style` 属性，权重最高。例：`<div style="color: red">` → `a=1`。
2. **`b`（ID 选择器）**：以 `#` 开头的选择器。例：`#header` → `b=1`；`#nav #logo` → `b=2`。
3. **`c`（类 / 伪类 / 属性选择器）**：
   - 类选择器：以 `.` 开头（如 `.active`）；
   - 伪类选择器：如 `:hover`、`:nth-child(2)`；
   - 属性选择器
4. **`d`（元素 / 伪元素选择器）**：
   - 元素选择器：如 `div`、`p`、`ul`；
   - 伪元素选择器：如 `::before`、`::after`。

### 权重比较规则

1. **从高到低依次比较**：先比较 `a`，`a` 大的权重更高；若 `a` 相等，比较 `b`，以此类推。例：`(1,0,0,0)` > `(0,2,0,0)`（内联样式 > 2 个 ID 选择器）。
2. **同权重时，后声明的规则覆盖先声明的**：若两个规则权重完全相同，写在后面的规则生效。
3. **通配符（`\*`）、继承样式、`!important` 特殊处理**：
   - 通配符 `*`：权重为 `(0,0,0,0)`，比任何具体选择器都低。
   - 继承的样式：权重最低，任何直接应用于元素的规则都能覆盖它。
   - !important：加在样式值后（如 color: red !important），会强制提升该样式的优先级，比内联样式还高（除非内联样式也加 !important）。

### 常见权重计算示例

| 选择器               | 权重 (a,b,c,d) | 说明                |
| -------------------- | -------------- | ------------------- |
| `div`                | (0,0,0,1)      | 1 个元素选择器      |
| `.box`               | (0,0,1,0)      | 1 个类选择器        |
| `#nav`               | (0,1,0,0)      | 1 个 ID 选择器      |
| `style="..."`        | (1,0,0,0)      | 内联样式            |
| `div.box`            | (0,0,1,1)      | 1 类 + 1 元素       |
| `#nav .link`         | (0,1,1,0)      | 1ID + 1 类          |
| `ul li:nth-child(2)` | (0,0,1,2)      | 1 伪类 + 2 元素     |
| `div#header .menu a` | (0,1,1,2)      | 1ID + 1 类 + 2 元素 |

## 闭包

闭包（Closure）是 JavaScript 中一个强大且重要的概念，简单来说，**闭包是指函数能够访问其自身作用域之外的变量**，即使外部函数已经执行完毕，这些变量依然可以被内部函数访问和操作。

### 闭包的形成条件

闭包的形成需要满足三个条件：

1. **嵌套函数**：存在内部函数嵌套在外部函数中；
2. **访问外部变量**：内部函数引用了外部函数中的变量或参数；
3. **外部函数返回内部函数**：外部函数将内部函数作为返回值，使得内部函数在外部函数执行完毕后仍能被调用。

### 闭包的基本示例

```js
function outer() {
  const outerVar = "我是外部变量"; // 外部函数的局部变量

  // 内部函数，引用了外部变量 outerVar
  function inner() {
    console.log(outerVar); // 访问外部函数的变量
  }

  return inner; // 外部函数返回内部函数
}

// 调用外部函数，得到内部函数的引用
const closureFunc = outer();
// 执行内部函数（此时 outer 已经执行完毕）
closureFunc(); // 输出："我是外部变量"
```

- 正常情况下，`outer` 函数执行完毕后，其内部变量 `outerVar` 会被垃圾回收机制销毁；
- 但由于 `inner` 函数引用了 `outerVar` 且被返回外部，`outerVar` 会被 “保留”，形成闭包。

### 闭包的核心特性

**延长变量生命周期**：外部函数的变量不会因函数执行完毕而销毁，只要内部函数还能被访问，这些变量就会一直存在。

```js
function createCounter() {
  let count = 0; // 被闭包保留的变量
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2（count 被持续修改）
```

**隔离作用域**：闭包可以创建独立的作用域，不同闭包之间的变量互不干扰。

```js
const counter1 = createCounter();
const counter2 = createCounter();
console.log(counter1()); // 1
console.log(counter2()); // 1（counter1 和 counter2 的 count 是独立的）
```

### 闭包的常见应用场景

1. **模块化封装**：隐藏内部变量，只暴露必要的接口（类似 “私有变量”）。

   ```javascript
   function createPerson(name) {
     let age = 0; // 私有变量，外部无法直接访问
     return {
       getName: () => name,
       getAge: () => age,
       grow: () => age++ // 只能通过方法修改
     };
   }
   
   const person = createPerson("Alice");
   console.log(person.getName()); // "Alice"
   person.grow();
   console.log(person.getAge()); // 1（age 无法被外部直接修改）
   ```

2. **防抖与节流**：利用闭包保存定时器变量，实现函数调用的控制。

   ```javascript
   // 防抖：多次触发只执行最后一次
   function debounce(fn, delay) {
     let timer; // 闭包保存定时器
     return function(...args) {
       clearTimeout(timer);
       timer = setTimeout(() => fn.apply(this, args), delay);
     };
   }
   ```

3. **回调函数与事件处理**：在异步操作（如定时器、Ajax）中，保存上下文变量。

   ```javascript
   function fetchData(url) {
     const name = "数据请求"; // 闭包保留 url 和 name
     setTimeout(() => {
       console.log(`${name}: ${url}`); // 即使 fetchData 执行完，仍能访问 url
     }, 1000);
   }
   fetchData("https://api.example.com"); // 1秒后输出："数据请求: https://api.example.com"
   ```

### 闭包的注意事项

1. **内存消耗**：闭包会保留外部变量，若大量使用或未及时释放，可能导致内存泄漏（尤其是在长期运行的程序中，如浏览器页面）。解决：不再使用闭包时，将其引用设为 `null`（`closureFunc = null`），让垃圾回收机制回收变量。
2. **this 指向问题**：闭包中的 `this` 通常指向全局对象（非严格模式）或 `undefined`（严格模式），而非外部函数的 `this`。解决：提前用变量保存外部 `this`（`const self = this;`）。
