## 算法总结

### 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        // 计算中间索引（避免溢出：等同于 Math.floor((left + right) / 2)）
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid; // 找到目标，返回下标
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标在右半部分
        } else {
            right = mid - 1; // 目标在左半部分
        }
    }
    
    return -1; // 未找到目标
}
```

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

双指针法思路

1. 定义两个指针：
   - `fast` 指针：遍历整个数组，用于寻找不等于 `val` 的元素。
   - `slow` 指针：指向当前需要填充新元素的位置（即新数组的末尾）。
2. 遍历过程：
   - 当 `fast` 指向的元素不等于 `val` 时，将该元素复制到 `slow` 指向的位置，然后 `slow` 向前移动一步（新数组长度 + 1）。
   - 当 `fast` 指向的元素等于 `val` 时，`fast` 直接跳过（不处理）。
3. **结束条件**：`fast` 遍历完整个数组后，`slow` 的值就是新数组的长度。

```js
function removeElement(nums, val) {
    let slow = 0; // 慢指针：记录新数组的长度，指向待填充位置
    for (let fast = 0; fast < nums.length; fast++) {
        // 当快指针找到不等于val的元素时，复制到慢指针位置
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++; // 慢指针前移，更新新数组长度
        }
    }
    return slow; // 慢指针的值就是新数组的长度
}
```

### 有序数组的平方

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

关键思路

原数组是**非递减排序**的，但平方后可能出现 “两边大、中间小” 的情况（因为负数平方后可能比正数大，例如 `[-4, -1, 2, 3]` 平方后为 `[16, 1, 4, 9]`）。因此，可采用**双指针法**从两端向中间遍历，比较两端元素的平方大小，将较大的平方值从新数组的末尾开始填充，最终得到有序结果。

双指针法实现步骤

1. 初始化左指针 `left` 指向数组起点（0），右指针 `right` 指向数组终点（`nums.length - 1`）。
2. 创建结果数组 `result`，长度与原数组相同，初始化索引 `index` 为 `nums.length - 1`（从末尾开始填充）。
3. 比较 `nums[left]` 和 `nums[right]` 的平方:
   - 若 `left` 指向元素的平方更大，将其放入 `result[index]`，并右移 `left`。
   - 否则，将 `right` 指向元素的平方放入 `result[index]`，并左移 `right`。
4. 递减 `index`，重复步骤 3，直到 `left` 超过 `right`。

```javascript
function sortedSquares(nums) {
    const n = nums.length;
    const result = new Array(n); // 结果数组
    let left = 0;
    let right = n - 1;
    let index = n - 1; // 从结果数组末尾开始填充

    while (left <= right) {
        const leftSquare = nums[left] * nums[left];
        const rightSquare = nums[right] * nums[right];

        if (leftSquare > rightSquare) {
            result[index] = leftSquare;
            left++; // 左指针右移
        } else {
            result[index] = rightSquare;
            right--; // 右指针左移
        }
        index--; // 结果数组索引左移
    }

    return result;
}
```

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

暴力破解的核心逻辑

1. 外层循环 `i` 定义子数组的起点（从 0 到 n-1）。
2. 内层循环 `j` 从起点 `i` 开始，逐步扩展子数组的终点，同时累加子数组的和。
3. 当子数组的和 `currentSum` 大于等于 `s` 时，计算当前子数组的长度（`j - i + 1`），并与已知的最小长度比较更新。
4. 找到符合条件的子数组后，通过 `break` 退出内层循环（因为继续扩展会使子数组更长，无需考虑）。
5. 遍历结束后，如果始终没有找到符合条件的子数组（`minLength` 仍为 `Infinity`），返回 0，否则返回最小长度。

```js
function minSubArrayLen(s, nums) {
    const n = nums.length;
    let minLength = Infinity; // 初始化最小长度为无穷大

    // 外层循环：遍历所有可能的子数组起点
    for (let i = 0; i < n; i++) {
        let currentSum = 0; // 记录当前子数组的和
        
        // 内层循环：从起点i开始，扩展子数组的终点
        for (let j = i; j < n; j++) {
            currentSum += nums[j]; // 累加当前元素到子数组和中
            
            // 一旦子数组和大于等于s，更新最小长度
            if (currentSum >= s) {
                const currentLength = j - i + 1;
                minLength = Math.min(minLength, currentLength);
                break; // 找到当前起点的最短子数组，无需继续扩展
            }
        }
    }

    // 如果未找到符合条件的子数组，返回0，否则返回最小长度
    return minLength === Infinity ? 0 : minLength;
}
    
```

要解决这个问题，最高效的方法是使用**滑动窗口**（双指针）技术，时间复杂度可以优化到 O (n)，比暴力解法（O (n²)）更高效。

滑动窗口思路

1. 定义两个指针 `left` 和 `right`，分别表示窗口的左右边界，初始都为 0。
2. 移动 `right` 指针扩大窗口，累加元素和 `sum`。
3. 当 `sum >= s` 时，尝试移动 `left` 指针缩小窗口，同时更新最小长度。
4. 重复步骤 2-3，直到 `right` 遍历完整个数组。

```js
function minSubArrayLen(s, nums) {
    let left = 0; // 窗口左边界
    let sum = 0; // 当前窗口的和
    let minLen = Infinity; // 最小子数组长度

    // 移动右边界，扩大窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];

        // 当窗口和 >= s 时，尝试缩小左边界
        while (sum >= s) {
            // 计算当前窗口长度并更新最小值
            const currentLen = right - left + 1;
            minLen = Math.min(minLen, currentLen);
            
            // 移动左边界，缩小窗口
            sum -= nums[left];
            left++;
        }
    }

    // 如果没找到符合条件的子数组，返回 0
    return minLen === Infinity ? 0 : minLen;
}
    
```

### 螺旋矩阵II

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

要解决这个问题，我们需要生成一个包含 1 到 n² 所有元素的正方形矩阵，且元素按顺时针螺旋排列。核心思路是**模拟顺时针螺旋的填充过程**，通过控制边界逐步缩小填充范围。

解题步骤

1. **初始化矩阵**：创建一个 n×n 的空矩阵，用于存放结果。
2. **定义边界**：设定上、下、左、右四个边界，初始分别为矩阵的顶部（0）、底部（n-1）、左侧（0）、右侧（n-1）。
3. **顺时针填充**：按照 “从左到右→从上到下→从右到左→从下到上” 的顺序循环填充，每完成一轮方向填充就缩小对应边界，直到所有元素（1 到 n²）都被填充完毕。

代码实现

```js
function generateMatrix(n) {
    // 初始化 n×n 的二维数组，填充 0
    const res = new Array(n).fill(0).map(item => new Array(n).fill(0))
    let startx = 0, starty = 0; // 每圈的起始位置
    let loop = Math.floor(n / 2); // 循环的圈数（n为奇数时，中心单独处理）
    const mid = Math.floor(n / 2); // 中心位置索引
    let count = 1; // 填充的数字，从1开始
    let offset = 1; // 每圈边界收缩量
    let i, j;

    while (loop--) {
        i = startx;
        j = starty;

        // 1. 上行：从左到右（左闭右开）
        for (j; j < n - offset; j++) {
            res[i][j] = count++;
        }

        // 2. 右列：从上到下（左闭右开）
        for (i; i < n - offset; i++) {
            res[i][j] = count++;
        }

        // 3. 下行：从右到左（左闭右开）
        for (; j > starty; j--) {
            res[i][j] = count++;
        }

        // 4. 左列：从下到上（左闭右开）
        for (; i > startx; i--) {
            res[i][j] = count++;
        }

        // 下一圈的起始位置内移
        startx++;
        starty++;

        // 边界收缩量增加
        offset++;
    }

    // 如果n是奇数，填充中心元素
    if (n % 2 !== 0) {
        res[mid][mid] = count;
    }

    return res;
}

// 测试示例
console.log(generateMatrix(3)); 
// 输出: [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ]
```

### 区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```js
5
1
2
3
4
5
0 1
1 3
```

输出示例

```js
3
9
```

暴力破解的核心思路

1. 读取数组长度和元素，存储为数组 `array`。

2. 对每个输入的区间[l, r]

   （假设 0 开始索引，左闭右闭）：

   - 从索引 `l` 遍历到 `r`，累加每个元素的值。
   - 输出累加结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组

rl.on('line', (line) => {
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 读取数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，切换到读取区间模式
      if (array.length === n) {
        isReadingArray = false;
      }
    }
  } else {
    // 处理区间请求：暴力遍历求和
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    let sum = 0;
    // 从 l 遍历到 r，累加元素
    for (let i = l; i <= r; i++) {
      sum += array[i];
    }
    console.log(sum);
  }
});
```

使用前缀和的解题思路

1. 读取数组长度与元素：先获取数组长度 `n`，再读取 `n` 个整数构建原数组。
2. 构建前缀和数组：前缀和数组 `prefix` 中，`prefix[i]` 表示原数组前 `i` 个元素的和（`prefix[0] = 0`，`prefix[1] = 原数组[0]`，以此类推）。通过前缀和可快速计算任意区间 `[l, r]` 的和：`sum = prefix[r+1] - prefix[l]`（假设区间从 0 开始索引）。
3. 处理区间请求：持续读取输入的区间（每行两个整数，代表区间的起始和结束索引），利用前缀和数组计算并输出每个区间的和，直至输入结束。

```js
const readline = require('readline');

// 创建读取输入的接口
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组阶段
let prefix = []; // 前缀和数组

// 处理每一行输入
rl.on('line', (line) => {
  // 去除行首尾空格，避免空输入干扰
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 第一行输入：数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 后续 n 行：读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，构建前缀和数组
      if (array.length === n) {
        isReadingArray = false;
        // 构建前缀和：prefix[0] = 0，prefix[1] = array[0]，prefix[2] = array[0]+array[1]...
        prefix[0] = 0;
        for (let i = 0; i < n; i++) {
          prefix[i + 1] = prefix[i] + array[i];
        }
      }
    }
  } else {
    // 读取区间请求：每行两个整数，代表区间 [l, r]（0 开始索引，左闭右闭）
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    // 区间和 = 前缀和[r+1] - 前缀和[l]
    const sum = prefix[r + 1] - prefix[l];
    console.log(sum);
  }
});
```

### 开发商买地

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

要解决这个问题，我们需要将一个 `n×m` 的城市区块按横向或纵向划分为两部分，使两部分的土地总价值之差最小。核心思路是**枚举所有可能的划分方式，计算每种方式的价值差，最终选择最小值**。

暴力解题步骤：

1. 读取输入并解析网格：获取 `n`（行数）和 `m`（列数），以及每个区块的价值，构建二维数组。
2. 计算总价值：先求出所有区块的总价值 `sum`，方便后续计算两部分的差值。
3. 枚举横向划分：
   - 横向划分有 `n-1` 种可能（在第 `k` 行和第 `k+1` 行之间切分，`k` 从 1 到 `n-1`）。
   - 对每种划分，计算上半部分（前 `k` 行）的总价值 `s`，差值为 `|2s - sum|`（因为另一部分价值为 `sum - s`，差值简化为 `|s - (sum - s)|`）。
4. 枚举纵向划分：
   - 纵向划分有 `m-1` 种可能（在第 `k` 列和第 `k+1` 列之间切分，`k` 从 1 到 `m-1`）。
   - 对每种划分，计算左半部分（前 `k` 列）的总价值 `s`，差值同样为 `|2s - sum|`。
5. 找最小差值：从横向和纵向划分的所有差值中，选择最小的那个作为结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
  inputLines.push(line.trim());
}).on('close', () => {
  // 解析输入
  const [n, m] = inputLines[0].split(' ').map(Number);
  const grid = [];
  for (let i = 1; i <= n; i++) {
    grid.push(inputLines[i].split(' ').map(Number));
  }

  // 计算所有区块的总价值
  let totalSum = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      totalSum += grid[i][j];
    }
  }

  let minDiff = Infinity; // 初始化最小差值为无穷大

  // 1. 枚举横向划分（按行切分）
  let rowSum = 0; // 累计前k行的总价值
  for (let k = 0; k < n - 1; k++) { // 切分位置：第k行后（0-based），共n-1种
    // 累加第k行的价值到rowSum（前k+1行的总和）
    for (let j = 0; j < m; j++) {
      rowSum += grid[k][j];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * rowSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 2. 枚举纵向划分（按列切分）
  let colSum = 0; // 累计前k列的总价值
  for (let k = 0; k < m - 1; k++) { // 切分位置：第k列后（0-based），共m-1种
    // 累加第k列的价值到colSum（前k+1列的总和）
    for (let i = 0; i < n; i++) {
      colSum += grid[i][k];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * colSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 输出最小差值
  console.log(minDiff);
});
```

用前缀和实现步骤：

1. 计算总行前缀和：`rowPrefix[i]` 表示前 `i` 行的总价值（用于横向分割时快速查询上部分价值）。
2. 计算总列前缀和：`colPrefix[j]` 表示前 `j` 列的总价值（用于纵向分割时快速查询左部分价值）。
3. 遍历所有横向 / 纵向分割线，利用前缀和直接计算两部分的价值差，取最小值。

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const readlineContent = [];
let grid = [];
let totalSum = 0;
let minDiff = Infinity;

rl.on('line', (line) => {
    const processLine = line.trim();
    if (processLine) readlineContent.push(processLine);
});

rl.on('close', () => {
    // 解析n和m
    const [n, m] = readlineContent[0].split(' ').map(Number);
    // 构建网格
    for (let i = 1; i <= n; i++) {
        grid.push(readlineContent[i].split(' ').map(Number));
    }

    // 1. 计算总行前缀和（用于横向分割）
    // rowPrefix[i] = 前i行的总价值（i从0到n，rowPrefix[0]=0，rowPrefix[1]=第0行总和，以此类推）
    const rowPrefix = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        // 第i-1行的总和（累加当前行的所有列）
        let rowSum = 0;
        for (let j = 0; j < m; j++) {
            rowSum += grid[i - 1][j];
        }
        rowPrefix[i] = rowPrefix[i - 1] + rowSum;
    }
    totalSum = rowPrefix[n]; // 总价值 = 前n行的总和

    // 2. 计算总列前缀和（用于纵向分割）
    // colPrefix[j] = 前j列的总价值（j从0到m，colPrefix[0]=0，colPrefix[1]=第0列总和，以此类推）
    const colPrefix = new Array(m + 1).fill(0);
    for (let j = 1; j <= m; j++) {
        // 第j-1列的总和（累加当前列的所有行）
        let colSum = 0;
        for (let i = 0; i < n; i++) {
            colSum += grid[i][j - 1];
        }
        colPrefix[j] = colPrefix[j - 1] + colSum;
    }

    // 3. 横向分割：遍历所有可能的分割线（第i行后，i从1到n-1）
    for (let i = 1; i < n; i++) {
        const upperSum = rowPrefix[i]; // 上部分 = 前i行的总和
        const lowerSum = totalSum - upperSum;
        const diff = Math.abs(upperSum - lowerSum);
        minDiff = Math.min(minDiff, diff);
    }

    // 4. 纵向分割：遍历所有可能的分割线（第j列后，j从1到m-1）
    for (let j = 1; j < m; j++) {
        const leftSum = colPrefix[j]; // 左部分 = 前j列的总和
        const rightSum = totalSum - leftSum;
        const diff = Math.abs(leftSum - rightSum);
        minDiff = Math.min(minDiff, diff);
    }

    console.log(minDiff);
});
```

### 移除链表元素

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

解题思路

1. 虚拟头节点：由于要删除的节点可能是原链表的头节点，引入虚拟头节点（`dummy`）可以避免单独处理头节点的特殊逻辑，其 `next` 指针指向原链表的头节点。
2. 遍历与删除使用指针 `current` 从虚拟头节点开始遍历，检查其下一个节点的值是否为 `val`：
   - 若为 `val`，则通过 `current.next = current.next.next` 跳过该节点（删除操作）。
   - 若不为 `val`，则将 `current` 后移一位，继续检查下一个节点。
3. 返回结果：遍历结束后，虚拟头节点的 `next` 指针即为删除后的新链表头节点。

```js
// 定义链表节点构造函数
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

// 删除链表中所有值为 val 的节点
var removeElements = function(head, val) {
    // 创建虚拟头节点，简化头节点删除逻辑
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let current = dummy; // 从虚拟头节点开始遍历
    
    // 遍历链表，检查当前节点的下一个节点是否需要删除
    while (current.next !== null) {
        if (current.next.val === val) {
            // 下一个节点需删除，跳过该节点
            current.next = current.next.next;
        } else {
            // 下一个节点无需删除，移动 current 指针
            current = current.next;
        }
    }
    
    // 返回删除后的链表头节点（虚拟头节点的 next）
    return dummy.next;
};
```

### 设计链表

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

示例：

```js
const linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);    //链表变为1-> 2-> 3
linkedList.get(1);             //返回2
linkedList.deleteAtIndex(1);   //现在链表是1-> 3
linkedList.get(1);             //返回3
```

实现

```js
class MyLinkedList {
  constructor() {
    // 虚拟头节点（简化边界处理）
    this.dummy = new ListNode(0);
    // 记录链表长度（方便快速判断索引有效性）
    this.size = 0;
  }

  /**
   * 获取链表中第 index 个节点的值
   * @param {number} index 目标索引
   * @return {number} 节点值（无效索引返回 -1）
   */
  get(index) {
    // 索引无效的情况（超出范围）
    if (index < 0 || index >= this.size) {
      return -1;
    }

    // 从虚拟头节点的下一个节点开始遍历
    let current = this.dummy.next;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    return current.val;
  }

  /**
   * 在链表头部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtHead(val) {
    // 创建新节点，next 指向原头节点
    const newNode = new ListNode(val, this.dummy.next);
    // 虚拟头节点指向新节点（更新头节点）
    this.dummy.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 在链表尾部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtTail(val) {
    // 遍历到最后一个节点
    let current = this.dummy;
    while (current.next !== null) {
      current = current.next;
    }
    // 在尾部添加新节点
    current.next = new ListNode(val);
    // 长度加 1
    this.size++;
  }

  /**
   * 在指定索引前添加节点
   * @param {number} index 目标索引
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtIndex(index, val) {
    // 索引大于长度时不插入
    if (index > this.size) {
      return;
    }
    // 索引小于 0 时，视为在头部插入
    if (index < 0) {
      index = 0;
    }

    // 找到要插入位置的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 创建新节点，插入到 current 后面
    const newNode = new ListNode(val, current.next);
    current.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 删除指定索引的节点
   * @param {number} index 目标索引
   * @return {void}
   */
  deleteAtIndex(index) {
    // 索引无效时不删除
    if (index < 0 || index >= this.size) {
      return;
    }

    // 找到要删除节点的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 跳过要删除的节点（完成删除）
    current.next = current.next.next;
    // 长度减 1
    this.size--;
  }
}

// 链表节点构造函数
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}
```

### 反转链表

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

方法 1：迭代法

通过三个指针（`prev`、`current`、`next`）逐步反转链表指针方向，原地完成反转。

```js
/**
 * 定义链表节点
 * @param {number} val 节点值
 * @param {ListNode} next 下一个节点
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 迭代法反转链表
 * @param {ListNode} head 链表头节点
 * @return {ListNode} 反转后的头节点
 */
function reverseList(head) {
  let prev = null; // 初始化前一个节点为 null（反转后尾节点的 next 是 null）
  let current = head; // 当前节点从 head 开始

  while (current !== null) {
    const next = current.next; // 先保存当前节点的下一个节点（防止丢失）
    current.next = prev; // 反转指针：当前节点指向前一个节点
    prev = current; // 前一个节点向后移动（当前节点成为新的前节点）
    current = next; // 当前节点向后移动（处理下一个节点）
  }

  // 循环结束后，prev 就是反转后的头节点（原尾节点）
  return prev;
}
```

步骤解析：以 `1->2->3->null` 为例：

1. 初始：`prev = null`，`current = 1`
2. 第一次循环：`next = 2` → `1.next = null` → `prev = 1` → `current = 2`
3. 第二次循环：`next = 3` → `2.next = 1` → `prev = 2` → `current = 3`
4. 第三次循环：`next = null` → `3.next = 2` → `prev = 3` → `current = null`
5. 结束，返回 `prev = 3`（反转后链表：`3->2->1->null`）

方法 2：递归法

利用递归栈回溯时反转指针，从链表尾部开始逐步反转。

```js
// 构建示例链表：1->2->3->4->5->null
const head = new ListNode(1, 
  new ListNode(2, 
    new ListNode(3, 
      new ListNode(4, 
        new ListNode(5)
      )
    )
  )
);

// 反转链表
const reversedHead = reverseList(head);

// 打印结果（5->4->3->2->1->null）
let current = reversedHead;
while (current !== null) {
  console.log(current.val); // 输出：5 4 3 2 1
  current = current.next;
}
```

### 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路解析

以链表 `1->2->3->4->null` 为例，目标是交换成 `2->1->4->3->null`。关键是：

1. 用**虚拟头节点**（dummy）简化边界处理（避免头节点变化的特殊判断）。
2. 每次处理一对节点（如 `1` 和 `2`），需要修改它们前后节点的指向。
3. 用指针跟踪当前待交换节点的前一个节点（`prev`），方便修改指向。

步骤拆解

1. 初始化虚拟头节点 `dummy`，让 `dummy.next = head`（指向原链表头）。
2. 定义 `prev` 指针，初始指向 `dummy`（`prev` 始终是待交换节点对的前一个节点）。
3. 循环条件：`prev.next` 和 `prev.next.next` 都存在（确保有两个节点可交换）。
4. 每次循环交换一对节点：
   - 标记第一个节点 `node1 = prev.next`（如 `1`）。
   - 标记第二个节点 `node2 = prev.next.next`（如 `2`）。
   - 交换指向：`prev.next = node2` → `node1.next = node2.next` → `node2.next = node1`。
   - 移动 `prev` 到交换后的第一个节点（如 `1`），准备处理下一对。

```js
/**
 * 定义链表节点
 * @param {number} val
 * @param {ListNode} next
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 两两交换链表中的节点
 * @param {ListNode} head
 * @return {ListNode}
 */
function swapPairs(head) {
  // 创建虚拟头节点，简化边界处理
  const dummy = new ListNode(0);
  dummy.next = head;
  // prev 指向待交换节点对的前一个节点（初始为 dummy）
  let prev = dummy;

  // 当存在至少两个节点可交换时，进入循环
  while (prev.next !== null && prev.next.next !== null) {
    // 标记待交换的两个节点
    const node1 = prev.next;       // 第一个节点（如 1）
    const node2 = prev.next.next;  // 第二个节点（如 2）

    // 交换节点指向
    prev.next = node2;      // prev 指向第二个节点（如 dummy->2）
    node1.next = node2.next; // 第一个节点指向第二个节点的下一个（如 1->3）
    node2.next = node1;      // 第二个节点指向第一个节点（如 2->1）

    // prev 移动到交换后的第一个节点（为下一次交换做准备）
    prev = node1;
  }

  // 返回虚拟头节点的下一个（新的头节点）
  return dummy.next;
}
```

### 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 ：

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

方法1：两次遍历

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0, head);
  let length = 0;
  let current = head;

  // 第一次遍历：计算链表长度
  while (current !== null) {
    length++;
    current = current.next;
  }

  // 找到倒数第n个节点的前一个节点（位置为 length - n）
  let prev = dummy;
  for (let i = 0; i < length - n; i++) {
    prev = prev.next;
  }

  // 删除节点
  prev.next = prev.next.next;

  return dummy.next;
}

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

方法二：快慢指针

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

var removeNthFromEnd = function(head, n) {
    // 1. 创建一个虚拟头节点，并将其指向链表的真正头节点
    const dummy = new ListNode(0);
    dummy.next = head;

    // 2. 初始化快慢指针，都指向虚拟头节点
    let fast = dummy;
    let slow = dummy;

    // 3. 快指针先向前移动 n+1 步
    // 这样当快指针到达末尾时，慢指针正好在倒数第 n+1 个节点上
    for (let i = 0; i <= n; i++) {
        fast = fast.next;
    }

    // 4. 快慢指针同时向前移动，直到快指针指向 null
    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 5. 此时 slow.next 就是要删除的倒数第 n 个节点
    // 将 slow 的 next 指针跳过要删除的节点
    slow.next = slow.next.next;

    // 6. 返回虚拟头节点的 next，即新的链表头
    return dummy.next;
};

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

### 链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。

思路：

1. **计算长度**：分别遍历两个链表，得到它们的长度 `lenA` 和 `lenB`。
2. 对齐指针：
   - 定义两个指针 `curA` 和 `curB`，分别指向两个链表的头节点。
   - 计算长度差 `diff = Math.abs(lenA - lenB)`。
   - 让较长链表的指针（比如 `curA`）先向前移动 `diff` 步。这样，`curA` 和 `curB` 就处在了同一个 “对齐” 的位置上，它们到各自链表末尾的距离是相等的。
3. 同步移动
4. 让 `curA` 和 `curB` 同时向前移动，直到它们相遇或者都到达链表末尾。
   - 如果相遇（`curA === curB`），则相遇点就是交点。
   - 如果都到达末尾（`curA === null` 且 `curB === null`），则没有交点。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    // 1. 计算两个链表的长度
    let lenA = 0, lenB = 0;
    let curA = headA, curB = headB;

    while (curA !== null) {
        lenA++;
        curA = curA.next;
    }
    while (curB !== null) {
        lenB++;
        curB = curB.next;
    }

    // 2. 重置指针，并让较长的链表指针先移动
    curA = headA;
    curB = headB;
    
    // 假设 lenA 更长，如果不是，则交换
    if (lenA < lenB) {
        [lenA, lenB] = [lenB, lenA];
        [curA, curB] = [curB, curA];
    }
    
    let diff = lenA - lenB;
    while (diff-- > 0) {
        curA = curA.next;
    }

    // 3. 同步移动，寻找交点
    while (curA !== null && curB !== null) {
        if (curA === curB) {
            return curA;
        }
        curA = curA.next;
        curB = curB.next;
    }

    // 4. 如果循环结束都没有相遇，则没有交点
    return null;
};
```

### 环形链表II

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

思路-快慢指针法：

1. **判断是否存在环**：使用一个慢指针 `slow` 和一个快指针 `fast`。`slow` 每次移动一步，`fast` 每次移动两步。如果链表中存在环，它们最终会在环内相遇。
2. **找到环的入口**：当 `slow` 和 `fast` 相遇后，我们再使用一个新的指针 `ptr`，让它从链表的头节点 `head` 开始，同时让 `slow` 指针继续从相遇点开始，两者都以每次一步的速度移动。它们最终会在**环的入口节点**相遇。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    // 阶段 1: 判断是否存在环，并找到相遇点
    let slow = head;
    let fast = head;
    let hasCycle = false;

    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow === fast) {
            hasCycle = true;
            break;
        }
    }

    // 如果没有环，直接返回 null
    if (!hasCycle) {
        return null;
    }

    // 阶段 2: 找到环的入口节点
    let ptr = head;
    while (ptr !== slow) {
        ptr = ptr.next;
        slow = slow.next;
    }

    // ptr 和 slow 的相遇点就是环的入口
    return ptr;
};
```

### 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母。

方法一：排序后比较:

1. 如果两个字符串长度不同，直接返回 `false`。
2. 将两个字符串分别拆分成字符数组，排序后再拼接成字符串。
3. 比较排序后的字符串是否相等。

```js
function isAnagram(s, t) {
    // 首先判断长度是否相同
    if (s.length !== t.length) return false;
    
    // 排序后比较
    const sortedS = s.split('').sort().join('');
    const sortedT = t.split('').sort().join('');
    
    return sortedS === sortedT;
}
```

哈希表计数:

1. 如果两个字符串长度不同，直接返回 `false`。
2. 用一个长度为 26 的数组 `count` 记录每个字母的出现次数（`count[0]` 对应 'a'，`count[1]` 对应 'b'，以此类推）。
3. 遍历字符串 `s`，统计每个字母的出现次数。
4. 遍历字符串 `t`，减去相应字母的出现次数。如果过程中出现负数，说明 `t` 中有 `s` 中没有的字符，直接返回 `false`。
5. 最后检查 `count` 数组是否所有元素都为 0。

```js
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    // 初始化一个长度为 26 的数组，用于记录每个字母的出现次数
    const count = new Array(26).fill(0);
    
    // 统计 s 中每个字母的出现次数
    for (let i = 0; i < s.length; i++) {
        const index = s.charCodeAt(i) - 'a'.charCodeAt(0);
        count[index]++;
    }
    
    // 减去 t 中每个字母的出现次数
    for (let i = 0; i < t.length; i++) {
        const index = t.charCodeAt(i) - 'a'.charCodeAt(0);
        count[index]--;
        
        // 如果出现负数，说明 t 中有 s 中没有的字符
        if (count[index] < 0) return false;
    }
    
    // 如果数组中所有元素都是 0，说明是字母异位词
    return true;
}
```

### 两个数组的交集

题意：给定两个数组，编写一个函数来计算它们的交集。

说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。

思路1：使用 Set 和 filter 

1. 将其中一个数组转换为 `Set`，以快速查找元素并自动去重。
2. 使用 `filter` 方法遍历另一个数组，检查其元素是否存在于第一步创建的 `Set` 中。
3. 将 `filter` 返回的结果数组再次转换为 `Set` 并转回数组，以确保结果中的元素是唯一的（虽然对于这个问题，步骤 2 的结果已经是唯一的，但这是一个好习惯）。

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
function intersection(nums1, nums2) {
    // 1. 将 nums1 转换为 Set，方便快速查找
    const set1 = new Set(nums1);
    
    // 2. 筛选出 nums2 中存在于 set1 的元素
    // 由于 Set 中的元素是唯一的，filter 的结果也自然是唯一的
    const intersectionArray = nums2.filter(num => set1.has(num));
    
    // 3. 再次转换为 Set 并转回数组，确保结果绝对唯一（此处可省略，但体现严谨性）
    return [...new Set(intersectionArray)];
}

// 更简洁的写法
function intersectionConcise(nums1, nums2) {
    return [...new Set(nums1)].filter(num => new Set(nums2).has(num));
}

// 示例
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
console.log(intersection(nums1, nums2)); // 输出: [2]

const nums3 = [4, 9, 5];
const nums4 = [9, 4, 9, 8, 4];
console.log(intersection(nums3, nums4)); // 输出: [4, 9] (或 [9, 4])
```

思路2：排序后使用双指针

1. 对两个数组进行排序。
2. 初始化两个指针 `i` 和 `j`，分别指向两个数组的开头。
3. 比较两个指针指向的元素：
   - 如果相等，说明找到一个交集元素。为了保证唯一性，需要检查结果数组的最后一个元素是否与当前元素相同，如果不同才加入。然后同时移动两个指针。
   - 如果 `nums1[i]` 小于 `nums2[j]`，移动 `i` 指针。
   - 否则，移动 `j` 指针。
4. 直到其中一个指针超出数组范围。

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
function intersectionWithTwoPointers(nums1, nums2) {
    // 1. 排序两个数组
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);
    
    const result = [];
    let i = 0, j = 0;
    
    // 2. 使用双指针遍历
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] === nums2[j]) {
            // 3. 找到交集元素，确保结果唯一
            if (result.length === 0 || result[result.length - 1] !== nums1[i]) {
                result.push(nums1[i]);
            }
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    
    return result;
}

// 示例
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
console.log(intersectionWithTwoPointers(nums1, nums2)); // 输出: [2]
```

### 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例：

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

思路1：快慢指针

1. 定义一个辅助函数 `getNext(n)`，用于计算一个数 `n` 的每个位置上数字的平方和。
2. 使用快慢指针：
   - `slow` 指针每次走一步，即计算 `getNext(slow)`。
   - `fast` 指针每次走两步，即计算 `getNext(getNext(fast))`。
3. 判断条件：
   - 如果 `fast` 指针先到达 1，说明 `n` 是快乐数，返回 `true`。
   - 如果 `slow` 指针和 `fast` 指针相遇（即进入循环），说明 `n` 不是快乐数，返回 `false`。

```js
function getHappyNum(n) {
    function getNext(n) {
        let sum = 0;
        while (n > 0) {
            let last = n % 10;
            sum += last * last;
            n = Math.floor(n / 10);
        }
        return sum;
    }

    let fast = n;
    let slow = n;

    // 使用无限循环，在内部判断退出条件
    while (true) {
        fast = getNext(getNext(fast));
        slow = getNext(slow);

        // 如果快指针追上慢指针，说明进入循环，不是快乐数
        if (fast === slow) {
            break;
        }
        // 如果快指针先到达1，说明是快乐数
        if (fast === 1) {
            return true;
        }
    }

    // 循环因 break 退出，说明 fast === slow，需要判断这个相遇点是不是1
    return fast === 1;
}

console.log(getHappyNum(19)); // 输出: true
console.log(getHappyNum(2));  // 输出: false
```

思路2：哈希法

1. 用哈希集合（如 JS 的 Set）记录每次计算出的 “数字平方和”。
2. 循环计算当前数的平方和，每次先查集合：若平方和已存在，说明进入循环（永远到不了 1），返回 false；若平方和是 1，返回 true。
3. 若都不满足，将当前平方和存入集合，继续下一轮计算。

```js
function isHappy(n) {
    const getNext = (num) => {
        let sum = 0;
        while (num > 0) {
            const digit = num % 10;
            sum += digit * digit;
            num = Math.floor(num / 10);
        }
        return sum;
    };

    const seen = new Set(); // 用 Set 存储出现过的平方和（对应 unordered_set）
    let current = getNext(n);

    while (current !== 1 && !seen.has(current)) {
        seen.add(current); // 记录当前平方和
        current = getNext(current); // 计算下一个平方和
    }

    return current === 1; // 若 current 是 1 则是快乐数，否则是循环
}

console.log(isHappy(19)); // true
console.log(isHappy(2)); // false
```

###  两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

最直观的暴力解法是遍历数组中所有两两组合，但其时间复杂度为 O (n²)。使用哈希表可以将时间复杂度优化到 O (n)。

哈希表核心思路：

1. 创建一个空的哈希表（`Map`），用于存储已经遍历过的数字及其对应的下标 `{数值: 下标}`。
2. 遍历数组 `nums` 中的每一个数字 `num`。
3. 在遍历时，计算目标值与当前数字的差值 `complement = target - num`。
4. 检查哈希表中是否存在 `complement`：
   - **如果存在**：说明我们找到了配对的两个数。`complement` 就是之前遍历过的某个数字，它的下标已经存储在哈希表中。当前数字 `num` 的下标是 `i`。直接返回这两个数的下标 `[map.get(complement), i]`。
   - **如果不存在**：将当前数字 `num` 和它的下标 `i` 存入哈希表中，以便后续的数字进行配对查找。
5. 由于题目保证每种输入只会对应一个答案，所以循环一定会找到并返回结果。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function twoSum(nums, target) {
    // 创建一个 Map 来存储数字和它们的索引
    const map = new Map();

    // 遍历数组
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i];
        // 计算需要配对的另一个数
        const complement = target - num;

        // 检查 complement 是否已经在 Map 中
        if (map.has(complement)) {
            // 如果存在，则找到了答案，返回两个数的索引
            return [map.get(complement), i];
        }

        // 如果不存在，将当前数和其索引存入 Map
        map.set(num, i);
    }

    // 根据题目描述，这里实际上是不可达的
    return [];
}

// 示例测试
const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(nums, target)); // 输出: [0, 1]
```

### 四数相加II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

例如:

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:2

解释:

两个元组如下:

1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

这个问题可以通过**哈希表（空间换时间）** 优化，将时间复杂度从暴力的 O (N⁴) 降低到 O (N²)，核心思路是 “分组求和 + 哈希表统计”。

方法思路：

1. **分组拆分**：把四个数组分成两组（A+B 和 C+D），分别计算两组中所有元素对的和，这样原问题就转化为 “寻找 A+B 中某个和与 C+D 中某个和相加等于 0” 的问题。
2. **哈希表统计**：用哈希表（JavaScript 中用 `Map`）存储 A+B 中所有和的出现次数（key 是和，value 是该和出现的次数）。
3. **匹配计算**：遍历 C+D 中所有和，计算其 “补数”（即 `0 - 当前和`），如果补数在哈希表中存在，说明存在对应的 A+B 和，两者相加为 0，此时将哈希表中补数的出现次数累加到结果中。

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
function fourSumCount(A, B, C, D) {
    const sumAB = new Map(); // 存储 A+B 的和及其出现次数
    let count = 0;

    // 第一步：计算 A+B 所有可能的和，存入 sumAB
    for (const a of A) {
        for (const b of B) {
            const sum = a + b;
            // 若 sum 已存在，次数加 1；否则初始化为 1
            sumAB.set(sum, (sumAB.get(sum) || 0) + 1);
        }
    }

    // 第二步：计算 C+D 所有可能的和，匹配 sumAB 中的补数
    for (const c of C) {
        for (const d of D) {
            const target = - (c + d); // 补数 = 0 - (C+D 的和)
            // 若补数存在于 sumAB，累加其出现次数
            if (sumAB.has(target)) {
                count += sumAB.get(target);
            }
        }
    }

    return count;
}

// 示例测试
const A = [1, 2];
const B = [-2, -1];
const C = [-1, 2];
const D = [0, 2];
console.log(fourSumCount(A, B, C, D)); // 输出: 2（对应元组 (0,0,0,1) 和 (1,1,0,1)）
```

### 赎金信

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true

方法思路

1. 统计杂志字符频率：用一个长度为 26 的数组（对应 26 个小写字母）记录杂志中每个字符出现的次数（数组索引对应字符的 ASCII 码偏移，如 `a` 对应索引 0，`b` 对应索引 1，以此类推）。
2. 检查赎金信字符：遍历赎金信中的每个字符，在频率数组中找到对应的索引，将该索引的计数减 1。如果计数减到负数，说明杂志中该字符的数量不足，直接返回 `false`。
3. 验证完成：如果赎金信遍历完毕，且所有字符的计数都未出现负数，说明杂志可以构成赎金信，返回 `true`。

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
function canConstruct(ransomNote, magazine) {
    // 初始化一个长度为 26 的数组，用于存储每个小写字母的出现次数
    const charCount = new Array(26).fill(0);

    // 1. 统计杂志字符串中每个字符的出现次数
    for (const char of magazine) {
        // 计算字符对应的数组索引（'a' -> 0, 'b' -> 1, ..., 'z' -> 25）
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
        charCount[index]++;
    }

    // 2. 检查赎金信中的每个字符是否能从杂志中获取
    for (const char of ransomNote) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
        // 如果杂志中该字符的数量已为 0，说明不足，返回 false
        if (charCount[index] === 0) {
            return false;
        }
        // 否则，将该字符的计数减 1（表示使用了一次）
        charCount[index]--;
    }

    // 3. 所有字符都检查通过，返回 true
    return true;
}

// 示例测试
console.log(canConstruct("a", "b")); // false
console.log(canConstruct("aa", "ab")); // false
console.log(canConstruct("aa", "aab")); // true
```

### 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

这个问题的核心难点在于 **如何高效地找到所有组合** 并且 **避免重复的三元组**。

方法思路：

最常用且最高效的解法是 **排序 + 双指针** 策略，这种方法可以将时间复杂度从暴力解法的 O (N³) 降低到 O (N²)。

思路分解：

1. **排序**：首先对数组进行排序。排序的好处是：
   - 方便我们使用双指针法来寻找满足条件的两个数。
   - 便于跳过重复的元素，从而避免重复的三元组。
2. **遍历 + 双指针**：
   - 我们固定一个数 `nums[i]` 作为三元组的第一个数。
   - 然后，使用两个指针，`left` 指针指向 `i+1`，`right` 指针指向数组的末尾。
   - 计算 `sum = nums[i] + nums[left] + nums[right]`。
   - - 如果 `sum === 0`：我们找到了一个有效的三元组，将其加入结果列表。然后，需要**跳过 `left` 和 `right` 指针指向的重复元素**，以防出现重复的三元组。之后，同时移动 `left` 和 `right` 指针。
   - - 如果 `sum < 0`：说明需要更大的数来接近 0，因此移动 `left` 指针向右。
   - - 如果 `sum > 0`：说明需要更小的数来接近 0，因此移动 `right` 指针向左。
3. **跳过重复元素**：
   - 在固定第一个数 `nums[i]` 时，如果 `nums[i]` 和 `nums[i-1]` 相同，我们应该跳过当前的 `i`，以避免重复的三元组。
   - 在找到一个有效三元组后，`left` 指针需要跳过所有与 `nums[left]` 相同的元素，`right` 指针需要跳过所有与 `nums[right]` 相同的元素。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function threeSum(nums) {
    const result = [];
    const n = nums.length;

    // 1. 先对数组进行排序
    nums.sort((a, b) => a - b);

    // 2. 遍历数组，固定第一个数
    for (let i = 0; i < n; i++) {
        // 如果当前数大于0，后面的数都比它大，三数之和不可能为0
        if (nums[i] > 0) {
            break;
        }

        // 跳过与前一个数相同的数，避免重复三元组
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }

        // 3. 初始化双指针
        let left = i + 1;
        let right = n - 1;

        // 4. 双指针遍历
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];

            if (sum === 0) {
                // 找到了一个有效的三元组
                result.push([nums[i], nums[left], nums[right]]);

                // 跳过 left 指针指向的重复元素
                while (left < right && nums[left] === nums[left + 1]) {
                    left++;
                }
                // 跳过 right 指针指向的重复元素
                while (left < right && nums[right] === nums[right - 1]) {
                    right--;
                }

                // 移动双指针，寻找下一个可能的组合
                left++;
                right--;
            } else if (sum < 0) {
                // 和太小，需要更大的数
                left++;
            } else {
                // 和太大，需要更小的数
                right--;
            }
        }
    }

    return result;
}

// 示例测试
const nums = [-1, 0, 1, 2, -1, -4];
console.log(threeSum(nums));
// 输出: [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```

### 四数之和

题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

方法思路：排序 + 两层循环 + 双指针

1. 排序：首先对数组进行排序。这有助于我们跳过重复元素，并高效地使用双指针。
2. 两层循环固定前两个数：
   - 外层循环固定第一个数 `nums[i]`。
   - 内层循环固定第二个数 `nums[j]`，其中 `j > i`。
3. 双指针寻找后两个数：
   - 初始化 `left` 指针为 `j + 1`，`right` 指针为数组末尾。
   - 计算当前四数之和 `sum = nums[i] + nums[j] + nums[left] + nums[right]`。
   - - 如果 `sum === target`：找到一个有效四元组，加入结果列表。然后跳过 `left` 和 `right` 指针指向的重复元素。
   - - 如果 `sum < target`：需要更大的数，移动 `left` 指针向右。
   - - 如果 `sum > target`：需要更小的数，移动 `right` 指针向左。
4. 跳过重复元素：
   - 在固定 `nums[i]` 时，如果 `nums[i]` 与 `nums[i-1]` 相同，跳过。
   - 在固定 `nums[j]` 时，如果 `nums[j]` 与 `nums[j-1]` 相同，且 `j > i+1`，跳过。
   - 在找到有效四元组后，`left` 和 `right` 指针也需要跳过重复元素。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
function fourSum(nums, target) {
    const result = [];
    const n = nums.length;

    // 1. 排序
    nums.sort((a, b) => a - b);

    // 2. 外层循环，固定第一个数
    for (let i = 0; i < n - 3; i++) {
        // 跳过重复的第一个数
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }

        // 3. 内层循环，固定第二个数
        for (let j = i + 1; j < n - 2; j++) {
            // 跳过重复的第二个数
            if (j > i + 1 && nums[j] === nums[j - 1]) {
                continue;
            }

            // 4. 初始化双指针
            let left = j + 1;
            let right = n - 1;

            // 5. 双指针寻找后两个数
            while (left < right) {
                const sum = nums[i] + nums[j] + nums[left] + nums[right];

                if (sum === target) {
                    // 找到一个有效的四元组
                    result.push([nums[i], nums[j], nums[left], nums[right]]);

                    // 跳过 left 指针指向的重复元素
                    while (left < right && nums[left] === nums[left + 1]) {
                        left++;
                    }
                    // 跳过 right 指针指向的重复元素
                    while (left < right && nums[right] === nums[right - 1]) {
                        right--;
                    }

                    // 移动双指针
                    left++;
                    right--;
                } else if (sum < target) {
                    // 和太小，需要更大的数
                    left++;
                } else {
                    // 和太大，需要更小的数
                    right--;
                }
            }
        }
    }

    return result;
}

// 示例测试
const nums = [1, 0, -1, 0, -2, 2];
const target = 0;
console.log(fourSum(nums, target));
// 输出: [ [ -2, -1, 1, 2 ], [ -2, 0, 0, 2 ], [ -1, 0, 0, 1 ] ]
```

### 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 ：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

方法思路：双指针法

1. 初始化指针：定义两个指针，一个 `left` 指针指向数组的开头（索引为 0），另一个 `right` 指针指向数组的末尾（索引为 `arr.length - 1`）。
2. 交换元素：交换 `left` 和 `right` 指针指向的元素。
3. 移动指针：`left` 指针向右移动一位，`right` 指针向左移动一位。
4. 循环继续：重复步骤 2 和 3，直到 `left` 指针大于或等于 `right` 指针。此时，数组的前半部分和后半部分已经完成交换，整个数组被反转。

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
function reverseString(s) {
    // 初始化左指针在数组开头
    let left = 0;
    // 初始化右指针在数组结尾
    let right = s.length - 1;

    // 当左指针小于右指针时，继续交换
    while (left < right) {
        // 交换 left 和 right 指向的元素
        // 使用 ES6 的解构赋值语法，简洁明了
        [s[left], s[right]] = [s[right], s[left]];

        // 移动指针
        left++;
        right--;
    }
    
    // 题目要求原地修改，不需要返回任何值
}

// 示例测试
const s = ["h", "e", "l", "l", "o"];
reverseString(s);
console.log(s); // 输出: ["o", "l", "l", "e", "h"]
```

### 反转字符串II

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2
输出: "bacdfeg"

这个问题可以通过**遍历字符串并分段处理**来解决。核心思路是：**以 `2k` 为一个周期，在每个周期内，反转前 `k` 个字符**。

方法思路：

1. **将字符串转换为数组**：因为字符串在 JavaScript 中是不可变的，为了实现原地修改（虽然题目没严格要求，但转换为数组操作更方便），先将字符串转为字符数组。
2. **循环遍历数组**：循环的步长为 `2k`，即每次处理 `2k` 个字符。
3. 反转每个周期的前 `k` 个字符：
   - 对于每个周期，确定需要反转的起始索引 `start` 和结束索引 `end`（`end = start + k - 1`）。
   - 如果剩余字符不足 `k` 个（即 `end >= 数组长度`），则将结束索引设为数组最后一个元素的索引。
   - 使用双指针法反转 `start` 到 `end` 之间的字符。
4. **将数组转换回字符串**：处理完所有周期后，将字符数组转回字符串并返回。

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
function reverseStr(s, k) {
    // 将字符串转换为数组，方便修改
    const arr = s.split('');
    const n = arr.length;

    // 以 2k 为步长遍历数组
    for (let start = 0; start < n; start += 2 * k) {
        // 确定当前周期内需要反转的前 k 个字符的结束索引
        // 若剩余字符不足 k 个，则结束索引为数组末尾
        let end = Math.min(start + k - 1, n - 1);
        
        // 双指针法反转 start 到 end 之间的字符
        let left = start;
        let right = end;
        while (left < right) {
            [arr[left], arr[right]] = [arr[right], arr[left]];
            left++;
            right--;
        }
    }

    // 将数组转换回字符串并返回
    return arr.join('');
}

// 示例测试
const s = "abcdefg";
const k = 2;
console.log(reverseStr(s, k)); // 输出: "bacdfeg"
```

### 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

实现思路:

1. 统计数字个数：计算字符串中数字的数量，确定最终数组需要的总长度（原长度 + 数字个数 × 5，因为 "number" 比单个数字多 5 个字符）。
2. 创建目标数组：根据计算的总长度初始化数组，用于存储结果。
3. 从后往前填充：双指针从原字符串末尾和目标数组末尾开始，非数字直接复制，数字则反向填充 "number"，避免覆盖未处理的字符。

```js
function replaceNumber(s) {
    let count = 0;
    const len = s.length;
    // 统计数字个数
    for (let i = 0; i < len; i++) {
        if (!isNaN(Number(s[i]))) { // 判断是否为数字
            count++;
        }
    }
    // 计算新数组长度：原长度 + 每个数字额外增加的5个字符（"number"是6个字符，比原数字多5个）
    const newLen = len + count * 5;
    const arr = new Array(newLen); // 创建目标数组
    let i = len - 1; // 原字符串指针（从后往前）
    let j = newLen - 1; // 目标数组指针（从后往前）
    
    while (i >= 0) {
        const char = s[i];
        if (!isNaN(Number(char))) { // 遇到数字，填充"number"（反向填充）
            arr[j--] = 'r';
            arr[j--] = 'e';
            arr[j--] = 'b';
            arr[j--] = 'm';
            arr[j--] = 'u';
            arr[j--] = 'n';
        } else { // 非数字，直接复制
            arr[j--] = char;
        }
        i--;
    }
    return arr.join('');
}

// 输入输出处理
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.question('', (s) => {
    console.log(replaceNumber(s));
    rl.close();
});
```

### 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good  example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

解题思路:

1. 处理空格：先去除字符串首尾的多余空格，再将单词间的多个空格压缩为单个空格。
2. 翻转整个字符串：将处理后的字符串整体翻转。
3. 翻转每个单词：对整体翻转后的字符串，逐个翻转每个单词，最终得到结果。

```js
function reverseWords(s) {
    // 步骤1：处理空格（trim去除首尾空格，正则替换多个空格为单个）
    const trimmed = s.trim().replace(/\s+/g, ' ');
    // 转为数组便于操作
    const arr = trimmed.split('');
    const n = arr.length;

    // 辅助函数：翻转数组指定区间的元素
    function reverse(arr, left, right) {
        while (left < right) {
            [arr[left], arr[right]] = [arr[right], arr[left]];
            left++;
            right--;
        }
    }

    // 步骤2：翻转整个字符串
    reverse(arr, 0, n - 1);

    // 步骤3：翻转每个单词
    let start = 0; // 记录每个单词的起始索引
    for (let i = 0; i <= n; i++) {
        // 遇到空格或字符串末尾，说明找到一个单词的结束位置
        if (i === n || arr[i] === ' ') {
            reverse(arr, start, i - 1);
            start = i + 1; // 更新下一个单词的起始索引
        }
    }

    return arr.join('');
}

// 测试示例
console.log(reverseWords("the sky is blue")); // "blue is sky the"
console.log(reverseWords("  hello world!  ")); // "world! hello"
console.log(reverseWords("a good  example")); // "example good a"
```

