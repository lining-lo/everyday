## 算法总结

### 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        // 计算中间索引（避免溢出：等同于 Math.floor((left + right) / 2)）
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid; // 找到目标，返回下标
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标在右半部分
        } else {
            right = mid - 1; // 目标在左半部分
        }
    }
    
    return -1; // 未找到目标
}
```

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

双指针法思路

1. 定义两个指针：
   - `fast` 指针：遍历整个数组，用于寻找不等于 `val` 的元素。
   - `slow` 指针：指向当前需要填充新元素的位置（即新数组的末尾）。
2. 遍历过程：
   - 当 `fast` 指向的元素不等于 `val` 时，将该元素复制到 `slow` 指向的位置，然后 `slow` 向前移动一步（新数组长度 + 1）。
   - 当 `fast` 指向的元素等于 `val` 时，`fast` 直接跳过（不处理）。
3. **结束条件**：`fast` 遍历完整个数组后，`slow` 的值就是新数组的长度。

```js
function removeElement(nums, val) {
    let slow = 0; // 慢指针：记录新数组的长度，指向待填充位置
    for (let fast = 0; fast < nums.length; fast++) {
        // 当快指针找到不等于val的元素时，复制到慢指针位置
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++; // 慢指针前移，更新新数组长度
        }
    }
    return slow; // 慢指针的值就是新数组的长度
}
```

### 有序数组的平方

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

关键思路

原数组是**非递减排序**的，但平方后可能出现 “两边大、中间小” 的情况（因为负数平方后可能比正数大，例如 `[-4, -1, 2, 3]` 平方后为 `[16, 1, 4, 9]`）。因此，可采用**双指针法**从两端向中间遍历，比较两端元素的平方大小，将较大的平方值从新数组的末尾开始填充，最终得到有序结果。

双指针法实现步骤

1. 初始化左指针 `left` 指向数组起点（0），右指针 `right` 指向数组终点（`nums.length - 1`）。
2. 创建结果数组 `result`，长度与原数组相同，初始化索引 `index` 为 `nums.length - 1`（从末尾开始填充）。
3. 比较 `nums[left]` 和 `nums[right]` 的平方:
   - 若 `left` 指向元素的平方更大，将其放入 `result[index]`，并右移 `left`。
   - 否则，将 `right` 指向元素的平方放入 `result[index]`，并左移 `right`。
4. 递减 `index`，重复步骤 3，直到 `left` 超过 `right`。

```javascript
function sortedSquares(nums) {
    const n = nums.length;
    const result = new Array(n); // 结果数组
    let left = 0;
    let right = n - 1;
    let index = n - 1; // 从结果数组末尾开始填充

    while (left <= right) {
        const leftSquare = nums[left] * nums[left];
        const rightSquare = nums[right] * nums[right];

        if (leftSquare > rightSquare) {
            result[index] = leftSquare;
            left++; // 左指针右移
        } else {
            result[index] = rightSquare;
            right--; // 右指针左移
        }
        index--; // 结果数组索引左移
    }

    return result;
}
```

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

暴力破解的核心逻辑

1. 外层循环 `i` 定义子数组的起点（从 0 到 n-1）。
2. 内层循环 `j` 从起点 `i` 开始，逐步扩展子数组的终点，同时累加子数组的和。
3. 当子数组的和 `currentSum` 大于等于 `s` 时，计算当前子数组的长度（`j - i + 1`），并与已知的最小长度比较更新。
4. 找到符合条件的子数组后，通过 `break` 退出内层循环（因为继续扩展会使子数组更长，无需考虑）。
5. 遍历结束后，如果始终没有找到符合条件的子数组（`minLength` 仍为 `Infinity`），返回 0，否则返回最小长度。

```js
function minSubArrayLen(s, nums) {
    const n = nums.length;
    let minLength = Infinity; // 初始化最小长度为无穷大

    // 外层循环：遍历所有可能的子数组起点
    for (let i = 0; i < n; i++) {
        let currentSum = 0; // 记录当前子数组的和
        
        // 内层循环：从起点i开始，扩展子数组的终点
        for (let j = i; j < n; j++) {
            currentSum += nums[j]; // 累加当前元素到子数组和中
            
            // 一旦子数组和大于等于s，更新最小长度
            if (currentSum >= s) {
                const currentLength = j - i + 1;
                minLength = Math.min(minLength, currentLength);
                break; // 找到当前起点的最短子数组，无需继续扩展
            }
        }
    }

    // 如果未找到符合条件的子数组，返回0，否则返回最小长度
    return minLength === Infinity ? 0 : minLength;
}
    
```

要解决这个问题，最高效的方法是使用**滑动窗口**（双指针）技术，时间复杂度可以优化到 O (n)，比暴力解法（O (n²)）更高效。

滑动窗口思路

1. 定义两个指针 `left` 和 `right`，分别表示窗口的左右边界，初始都为 0。
2. 移动 `right` 指针扩大窗口，累加元素和 `sum`。
3. 当 `sum >= s` 时，尝试移动 `left` 指针缩小窗口，同时更新最小长度。
4. 重复步骤 2-3，直到 `right` 遍历完整个数组。

```js
function minSubArrayLen(s, nums) {
    let left = 0; // 窗口左边界
    let sum = 0; // 当前窗口的和
    let minLen = Infinity; // 最小子数组长度

    // 移动右边界，扩大窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];

        // 当窗口和 >= s 时，尝试缩小左边界
        while (sum >= s) {
            // 计算当前窗口长度并更新最小值
            const currentLen = right - left + 1;
            minLen = Math.min(minLen, currentLen);
            
            // 移动左边界，缩小窗口
            sum -= nums[left];
            left++;
        }
    }

    // 如果没找到符合条件的子数组，返回 0
    return minLen === Infinity ? 0 : minLen;
}
    
```

### 螺旋矩阵II

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

要解决这个问题，我们需要生成一个包含 1 到 n² 所有元素的正方形矩阵，且元素按顺时针螺旋排列。核心思路是**模拟顺时针螺旋的填充过程**，通过控制边界逐步缩小填充范围。

解题步骤

1. **初始化矩阵**：创建一个 n×n 的空矩阵，用于存放结果。
2. **定义边界**：设定上、下、左、右四个边界，初始分别为矩阵的顶部（0）、底部（n-1）、左侧（0）、右侧（n-1）。
3. **顺时针填充**：按照 “从左到右→从上到下→从右到左→从下到上” 的顺序循环填充，每完成一轮方向填充就缩小对应边界，直到所有元素（1 到 n²）都被填充完毕。

代码实现

```js
function generateMatrix(n) {
    // 初始化 n×n 的二维数组，填充 0
    const res = new Array(n).fill(0).map(item => new Array(n).fill(0))
    let startx = 0, starty = 0; // 每圈的起始位置
    let loop = Math.floor(n / 2); // 循环的圈数（n为奇数时，中心单独处理）
    const mid = Math.floor(n / 2); // 中心位置索引
    let count = 1; // 填充的数字，从1开始
    let offset = 1; // 每圈边界收缩量
    let i, j;

    while (loop--) {
        i = startx;
        j = starty;

        // 1. 上行：从左到右（左闭右开）
        for (j; j < n - offset; j++) {
            res[i][j] = count++;
        }

        // 2. 右列：从上到下（左闭右开）
        for (i; i < n - offset; i++) {
            res[i][j] = count++;
        }

        // 3. 下行：从右到左（左闭右开）
        for (; j > starty; j--) {
            res[i][j] = count++;
        }

        // 4. 左列：从下到上（左闭右开）
        for (; i > startx; i--) {
            res[i][j] = count++;
        }

        // 下一圈的起始位置内移
        startx++;
        starty++;

        // 边界收缩量增加
        offset++;
    }

    // 如果n是奇数，填充中心元素
    if (n % 2 !== 0) {
        res[mid][mid] = count;
    }

    return res;
}

// 测试示例
console.log(generateMatrix(3)); 
// 输出: [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ]
```

### 区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```js
5
1
2
3
4
5
0 1
1 3
```

输出示例

```js
3
9
```

暴力破解的核心思路

1. 读取数组长度和元素，存储为数组 `array`。

2. 对每个输入的区间[l, r]

   （假设 0 开始索引，左闭右闭）：

   - 从索引 `l` 遍历到 `r`，累加每个元素的值。
   - 输出累加结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组

rl.on('line', (line) => {
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 读取数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，切换到读取区间模式
      if (array.length === n) {
        isReadingArray = false;
      }
    }
  } else {
    // 处理区间请求：暴力遍历求和
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    let sum = 0;
    // 从 l 遍历到 r，累加元素
    for (let i = l; i <= r; i++) {
      sum += array[i];
    }
    console.log(sum);
  }
});
```

使用前缀和的解题思路

1. 读取数组长度与元素：先获取数组长度 `n`，再读取 `n` 个整数构建原数组。
2. 构建前缀和数组：前缀和数组 `prefix` 中，`prefix[i]` 表示原数组前 `i` 个元素的和（`prefix[0] = 0`，`prefix[1] = 原数组[0]`，以此类推）。通过前缀和可快速计算任意区间 `[l, r]` 的和：`sum = prefix[r+1] - prefix[l]`（假设区间从 0 开始索引）。
3. 处理区间请求：持续读取输入的区间（每行两个整数，代表区间的起始和结束索引），利用前缀和数组计算并输出每个区间的和，直至输入结束。

```js
const readline = require('readline');

// 创建读取输入的接口
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组阶段
let prefix = []; // 前缀和数组

// 处理每一行输入
rl.on('line', (line) => {
  // 去除行首尾空格，避免空输入干扰
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 第一行输入：数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 后续 n 行：读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，构建前缀和数组
      if (array.length === n) {
        isReadingArray = false;
        // 构建前缀和：prefix[0] = 0，prefix[1] = array[0]，prefix[2] = array[0]+array[1]...
        prefix[0] = 0;
        for (let i = 0; i < n; i++) {
          prefix[i + 1] = prefix[i] + array[i];
        }
      }
    }
  } else {
    // 读取区间请求：每行两个整数，代表区间 [l, r]（0 开始索引，左闭右闭）
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    // 区间和 = 前缀和[r+1] - 前缀和[l]
    const sum = prefix[r + 1] - prefix[l];
    console.log(sum);
  }
});
```

### 开发商买地

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

要解决这个问题，我们需要将一个 `n×m` 的城市区块按横向或纵向划分为两部分，使两部分的土地总价值之差最小。核心思路是**枚举所有可能的划分方式，计算每种方式的价值差，最终选择最小值**。

解题步骤

1. 读取输入并解析网格：获取 `n`（行数）和 `m`（列数），以及每个区块的价值，构建二维数组。
2. 计算总价值：先求出所有区块的总价值 `sum`，方便后续计算两部分的差值。
3. 枚举横向划分：
   - 横向划分有 `n-1` 种可能（在第 `k` 行和第 `k+1` 行之间切分，`k` 从 1 到 `n-1`）。
   - 对每种划分，计算上半部分（前 `k` 行）的总价值 `s`，差值为 `|2s - sum|`（因为另一部分价值为 `sum - s`，差值简化为 `|s - (sum - s)|`）。
4. 枚举纵向划分：
   - 纵向划分有 `m-1` 种可能（在第 `k` 列和第 `k+1` 列之间切分，`k` 从 1 到 `m-1`）。
   - 对每种划分，计算左半部分（前 `k` 列）的总价值 `s`，差值同样为 `|2s - sum|`。
5. 找最小差值：从横向和纵向划分的所有差值中，选择最小的那个作为结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
  inputLines.push(line.trim());
}).on('close', () => {
  // 解析输入
  const [n, m] = inputLines[0].split(' ').map(Number);
  const grid = [];
  for (let i = 1; i <= n; i++) {
    grid.push(inputLines[i].split(' ').map(Number));
  }

  // 计算所有区块的总价值
  let totalSum = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      totalSum += grid[i][j];
    }
  }

  let minDiff = Infinity; // 初始化最小差值为无穷大

  // 1. 枚举横向划分（按行切分）
  let rowSum = 0; // 累计前k行的总价值
  for (let k = 0; k < n - 1; k++) { // 切分位置：第k行后（0-based），共n-1种
    // 累加第k行的价值到rowSum（前k+1行的总和）
    for (let j = 0; j < m; j++) {
      rowSum += grid[k][j];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * rowSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 2. 枚举纵向划分（按列切分）
  let colSum = 0; // 累计前k列的总价值
  for (let k = 0; k < m - 1; k++) { // 切分位置：第k列后（0-based），共m-1种
    // 累加第k列的价值到colSum（前k+1列的总和）
    for (let i = 0; i < n; i++) {
      colSum += grid[i][k];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * colSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 输出最小差值
  console.log(minDiff);
});
```

