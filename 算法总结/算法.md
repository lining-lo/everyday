## 算法总结

### 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        // 计算中间索引（避免溢出：等同于 Math.floor((left + right) / 2)）
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid; // 找到目标，返回下标
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标在右半部分
        } else {
            right = mid - 1; // 目标在左半部分
        }
    }
    
    return -1; // 未找到目标
}
```

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

双指针法思路

1. 定义两个指针：
   - `fast` 指针：遍历整个数组，用于寻找不等于 `val` 的元素。
   - `slow` 指针：指向当前需要填充新元素的位置（即新数组的末尾）。
2. 遍历过程：
   - 当 `fast` 指向的元素不等于 `val` 时，将该元素复制到 `slow` 指向的位置，然后 `slow` 向前移动一步（新数组长度 + 1）。
   - 当 `fast` 指向的元素等于 `val` 时，`fast` 直接跳过（不处理）。
3. **结束条件**：`fast` 遍历完整个数组后，`slow` 的值就是新数组的长度。

```js
function removeElement(nums, val) {
    let slow = 0; // 慢指针：记录新数组的长度，指向待填充位置
    for (let fast = 0; fast < nums.length; fast++) {
        // 当快指针找到不等于val的元素时，复制到慢指针位置
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++; // 慢指针前移，更新新数组长度
        }
    }
    return slow; // 慢指针的值就是新数组的长度
}
```

### 有序数组的平方

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

关键思路

原数组是**非递减排序**的，但平方后可能出现 “两边大、中间小” 的情况（因为负数平方后可能比正数大，例如 `[-4, -1, 2, 3]` 平方后为 `[16, 1, 4, 9]`）。因此，可采用**双指针法**从两端向中间遍历，比较两端元素的平方大小，将较大的平方值从新数组的末尾开始填充，最终得到有序结果。

双指针法实现步骤

1. 初始化左指针 `left` 指向数组起点（0），右指针 `right` 指向数组终点（`nums.length - 1`）。
2. 创建结果数组 `result`，长度与原数组相同，初始化索引 `index` 为 `nums.length - 1`（从末尾开始填充）。
3. 比较 `nums[left]` 和 `nums[right]` 的平方:
   - 若 `left` 指向元素的平方更大，将其放入 `result[index]`，并右移 `left`。
   - 否则，将 `right` 指向元素的平方放入 `result[index]`，并左移 `right`。
4. 递减 `index`，重复步骤 3，直到 `left` 超过 `right`。

```javascript
function sortedSquares(nums) {
    const n = nums.length;
    const result = new Array(n); // 结果数组
    let left = 0;
    let right = n - 1;
    let index = n - 1; // 从结果数组末尾开始填充

    while (left <= right) {
        const leftSquare = nums[left] * nums[left];
        const rightSquare = nums[right] * nums[right];

        if (leftSquare > rightSquare) {
            result[index] = leftSquare;
            left++; // 左指针右移
        } else {
            result[index] = rightSquare;
            right--; // 右指针左移
        }
        index--; // 结果数组索引左移
    }

    return result;
}
```

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

暴力破解的核心逻辑

1. 外层循环 `i` 定义子数组的起点（从 0 到 n-1）。
2. 内层循环 `j` 从起点 `i` 开始，逐步扩展子数组的终点，同时累加子数组的和。
3. 当子数组的和 `currentSum` 大于等于 `s` 时，计算当前子数组的长度（`j - i + 1`），并与已知的最小长度比较更新。
4. 找到符合条件的子数组后，通过 `break` 退出内层循环（因为继续扩展会使子数组更长，无需考虑）。
5. 遍历结束后，如果始终没有找到符合条件的子数组（`minLength` 仍为 `Infinity`），返回 0，否则返回最小长度。

```js
function minSubArrayLen(s, nums) {
    const n = nums.length;
    let minLength = Infinity; // 初始化最小长度为无穷大

    // 外层循环：遍历所有可能的子数组起点
    for (let i = 0; i < n; i++) {
        let currentSum = 0; // 记录当前子数组的和
        
        // 内层循环：从起点i开始，扩展子数组的终点
        for (let j = i; j < n; j++) {
            currentSum += nums[j]; // 累加当前元素到子数组和中
            
            // 一旦子数组和大于等于s，更新最小长度
            if (currentSum >= s) {
                const currentLength = j - i + 1;
                minLength = Math.min(minLength, currentLength);
                break; // 找到当前起点的最短子数组，无需继续扩展
            }
        }
    }

    // 如果未找到符合条件的子数组，返回0，否则返回最小长度
    return minLength === Infinity ? 0 : minLength;
}
    
```

要解决这个问题，最高效的方法是使用**滑动窗口**（双指针）技术，时间复杂度可以优化到 O (n)，比暴力解法（O (n²)）更高效。

滑动窗口思路

1. 定义两个指针 `left` 和 `right`，分别表示窗口的左右边界，初始都为 0。
2. 移动 `right` 指针扩大窗口，累加元素和 `sum`。
3. 当 `sum >= s` 时，尝试移动 `left` 指针缩小窗口，同时更新最小长度。
4. 重复步骤 2-3，直到 `right` 遍历完整个数组。

```js
function minSubArrayLen(s, nums) {
    let left = 0; // 窗口左边界
    let sum = 0; // 当前窗口的和
    let minLen = Infinity; // 最小子数组长度

    // 移动右边界，扩大窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];

        // 当窗口和 >= s 时，尝试缩小左边界
        while (sum >= s) {
            // 计算当前窗口长度并更新最小值
            const currentLen = right - left + 1;
            minLen = Math.min(minLen, currentLen);
            
            // 移动左边界，缩小窗口
            sum -= nums[left];
            left++;
        }
    }

    // 如果没找到符合条件的子数组，返回 0
    return minLen === Infinity ? 0 : minLen;
}
    
```

### 螺旋矩阵II

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

要解决这个问题，我们需要生成一个包含 1 到 n² 所有元素的正方形矩阵，且元素按顺时针螺旋排列。核心思路是**模拟顺时针螺旋的填充过程**，通过控制边界逐步缩小填充范围。

解题步骤

1. **初始化矩阵**：创建一个 n×n 的空矩阵，用于存放结果。
2. **定义边界**：设定上、下、左、右四个边界，初始分别为矩阵的顶部（0）、底部（n-1）、左侧（0）、右侧（n-1）。
3. **顺时针填充**：按照 “从左到右→从上到下→从右到左→从下到上” 的顺序循环填充，每完成一轮方向填充就缩小对应边界，直到所有元素（1 到 n²）都被填充完毕。

代码实现

```js
function generateMatrix(n) {
    // 初始化 n×n 的二维数组，填充 0
    const res = new Array(n).fill(0).map(item => new Array(n).fill(0))
    let startx = 0, starty = 0; // 每圈的起始位置
    let loop = Math.floor(n / 2); // 循环的圈数（n为奇数时，中心单独处理）
    const mid = Math.floor(n / 2); // 中心位置索引
    let count = 1; // 填充的数字，从1开始
    let offset = 1; // 每圈边界收缩量
    let i, j;

    while (loop--) {
        i = startx;
        j = starty;

        // 1. 上行：从左到右（左闭右开）
        for (j; j < n - offset; j++) {
            res[i][j] = count++;
        }

        // 2. 右列：从上到下（左闭右开）
        for (i; i < n - offset; i++) {
            res[i][j] = count++;
        }

        // 3. 下行：从右到左（左闭右开）
        for (; j > starty; j--) {
            res[i][j] = count++;
        }

        // 4. 左列：从下到上（左闭右开）
        for (; i > startx; i--) {
            res[i][j] = count++;
        }

        // 下一圈的起始位置内移
        startx++;
        starty++;

        // 边界收缩量增加
        offset++;
    }

    // 如果n是奇数，填充中心元素
    if (n % 2 !== 0) {
        res[mid][mid] = count;
    }

    return res;
}

// 测试示例
console.log(generateMatrix(3)); 
// 输出: [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ]
```

### 区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```js
5
1
2
3
4
5
0 1
1 3
```

输出示例

```js
3
9
```

暴力破解的核心思路

1. 读取数组长度和元素，存储为数组 `array`。

2. 对每个输入的区间[l, r]

   （假设 0 开始索引，左闭右闭）：

   - 从索引 `l` 遍历到 `r`，累加每个元素的值。
   - 输出累加结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组

rl.on('line', (line) => {
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 读取数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，切换到读取区间模式
      if (array.length === n) {
        isReadingArray = false;
      }
    }
  } else {
    // 处理区间请求：暴力遍历求和
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    let sum = 0;
    // 从 l 遍历到 r，累加元素
    for (let i = l; i <= r; i++) {
      sum += array[i];
    }
    console.log(sum);
  }
});
```

使用前缀和的解题思路

1. 读取数组长度与元素：先获取数组长度 `n`，再读取 `n` 个整数构建原数组。
2. 构建前缀和数组：前缀和数组 `prefix` 中，`prefix[i]` 表示原数组前 `i` 个元素的和（`prefix[0] = 0`，`prefix[1] = 原数组[0]`，以此类推）。通过前缀和可快速计算任意区间 `[l, r]` 的和：`sum = prefix[r+1] - prefix[l]`（假设区间从 0 开始索引）。
3. 处理区间请求：持续读取输入的区间（每行两个整数，代表区间的起始和结束索引），利用前缀和数组计算并输出每个区间的和，直至输入结束。

```js
const readline = require('readline');

// 创建读取输入的接口
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组阶段
let prefix = []; // 前缀和数组

// 处理每一行输入
rl.on('line', (line) => {
  // 去除行首尾空格，避免空输入干扰
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 第一行输入：数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 后续 n 行：读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，构建前缀和数组
      if (array.length === n) {
        isReadingArray = false;
        // 构建前缀和：prefix[0] = 0，prefix[1] = array[0]，prefix[2] = array[0]+array[1]...
        prefix[0] = 0;
        for (let i = 0; i < n; i++) {
          prefix[i + 1] = prefix[i] + array[i];
        }
      }
    }
  } else {
    // 读取区间请求：每行两个整数，代表区间 [l, r]（0 开始索引，左闭右闭）
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    // 区间和 = 前缀和[r+1] - 前缀和[l]
    const sum = prefix[r + 1] - prefix[l];
    console.log(sum);
  }
});
```

### 开发商买地

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

要解决这个问题，我们需要将一个 `n×m` 的城市区块按横向或纵向划分为两部分，使两部分的土地总价值之差最小。核心思路是**枚举所有可能的划分方式，计算每种方式的价值差，最终选择最小值**。

暴力解题步骤：

1. 读取输入并解析网格：获取 `n`（行数）和 `m`（列数），以及每个区块的价值，构建二维数组。
2. 计算总价值：先求出所有区块的总价值 `sum`，方便后续计算两部分的差值。
3. 枚举横向划分：
   - 横向划分有 `n-1` 种可能（在第 `k` 行和第 `k+1` 行之间切分，`k` 从 1 到 `n-1`）。
   - 对每种划分，计算上半部分（前 `k` 行）的总价值 `s`，差值为 `|2s - sum|`（因为另一部分价值为 `sum - s`，差值简化为 `|s - (sum - s)|`）。
4. 枚举纵向划分：
   - 纵向划分有 `m-1` 种可能（在第 `k` 列和第 `k+1` 列之间切分，`k` 从 1 到 `m-1`）。
   - 对每种划分，计算左半部分（前 `k` 列）的总价值 `s`，差值同样为 `|2s - sum|`。
5. 找最小差值：从横向和纵向划分的所有差值中，选择最小的那个作为结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
  inputLines.push(line.trim());
}).on('close', () => {
  // 解析输入
  const [n, m] = inputLines[0].split(' ').map(Number);
  const grid = [];
  for (let i = 1; i <= n; i++) {
    grid.push(inputLines[i].split(' ').map(Number));
  }

  // 计算所有区块的总价值
  let totalSum = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      totalSum += grid[i][j];
    }
  }

  let minDiff = Infinity; // 初始化最小差值为无穷大

  // 1. 枚举横向划分（按行切分）
  let rowSum = 0; // 累计前k行的总价值
  for (let k = 0; k < n - 1; k++) { // 切分位置：第k行后（0-based），共n-1种
    // 累加第k行的价值到rowSum（前k+1行的总和）
    for (let j = 0; j < m; j++) {
      rowSum += grid[k][j];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * rowSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 2. 枚举纵向划分（按列切分）
  let colSum = 0; // 累计前k列的总价值
  for (let k = 0; k < m - 1; k++) { // 切分位置：第k列后（0-based），共m-1种
    // 累加第k列的价值到colSum（前k+1列的总和）
    for (let i = 0; i < n; i++) {
      colSum += grid[i][k];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * colSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 输出最小差值
  console.log(minDiff);
});
```

用前缀和实现步骤：

1. 计算总行前缀和：`rowPrefix[i]` 表示前 `i` 行的总价值（用于横向分割时快速查询上部分价值）。
2. 计算总列前缀和：`colPrefix[j]` 表示前 `j` 列的总价值（用于纵向分割时快速查询左部分价值）。
3. 遍历所有横向 / 纵向分割线，利用前缀和直接计算两部分的价值差，取最小值。

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const readlineContent = [];
let grid = [];
let totalSum = 0;
let minDiff = Infinity;

rl.on('line', (line) => {
    const processLine = line.trim();
    if (processLine) readlineContent.push(processLine);
});

rl.on('close', () => {
    // 解析n和m
    const [n, m] = readlineContent[0].split(' ').map(Number);
    // 构建网格
    for (let i = 1; i <= n; i++) {
        grid.push(readlineContent[i].split(' ').map(Number));
    }

    // 1. 计算总行前缀和（用于横向分割）
    // rowPrefix[i] = 前i行的总价值（i从0到n，rowPrefix[0]=0，rowPrefix[1]=第0行总和，以此类推）
    const rowPrefix = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        // 第i-1行的总和（累加当前行的所有列）
        let rowSum = 0;
        for (let j = 0; j < m; j++) {
            rowSum += grid[i - 1][j];
        }
        rowPrefix[i] = rowPrefix[i - 1] + rowSum;
    }
    totalSum = rowPrefix[n]; // 总价值 = 前n行的总和

    // 2. 计算总列前缀和（用于纵向分割）
    // colPrefix[j] = 前j列的总价值（j从0到m，colPrefix[0]=0，colPrefix[1]=第0列总和，以此类推）
    const colPrefix = new Array(m + 1).fill(0);
    for (let j = 1; j <= m; j++) {
        // 第j-1列的总和（累加当前列的所有行）
        let colSum = 0;
        for (let i = 0; i < n; i++) {
            colSum += grid[i][j - 1];
        }
        colPrefix[j] = colPrefix[j - 1] + colSum;
    }

    // 3. 横向分割：遍历所有可能的分割线（第i行后，i从1到n-1）
    for (let i = 1; i < n; i++) {
        const upperSum = rowPrefix[i]; // 上部分 = 前i行的总和
        const lowerSum = totalSum - upperSum;
        const diff = Math.abs(upperSum - lowerSum);
        minDiff = Math.min(minDiff, diff);
    }

    // 4. 纵向分割：遍历所有可能的分割线（第j列后，j从1到m-1）
    for (let j = 1; j < m; j++) {
        const leftSum = colPrefix[j]; // 左部分 = 前j列的总和
        const rightSum = totalSum - leftSum;
        const diff = Math.abs(leftSum - rightSum);
        minDiff = Math.min(minDiff, diff);
    }

    console.log(minDiff);
});
```

### 移除链表元素

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

解题思路

1. 虚拟头节点：由于要删除的节点可能是原链表的头节点，引入虚拟头节点（`dummy`）可以避免单独处理头节点的特殊逻辑，其 `next` 指针指向原链表的头节点。
2. 遍历与删除使用指针 `current` 从虚拟头节点开始遍历，检查其下一个节点的值是否为 `val`：
   - 若为 `val`，则通过 `current.next = current.next.next` 跳过该节点（删除操作）。
   - 若不为 `val`，则将 `current` 后移一位，继续检查下一个节点。
3. 返回结果：遍历结束后，虚拟头节点的 `next` 指针即为删除后的新链表头节点。

```js
// 定义链表节点构造函数
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

// 删除链表中所有值为 val 的节点
var removeElements = function(head, val) {
    // 创建虚拟头节点，简化头节点删除逻辑
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let current = dummy; // 从虚拟头节点开始遍历
    
    // 遍历链表，检查当前节点的下一个节点是否需要删除
    while (current.next !== null) {
        if (current.next.val === val) {
            // 下一个节点需删除，跳过该节点
            current.next = current.next.next;
        } else {
            // 下一个节点无需删除，移动 current 指针
            current = current.next;
        }
    }
    
    // 返回删除后的链表头节点（虚拟头节点的 next）
    return dummy.next;
};
```

### 设计链表

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

示例：

```js
const linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);    //链表变为1-> 2-> 3
linkedList.get(1);             //返回2
linkedList.deleteAtIndex(1);   //现在链表是1-> 3
linkedList.get(1);             //返回3
```

实现

```js
class MyLinkedList {
  constructor() {
    // 虚拟头节点（简化边界处理）
    this.dummy = new ListNode(0);
    // 记录链表长度（方便快速判断索引有效性）
    this.size = 0;
  }

  /**
   * 获取链表中第 index 个节点的值
   * @param {number} index 目标索引
   * @return {number} 节点值（无效索引返回 -1）
   */
  get(index) {
    // 索引无效的情况（超出范围）
    if (index < 0 || index >= this.size) {
      return -1;
    }

    // 从虚拟头节点的下一个节点开始遍历
    let current = this.dummy.next;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    return current.val;
  }

  /**
   * 在链表头部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtHead(val) {
    // 创建新节点，next 指向原头节点
    const newNode = new ListNode(val, this.dummy.next);
    // 虚拟头节点指向新节点（更新头节点）
    this.dummy.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 在链表尾部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtTail(val) {
    // 遍历到最后一个节点
    let current = this.dummy;
    while (current.next !== null) {
      current = current.next;
    }
    // 在尾部添加新节点
    current.next = new ListNode(val);
    // 长度加 1
    this.size++;
  }

  /**
   * 在指定索引前添加节点
   * @param {number} index 目标索引
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtIndex(index, val) {
    // 索引大于长度时不插入
    if (index > this.size) {
      return;
    }
    // 索引小于 0 时，视为在头部插入
    if (index < 0) {
      index = 0;
    }

    // 找到要插入位置的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 创建新节点，插入到 current 后面
    const newNode = new ListNode(val, current.next);
    current.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 删除指定索引的节点
   * @param {number} index 目标索引
   * @return {void}
   */
  deleteAtIndex(index) {
    // 索引无效时不删除
    if (index < 0 || index >= this.size) {
      return;
    }

    // 找到要删除节点的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 跳过要删除的节点（完成删除）
    current.next = current.next.next;
    // 长度减 1
    this.size--;
  }
}

// 链表节点构造函数
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}
```

### 反转链表

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

方法 1：迭代法

通过三个指针（`prev`、`current`、`next`）逐步反转链表指针方向，原地完成反转。

```js
/**
 * 定义链表节点
 * @param {number} val 节点值
 * @param {ListNode} next 下一个节点
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 迭代法反转链表
 * @param {ListNode} head 链表头节点
 * @return {ListNode} 反转后的头节点
 */
function reverseList(head) {
  let prev = null; // 初始化前一个节点为 null（反转后尾节点的 next 是 null）
  let current = head; // 当前节点从 head 开始

  while (current !== null) {
    const next = current.next; // 先保存当前节点的下一个节点（防止丢失）
    current.next = prev; // 反转指针：当前节点指向前一个节点
    prev = current; // 前一个节点向后移动（当前节点成为新的前节点）
    current = next; // 当前节点向后移动（处理下一个节点）
  }

  // 循环结束后，prev 就是反转后的头节点（原尾节点）
  return prev;
}
```

步骤解析：以 `1->2->3->null` 为例：

1. 初始：`prev = null`，`current = 1`
2. 第一次循环：`next = 2` → `1.next = null` → `prev = 1` → `current = 2`
3. 第二次循环：`next = 3` → `2.next = 1` → `prev = 2` → `current = 3`
4. 第三次循环：`next = null` → `3.next = 2` → `prev = 3` → `current = null`
5. 结束，返回 `prev = 3`（反转后链表：`3->2->1->null`）

方法 2：递归法

利用递归栈回溯时反转指针，从链表尾部开始逐步反转。

```js
// 构建示例链表：1->2->3->4->5->null
const head = new ListNode(1, 
  new ListNode(2, 
    new ListNode(3, 
      new ListNode(4, 
        new ListNode(5)
      )
    )
  )
);

// 反转链表
const reversedHead = reverseList(head);

// 打印结果（5->4->3->2->1->null）
let current = reversedHead;
while (current !== null) {
  console.log(current.val); // 输出：5 4 3 2 1
  current = current.next;
}
```

### 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路解析

以链表 `1->2->3->4->null` 为例，目标是交换成 `2->1->4->3->null`。关键是：

1. 用**虚拟头节点**（dummy）简化边界处理（避免头节点变化的特殊判断）。
2. 每次处理一对节点（如 `1` 和 `2`），需要修改它们前后节点的指向。
3. 用指针跟踪当前待交换节点的前一个节点（`prev`），方便修改指向。

步骤拆解

1. 初始化虚拟头节点 `dummy`，让 `dummy.next = head`（指向原链表头）。
2. 定义 `prev` 指针，初始指向 `dummy`（`prev` 始终是待交换节点对的前一个节点）。
3. 循环条件：`prev.next` 和 `prev.next.next` 都存在（确保有两个节点可交换）。
4. 每次循环交换一对节点：
   - 标记第一个节点 `node1 = prev.next`（如 `1`）。
   - 标记第二个节点 `node2 = prev.next.next`（如 `2`）。
   - 交换指向：`prev.next = node2` → `node1.next = node2.next` → `node2.next = node1`。
   - 移动 `prev` 到交换后的第一个节点（如 `1`），准备处理下一对。

```js
/**
 * 定义链表节点
 * @param {number} val
 * @param {ListNode} next
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 两两交换链表中的节点
 * @param {ListNode} head
 * @return {ListNode}
 */
function swapPairs(head) {
  // 创建虚拟头节点，简化边界处理
  const dummy = new ListNode(0);
  dummy.next = head;
  // prev 指向待交换节点对的前一个节点（初始为 dummy）
  let prev = dummy;

  // 当存在至少两个节点可交换时，进入循环
  while (prev.next !== null && prev.next.next !== null) {
    // 标记待交换的两个节点
    const node1 = prev.next;       // 第一个节点（如 1）
    const node2 = prev.next.next;  // 第二个节点（如 2）

    // 交换节点指向
    prev.next = node2;      // prev 指向第二个节点（如 dummy->2）
    node1.next = node2.next; // 第一个节点指向第二个节点的下一个（如 1->3）
    node2.next = node1;      // 第二个节点指向第一个节点（如 2->1）

    // prev 移动到交换后的第一个节点（为下一次交换做准备）
    prev = node1;
  }

  // 返回虚拟头节点的下一个（新的头节点）
  return dummy.next;
}
```

### 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 ：

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

方法1：两次遍历

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0, head);
  let length = 0;
  let current = head;

  // 第一次遍历：计算链表长度
  while (current !== null) {
    length++;
    current = current.next;
  }

  // 找到倒数第n个节点的前一个节点（位置为 length - n）
  let prev = dummy;
  for (let i = 0; i < length - n; i++) {
    prev = prev.next;
  }

  // 删除节点
  prev.next = prev.next.next;

  return dummy.next;
}

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

方法二：快慢指针

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

var removeNthFromEnd = function(head, n) {
    // 1. 创建一个虚拟头节点，并将其指向链表的真正头节点
    const dummy = new ListNode(0);
    dummy.next = head;

    // 2. 初始化快慢指针，都指向虚拟头节点
    let fast = dummy;
    let slow = dummy;

    // 3. 快指针先向前移动 n+1 步
    // 这样当快指针到达末尾时，慢指针正好在倒数第 n+1 个节点上
    for (let i = 0; i <= n; i++) {
        fast = fast.next;
    }

    // 4. 快慢指针同时向前移动，直到快指针指向 null
    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 5. 此时 slow.next 就是要删除的倒数第 n 个节点
    // 将 slow 的 next 指针跳过要删除的节点
    slow.next = slow.next.next;

    // 6. 返回虚拟头节点的 next，即新的链表头
    return dummy.next;
};

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

### 链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。

思路：

1. **计算长度**：分别遍历两个链表，得到它们的长度 `lenA` 和 `lenB`。
2. 对齐指针：
   - 定义两个指针 `curA` 和 `curB`，分别指向两个链表的头节点。
   - 计算长度差 `diff = Math.abs(lenA - lenB)`。
   - 让较长链表的指针（比如 `curA`）先向前移动 `diff` 步。这样，`curA` 和 `curB` 就处在了同一个 “对齐” 的位置上，它们到各自链表末尾的距离是相等的。
3. 同步移动
4. 让 `curA` 和 `curB` 同时向前移动，直到它们相遇或者都到达链表末尾。
   - 如果相遇（`curA === curB`），则相遇点就是交点。
   - 如果都到达末尾（`curA === null` 且 `curB === null`），则没有交点。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    // 1. 计算两个链表的长度
    let lenA = 0, lenB = 0;
    let curA = headA, curB = headB;

    while (curA !== null) {
        lenA++;
        curA = curA.next;
    }
    while (curB !== null) {
        lenB++;
        curB = curB.next;
    }

    // 2. 重置指针，并让较长的链表指针先移动
    curA = headA;
    curB = headB;
    
    // 假设 lenA 更长，如果不是，则交换
    if (lenA < lenB) {
        [lenA, lenB] = [lenB, lenA];
        [curA, curB] = [curB, curA];
    }
    
    let diff = lenA - lenB;
    while (diff-- > 0) {
        curA = curA.next;
    }

    // 3. 同步移动，寻找交点
    while (curA !== null && curB !== null) {
        if (curA === curB) {
            return curA;
        }
        curA = curA.next;
        curB = curB.next;
    }

    // 4. 如果循环结束都没有相遇，则没有交点
    return null;
};
```

### 环形链表II

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

思路-快慢指针法：

1. **判断是否存在环**：使用一个慢指针 `slow` 和一个快指针 `fast`。`slow` 每次移动一步，`fast` 每次移动两步。如果链表中存在环，它们最终会在环内相遇。
2. **找到环的入口**：当 `slow` 和 `fast` 相遇后，我们再使用一个新的指针 `ptr`，让它从链表的头节点 `head` 开始，同时让 `slow` 指针继续从相遇点开始，两者都以每次一步的速度移动。它们最终会在**环的入口节点**相遇。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    // 阶段 1: 判断是否存在环，并找到相遇点
    let slow = head;
    let fast = head;
    let hasCycle = false;

    while (fast !== null && fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;

        if (slow === fast) {
            hasCycle = true;
            break;
        }
    }

    // 如果没有环，直接返回 null
    if (!hasCycle) {
        return null;
    }

    // 阶段 2: 找到环的入口节点
    let ptr = head;
    while (ptr !== slow) {
        ptr = ptr.next;
        slow = slow.next;
    }

    // ptr 和 slow 的相遇点就是环的入口
    return ptr;
};
```

### 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1: 输入: s = "anagram", t = "nagaram" 输出: true

示例 2: 输入: s = "rat", t = "car" 输出: false

说明: 你可以假设字符串只包含小写字母。

方法一：排序后比较:

1. 如果两个字符串长度不同，直接返回 `false`。
2. 将两个字符串分别拆分成字符数组，排序后再拼接成字符串。
3. 比较排序后的字符串是否相等。

```js
function isAnagram(s, t) {
    // 首先判断长度是否相同
    if (s.length !== t.length) return false;
    
    // 排序后比较
    const sortedS = s.split('').sort().join('');
    const sortedT = t.split('').sort().join('');
    
    return sortedS === sortedT;
}
```

哈希表计数:

1. 如果两个字符串长度不同，直接返回 `false`。
2. 用一个长度为 26 的数组 `count` 记录每个字母的出现次数（`count[0]` 对应 'a'，`count[1]` 对应 'b'，以此类推）。
3. 遍历字符串 `s`，统计每个字母的出现次数。
4. 遍历字符串 `t`，减去相应字母的出现次数。如果过程中出现负数，说明 `t` 中有 `s` 中没有的字符，直接返回 `false`。
5. 最后检查 `count` 数组是否所有元素都为 0。

```js
function isAnagram(s, t) {
    if (s.length !== t.length) return false;
    
    // 初始化一个长度为 26 的数组，用于记录每个字母的出现次数
    const count = new Array(26).fill(0);
    
    // 统计 s 中每个字母的出现次数
    for (let i = 0; i < s.length; i++) {
        const index = s.charCodeAt(i) - 'a'.charCodeAt(0);
        count[index]++;
    }
    
    // 减去 t 中每个字母的出现次数
    for (let i = 0; i < t.length; i++) {
        const index = t.charCodeAt(i) - 'a'.charCodeAt(0);
        count[index]--;
        
        // 如果出现负数，说明 t 中有 s 中没有的字符
        if (count[index] < 0) return false;
    }
    
    // 如果数组中所有元素都是 0，说明是字母异位词
    return true;
}
```

### 两个数组的交集

题意：给定两个数组，编写一个函数来计算它们的交集。

说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。

思路1：使用 Set 和 filter 

1. 将其中一个数组转换为 `Set`，以快速查找元素并自动去重。
2. 使用 `filter` 方法遍历另一个数组，检查其元素是否存在于第一步创建的 `Set` 中。
3. 将 `filter` 返回的结果数组再次转换为 `Set` 并转回数组，以确保结果中的元素是唯一的（虽然对于这个问题，步骤 2 的结果已经是唯一的，但这是一个好习惯）。

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
function intersection(nums1, nums2) {
    // 1. 将 nums1 转换为 Set，方便快速查找
    const set1 = new Set(nums1);
    
    // 2. 筛选出 nums2 中存在于 set1 的元素
    // 由于 Set 中的元素是唯一的，filter 的结果也自然是唯一的
    const intersectionArray = nums2.filter(num => set1.has(num));
    
    // 3. 再次转换为 Set 并转回数组，确保结果绝对唯一（此处可省略，但体现严谨性）
    return [...new Set(intersectionArray)];
}

// 更简洁的写法
function intersectionConcise(nums1, nums2) {
    return [...new Set(nums1)].filter(num => new Set(nums2).has(num));
}

// 示例
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
console.log(intersection(nums1, nums2)); // 输出: [2]

const nums3 = [4, 9, 5];
const nums4 = [9, 4, 9, 8, 4];
console.log(intersection(nums3, nums4)); // 输出: [4, 9] (或 [9, 4])
```

思路2：排序后使用双指针

1. 对两个数组进行排序。
2. 初始化两个指针 `i` 和 `j`，分别指向两个数组的开头。
3. 比较两个指针指向的元素：
   - 如果相等，说明找到一个交集元素。为了保证唯一性，需要检查结果数组的最后一个元素是否与当前元素相同，如果不同才加入。然后同时移动两个指针。
   - 如果 `nums1[i]` 小于 `nums2[j]`，移动 `i` 指针。
   - 否则，移动 `j` 指针。
4. 直到其中一个指针超出数组范围。

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
function intersectionWithTwoPointers(nums1, nums2) {
    // 1. 排序两个数组
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);
    
    const result = [];
    let i = 0, j = 0;
    
    // 2. 使用双指针遍历
    while (i < nums1.length && j < nums2.length) {
        if (nums1[i] === nums2[j]) {
            // 3. 找到交集元素，确保结果唯一
            if (result.length === 0 || result[result.length - 1] !== nums1[i]) {
                result.push(nums1[i]);
            }
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    
    return result;
}

// 示例
const nums1 = [1, 2, 2, 1];
const nums2 = [2, 2];
console.log(intersectionWithTwoPointers(nums1, nums2)); // 输出: [2]
```

### 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

示例：

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

思路1：快慢指针

1. 定义一个辅助函数 `getNext(n)`，用于计算一个数 `n` 的每个位置上数字的平方和。
2. 使用快慢指针：
   - `slow` 指针每次走一步，即计算 `getNext(slow)`。
   - `fast` 指针每次走两步，即计算 `getNext(getNext(fast))`。
3. 判断条件：
   - 如果 `fast` 指针先到达 1，说明 `n` 是快乐数，返回 `true`。
   - 如果 `slow` 指针和 `fast` 指针相遇（即进入循环），说明 `n` 不是快乐数，返回 `false`。

```js
function getHappyNum(n) {
    function getNext(n) {
        let sum = 0;
        while (n > 0) {
            let last = n % 10;
            sum += last * last;
            n = Math.floor(n / 10);
        }
        return sum;
    }

    let fast = n;
    let slow = n;

    // 使用无限循环，在内部判断退出条件
    while (true) {
        fast = getNext(getNext(fast));
        slow = getNext(slow);

        // 如果快指针追上慢指针，说明进入循环，不是快乐数
        if (fast === slow) {
            break;
        }
        // 如果快指针先到达1，说明是快乐数
        if (fast === 1) {
            return true;
        }
    }

    // 循环因 break 退出，说明 fast === slow，需要判断这个相遇点是不是1
    return fast === 1;
}

console.log(getHappyNum(19)); // 输出: true
console.log(getHappyNum(2));  // 输出: false
```

思路2：哈希法

1. 用哈希集合（如 JS 的 Set）记录每次计算出的 “数字平方和”。
2. 循环计算当前数的平方和，每次先查集合：若平方和已存在，说明进入循环（永远到不了 1），返回 false；若平方和是 1，返回 true。
3. 若都不满足，将当前平方和存入集合，继续下一轮计算。

```js
function isHappy(n) {
    const getNext = (num) => {
        let sum = 0;
        while (num > 0) {
            const digit = num % 10;
            sum += digit * digit;
            num = Math.floor(num / 10);
        }
        return sum;
    };

    const seen = new Set(); // 用 Set 存储出现过的平方和（对应 unordered_set）
    let current = getNext(n);

    while (current !== 1 && !seen.has(current)) {
        seen.add(current); // 记录当前平方和
        current = getNext(current); // 计算下一个平方和
    }

    return current === 1; // 若 current 是 1 则是快乐数，否则是循环
}

console.log(isHappy(19)); // true
console.log(isHappy(2)); // false
```

###  两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

最直观的暴力解法是遍历数组中所有两两组合，但其时间复杂度为 O (n²)。使用哈希表可以将时间复杂度优化到 O (n)。

哈希表核心思路：

1. 创建一个空的哈希表（`Map`），用于存储已经遍历过的数字及其对应的下标 `{数值: 下标}`。
2. 遍历数组 `nums` 中的每一个数字 `num`。
3. 在遍历时，计算目标值与当前数字的差值 `complement = target - num`。
4. 检查哈希表中是否存在 `complement`：
   - **如果存在**：说明我们找到了配对的两个数。`complement` 就是之前遍历过的某个数字，它的下标已经存储在哈希表中。当前数字 `num` 的下标是 `i`。直接返回这两个数的下标 `[map.get(complement), i]`。
   - **如果不存在**：将当前数字 `num` 和它的下标 `i` 存入哈希表中，以便后续的数字进行配对查找。
5. 由于题目保证每种输入只会对应一个答案，所以循环一定会找到并返回结果。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
function twoSum(nums, target) {
    // 创建一个 Map 来存储数字和它们的索引
    const map = new Map();

    // 遍历数组
    for (let i = 0; i < nums.length; i++) {
        const num = nums[i];
        // 计算需要配对的另一个数
        const complement = target - num;

        // 检查 complement 是否已经在 Map 中
        if (map.has(complement)) {
            // 如果存在，则找到了答案，返回两个数的索引
            return [map.get(complement), i];
        }

        // 如果不存在，将当前数和其索引存入 Map
        map.set(num, i);
    }

    // 根据题目描述，这里实际上是不可达的
    return [];
}

// 示例测试
const nums = [2, 7, 11, 15];
const target = 9;
console.log(twoSum(nums, target)); // 输出: [0, 1]
```

### 四数相加II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。

例如:

输入:

- A = [ 1, 2]
- B = [-2,-1]
- C = [-1, 2]
- D = [ 0, 2]

输出:2

解释:

两个元组如下:

1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

这个问题可以通过**哈希表（空间换时间）** 优化，将时间复杂度从暴力的 O (N⁴) 降低到 O (N²)，核心思路是 “分组求和 + 哈希表统计”。

方法思路：

1. **分组拆分**：把四个数组分成两组（A+B 和 C+D），分别计算两组中所有元素对的和，这样原问题就转化为 “寻找 A+B 中某个和与 C+D 中某个和相加等于 0” 的问题。
2. **哈希表统计**：用哈希表（JavaScript 中用 `Map`）存储 A+B 中所有和的出现次数（key 是和，value 是该和出现的次数）。
3. **匹配计算**：遍历 C+D 中所有和，计算其 “补数”（即 `0 - 当前和`），如果补数在哈希表中存在，说明存在对应的 A+B 和，两者相加为 0，此时将哈希表中补数的出现次数累加到结果中。

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @param {number[]} C
 * @param {number[]} D
 * @return {number}
 */
function fourSumCount(A, B, C, D) {
    const sumAB = new Map(); // 存储 A+B 的和及其出现次数
    let count = 0;

    // 第一步：计算 A+B 所有可能的和，存入 sumAB
    for (const a of A) {
        for (const b of B) {
            const sum = a + b;
            // 若 sum 已存在，次数加 1；否则初始化为 1
            sumAB.set(sum, (sumAB.get(sum) || 0) + 1);
        }
    }

    // 第二步：计算 C+D 所有可能的和，匹配 sumAB 中的补数
    for (const c of C) {
        for (const d of D) {
            const target = - (c + d); // 补数 = 0 - (C+D 的和)
            // 若补数存在于 sumAB，累加其出现次数
            if (sumAB.has(target)) {
                count += sumAB.get(target);
            }
        }
    }

    return count;
}

// 示例测试
const A = [1, 2];
const B = [-2, -1];
const C = [-1, 2];
const D = [0, 2];
console.log(fourSumCount(A, B, C, D)); // 输出: 2（对应元组 (0,0,0,1) 和 (1,1,0,1)）
```

### 赎金信

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true

方法思路

1. 统计杂志字符频率：用一个长度为 26 的数组（对应 26 个小写字母）记录杂志中每个字符出现的次数（数组索引对应字符的 ASCII 码偏移，如 `a` 对应索引 0，`b` 对应索引 1，以此类推）。
2. 检查赎金信字符：遍历赎金信中的每个字符，在频率数组中找到对应的索引，将该索引的计数减 1。如果计数减到负数，说明杂志中该字符的数量不足，直接返回 `false`。
3. 验证完成：如果赎金信遍历完毕，且所有字符的计数都未出现负数，说明杂志可以构成赎金信，返回 `true`。

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
function canConstruct(ransomNote, magazine) {
    // 初始化一个长度为 26 的数组，用于存储每个小写字母的出现次数
    const charCount = new Array(26).fill(0);

    // 1. 统计杂志字符串中每个字符的出现次数
    for (const char of magazine) {
        // 计算字符对应的数组索引（'a' -> 0, 'b' -> 1, ..., 'z' -> 25）
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
        charCount[index]++;
    }

    // 2. 检查赎金信中的每个字符是否能从杂志中获取
    for (const char of ransomNote) {
        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);
        // 如果杂志中该字符的数量已为 0，说明不足，返回 false
        if (charCount[index] === 0) {
            return false;
        }
        // 否则，将该字符的计数减 1（表示使用了一次）
        charCount[index]--;
    }

    // 3. 所有字符都检查通过，返回 true
    return true;
}

// 示例测试
console.log(canConstruct("a", "b")); // false
console.log(canConstruct("aa", "ab")); // false
console.log(canConstruct("aa", "aab")); // true
```

### 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意： 答案中不可以包含重复的三元组。

示例：

给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

这个问题的核心难点在于 **如何高效地找到所有组合** 并且 **避免重复的三元组**。

方法思路：

最常用且最高效的解法是 **排序 + 双指针** 策略，这种方法可以将时间复杂度从暴力解法的 O (N³) 降低到 O (N²)。

思路分解：

1. **排序**：首先对数组进行排序。排序的好处是：
   - 方便我们使用双指针法来寻找满足条件的两个数。
   - 便于跳过重复的元素，从而避免重复的三元组。
2. **遍历 + 双指针**：
   - 我们固定一个数 `nums[i]` 作为三元组的第一个数。
   - 然后，使用两个指针，`left` 指针指向 `i+1`，`right` 指针指向数组的末尾。
   - 计算 `sum = nums[i] + nums[left] + nums[right]`。
   - - 如果 `sum === 0`：我们找到了一个有效的三元组，将其加入结果列表。然后，需要**跳过 `left` 和 `right` 指针指向的重复元素**，以防出现重复的三元组。之后，同时移动 `left` 和 `right` 指针。
   - - 如果 `sum < 0`：说明需要更大的数来接近 0，因此移动 `left` 指针向右。
   - - 如果 `sum > 0`：说明需要更小的数来接近 0，因此移动 `right` 指针向左。
3. **跳过重复元素**：
   - 在固定第一个数 `nums[i]` 时，如果 `nums[i]` 和 `nums[i-1]` 相同，我们应该跳过当前的 `i`，以避免重复的三元组。
   - 在找到一个有效三元组后，`left` 指针需要跳过所有与 `nums[left]` 相同的元素，`right` 指针需要跳过所有与 `nums[right]` 相同的元素。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function threeSum(nums) {
    const result = [];
    const n = nums.length;

    // 1. 先对数组进行排序
    nums.sort((a, b) => a - b);

    // 2. 遍历数组，固定第一个数
    for (let i = 0; i < n; i++) {
        // 如果当前数大于0，后面的数都比它大，三数之和不可能为0
        if (nums[i] > 0) {
            break;
        }

        // 跳过与前一个数相同的数，避免重复三元组
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }

        // 3. 初始化双指针
        let left = i + 1;
        let right = n - 1;

        // 4. 双指针遍历
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];

            if (sum === 0) {
                // 找到了一个有效的三元组
                result.push([nums[i], nums[left], nums[right]]);

                // 跳过 left 指针指向的重复元素
                while (left < right && nums[left] === nums[left + 1]) {
                    left++;
                }
                // 跳过 right 指针指向的重复元素
                while (left < right && nums[right] === nums[right - 1]) {
                    right--;
                }

                // 移动双指针，寻找下一个可能的组合
                left++;
                right--;
            } else if (sum < 0) {
                // 和太小，需要更大的数
                left++;
            } else {
                // 和太大，需要更小的数
                right--;
            }
        }
    }

    return result;
}

// 示例测试
const nums = [-1, 0, 1, 2, -1, -4];
console.log(threeSum(nums));
// 输出: [ [ -1, -1, 2 ], [ -1, 0, 1 ] ]
```

### 四数之和

题意：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ]

方法思路：排序 + 两层循环 + 双指针

1. 排序：首先对数组进行排序。这有助于我们跳过重复元素，并高效地使用双指针。
2. 两层循环固定前两个数：
   - 外层循环固定第一个数 `nums[i]`。
   - 内层循环固定第二个数 `nums[j]`，其中 `j > i`。
3. 双指针寻找后两个数：
   - 初始化 `left` 指针为 `j + 1`，`right` 指针为数组末尾。
   - 计算当前四数之和 `sum = nums[i] + nums[j] + nums[left] + nums[right]`。
   - - 如果 `sum === target`：找到一个有效四元组，加入结果列表。然后跳过 `left` 和 `right` 指针指向的重复元素。
   - - 如果 `sum < target`：需要更大的数，移动 `left` 指针向右。
   - - 如果 `sum > target`：需要更小的数，移动 `right` 指针向左。
4. 跳过重复元素：
   - 在固定 `nums[i]` 时，如果 `nums[i]` 与 `nums[i-1]` 相同，跳过。
   - 在固定 `nums[j]` 时，如果 `nums[j]` 与 `nums[j-1]` 相同，且 `j > i+1`，跳过。
   - 在找到有效四元组后，`left` 和 `right` 指针也需要跳过重复元素。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
function fourSum(nums, target) {
    const result = [];
    const n = nums.length;

    // 1. 排序
    nums.sort((a, b) => a - b);

    // 2. 外层循环，固定第一个数
    for (let i = 0; i < n - 3; i++) {
        // 跳过重复的第一个数
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }

        // 3. 内层循环，固定第二个数
        for (let j = i + 1; j < n - 2; j++) {
            // 跳过重复的第二个数
            if (j > i + 1 && nums[j] === nums[j - 1]) {
                continue;
            }

            // 4. 初始化双指针
            let left = j + 1;
            let right = n - 1;

            // 5. 双指针寻找后两个数
            while (left < right) {
                const sum = nums[i] + nums[j] + nums[left] + nums[right];

                if (sum === target) {
                    // 找到一个有效的四元组
                    result.push([nums[i], nums[j], nums[left], nums[right]]);

                    // 跳过 left 指针指向的重复元素
                    while (left < right && nums[left] === nums[left + 1]) {
                        left++;
                    }
                    // 跳过 right 指针指向的重复元素
                    while (left < right && nums[right] === nums[right - 1]) {
                        right--;
                    }

                    // 移动双指针
                    left++;
                    right--;
                } else if (sum < target) {
                    // 和太小，需要更大的数
                    left++;
                } else {
                    // 和太大，需要更小的数
                    right--;
                }
            }
        }
    }

    return result;
}

// 示例测试
const nums = [1, 0, -1, 0, -2, 2];
const target = 0;
console.log(fourSum(nums, target));
// 输出: [ [ -2, -1, 1, 2 ], [ -2, 0, 0, 2 ], [ -1, 0, 0, 1 ] ]
```

### 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 ：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

方法思路：双指针法

1. 初始化指针：定义两个指针，一个 `left` 指针指向数组的开头（索引为 0），另一个 `right` 指针指向数组的末尾（索引为 `arr.length - 1`）。
2. 交换元素：交换 `left` 和 `right` 指针指向的元素。
3. 移动指针：`left` 指针向右移动一位，`right` 指针向左移动一位。
4. 循环继续：重复步骤 2 和 3，直到 `left` 指针大于或等于 `right` 指针。此时，数组的前半部分和后半部分已经完成交换，整个数组被反转。

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
function reverseString(s) {
    // 初始化左指针在数组开头
    let left = 0;
    // 初始化右指针在数组结尾
    let right = s.length - 1;

    // 当左指针小于右指针时，继续交换
    while (left < right) {
        // 交换 left 和 right 指向的元素
        // 使用 ES6 的解构赋值语法，简洁明了
        [s[left], s[right]] = [s[right], s[left]];

        // 移动指针
        left++;
        right--;
    }
    
    // 题目要求原地修改，不需要返回任何值
}

// 示例测试
const s = ["h", "e", "l", "l", "o"];
reverseString(s);
console.log(s); // 输出: ["o", "l", "l", "e", "h"]
```

### 反转字符串II

给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

如果剩余字符少于 k 个，则将剩余字符全部反转。

如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

示例:

输入: s = "abcdefg", k = 2
输出: "bacdfeg"

这个问题可以通过**遍历字符串并分段处理**来解决。核心思路是：**以 `2k` 为一个周期，在每个周期内，反转前 `k` 个字符**。

方法思路：

1. **将字符串转换为数组**：因为字符串在 JavaScript 中是不可变的，为了实现原地修改（虽然题目没严格要求，但转换为数组操作更方便），先将字符串转为字符数组。
2. **循环遍历数组**：循环的步长为 `2k`，即每次处理 `2k` 个字符。
3. 反转每个周期的前 `k` 个字符：
   - 对于每个周期，确定需要反转的起始索引 `start` 和结束索引 `end`（`end = start + k - 1`）。
   - 如果剩余字符不足 `k` 个（即 `end >= 数组长度`），则将结束索引设为数组最后一个元素的索引。
   - 使用双指针法反转 `start` 到 `end` 之间的字符。
4. **将数组转换回字符串**：处理完所有周期后，将字符数组转回字符串并返回。

```js
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
function reverseStr(s, k) {
    // 将字符串转换为数组，方便修改
    const arr = s.split('');
    const n = arr.length;

    // 以 2k 为步长遍历数组
    for (let start = 0; start < n; start += 2 * k) {
        // 确定当前周期内需要反转的前 k 个字符的结束索引
        // 若剩余字符不足 k 个，则结束索引为数组末尾
        let end = Math.min(start + k - 1, n - 1);
        
        // 双指针法反转 start 到 end 之间的字符
        let left = start;
        let right = end;
        while (left < right) {
            [arr[left], arr[right]] = [arr[right], arr[left]];
            left++;
            right--;
        }
    }

    // 将数组转换回字符串并返回
    return arr.join('');
}

// 示例测试
const s = "abcdefg";
const k = 2;
console.log(reverseStr(s, k)); // 输出: "bacdfeg"
```

### 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

实现思路:

1. 统计数字个数：计算字符串中数字的数量，确定最终数组需要的总长度（原长度 + 数字个数 × 5，因为 "number" 比单个数字多 5 个字符）。
2. 创建目标数组：根据计算的总长度初始化数组，用于存储结果。
3. 从后往前填充：双指针从原字符串末尾和目标数组末尾开始，非数字直接复制，数字则反向填充 "number"，避免覆盖未处理的字符。

```js
function replaceNumber(s) {
    let count = 0;
    const len = s.length;
    // 统计数字个数
    for (let i = 0; i < len; i++) {
        if (!isNaN(Number(s[i]))) { // 判断是否为数字
            count++;
        }
    }
    // 计算新数组长度：原长度 + 每个数字额外增加的5个字符（"number"是6个字符，比原数字多5个）
    const newLen = len + count * 5;
    const arr = new Array(newLen); // 创建目标数组
    let i = len - 1; // 原字符串指针（从后往前）
    let j = newLen - 1; // 目标数组指针（从后往前）
    
    while (i >= 0) {
        const char = s[i];
        if (!isNaN(Number(char))) { // 遇到数字，填充"number"（反向填充）
            arr[j--] = 'r';
            arr[j--] = 'e';
            arr[j--] = 'b';
            arr[j--] = 'm';
            arr[j--] = 'u';
            arr[j--] = 'n';
        } else { // 非数字，直接复制
            arr[j--] = char;
        }
        i--;
    }
    return arr.join('');
}

// 输入输出处理
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
rl.question('', (s) => {
    console.log(replaceNumber(s));
    rl.close();
});
```

### 翻转字符串里的单词

给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good  example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

解题思路:

1. 处理空格：先去除字符串首尾的多余空格，再将单词间的多个空格压缩为单个空格。
2. 翻转整个字符串：将处理后的字符串整体翻转。
3. 翻转每个单词：对整体翻转后的字符串，逐个翻转每个单词，最终得到结果。

```js
function reverseWords(s) {
    // 步骤1：处理空格（trim去除首尾空格，正则替换多个空格为单个）
    const trimmed = s.trim().replace(/\s+/g, ' ');
    // 转为数组便于操作
    const arr = trimmed.split('');
    const n = arr.length;

    // 辅助函数：翻转数组指定区间的元素
    function reverse(arr, left, right) {
        while (left < right) {
            [arr[left], arr[right]] = [arr[right], arr[left]];
            left++;
            right--;
        }
    }

    // 步骤2：翻转整个字符串
    reverse(arr, 0, n - 1);

    // 步骤3：翻转每个单词
    let start = 0; // 记录每个单词的起始索引
    for (let i = 0; i <= n; i++) {
        // 遇到空格或字符串末尾，说明找到一个单词的结束位置
        if (i === n || arr[i] === ' ') {
            reverse(arr, start, i - 1);
            start = i + 1; // 更新下一个单词的起始索引
        }
    }

    return arr.join('');
}

// 测试示例
console.log(reverseWords("the sky is blue")); // "blue is sky the"
console.log(reverseWords("  hello world!  ")); // "world! hello"
console.log(reverseWords("a good  example")); // "example good a"
```

### 右旋字符串

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

输出：输出共一行，为进行了右旋转操作后的字符串。

样例输入：

```text
2
abcdefg 
```

样例输出：

```text
fgabcde
```

解题思路：

1. **处理 `k` 可能大于字符串长度的情况**：当 `k` 大于字符串长度 `n` 时，实际右旋转 `k % n` 次与旋转 `k` 次效果相同（例如字符串长度为 7，旋转 9 次等价于旋转 2 次）。
2. **截取字符串**：
   - 尾部 `k` 个字符：从索引 `n - k` 截取到末尾。
   - 剩余前面的字符：从索引 `0` 截取到 `n - k`。
   - 将两部分拼接，即为旋转右旋转后的结果。

```js
// 读取输入
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];
rl.on('line', (line) => {
    input.push(line);
    if (input.length === 2) {
        const k = parseInt(input[0]);
        const s = input[1];
        const n = s.length;
        // 处理 k 大于字符串长度的情况
        const rotateK = k % n;
        // 截取尾部 k 个字符 + 前面剩余字符
        const result = s.slice(n - rotateK) + s.slice(0, n - rotateK);
        console.log(result);
        rl.close();
    }
});
```

为了让本题更有意义，提升一下本题难度：不能申请额外空间，只能在本串上操作。

核心原理

右旋转 `k` 位，等价于：

1. 翻转整个字符串
2. 翻转前 `k` 个字符
3. 翻转剩余的 `n - k` 个字符

例如：输入 `abcdefg`（n=7）、k=2

- 第一次翻转整个字符串 → `gfedcba`
- 第二次翻转前 2 个字符 → `fedcgba`
- 第三次翻转后 5 个字符 → `fgabcde`（最终结果）

```js
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// 辅助函数：原地翻转数组的 [left, right] 区间
function reverseArr(arr, left, right) {
    while (left < right) {
        // 交换元素（无额外空间消耗）
        [arr[left], arr[right]] = [arr[right], arr[left]];
        left++;
        right--;
    }
}

let input = [];
rl.on('line', (line) => {
    input.push(line);
    if (input.length === 2) {
        let k = parseInt(input[0]);
        const s = input[1];
        const n = s.length;
        
        // 处理 k 大于字符串长度的情况
        k = k % n;
        if (k === 0) { // 旋转 0 位直接输出原字符串
            console.log(s);
            rl.close();
            return;
        }
        
        // 字符串转数组（唯一的空间开销是数组本身，无额外辅助空间）
        const arr = s.split('');
        
        // 三次原地翻转
        reverseArr(arr, 0, n - 1); // 1. 翻转整个数组
        reverseArr(arr, 0, k - 1); // 2. 翻转前 k 个字符
        reverseArr(arr, k, n - 1); // 3. 翻转剩余字符
        
        // 数组转回字符串输出
        console.log(arr.join(''));
        rl.close();
    }
});
```

### 用栈实现队列

使用栈实现队列的下列操作：

push(x) -- 将一个元素放入队列的尾部。
pop() -- 从队列首部移除元素。
peek() -- 返回队列首部的元素。
empty() -- 返回队列是否为空。

示例:

MyQueue queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false

说明:

- 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

**方法思路**：双栈法

解决这个问题的标准方法是使用**两个栈**，我们可以称之为 `inStack` 和 `outStack`。

1. **`inStack` (入队栈)**：专门用于处理 `push` 操作，所有新元素都压入这个栈。
2. **`outStack` (出队栈)**：专门用于处理 `pop` 和 `peek` 操作。

**核心思想**：当需要执行 `pop` 或 `peek` 操作时，如果 `outStack` 为空，我们就将 `inStack` 中的所有元素 “倒” 到 `outStack` 中。这样一来，`inStack` 中最早进入的元素就变成了 `outStack` 中最晚进入的元素，当我们从 `outStack` 中弹出或查看顶部元素时，就符合了队列 “先进先出” 的规则。

**举个例子**：

- `push(1)` -> `inStack: [1]`
- `push(2)` -> `inStack: [1, 2]`
  - `inStack` 弹出 `2`，压入 `outStack` -> `outStack: [2]`
  - `inStack` 弹出 `1`，压入 `outStack` -> `outStack: [2, 1]`
- 现在 `outStack` 不为空，`peek()` 直接返回 `outStack` 的栈顶元素 `1`。
- `pop()` -> 从 `outStack` 弹出栈顶元素 `1`，`outStack` 变为 `[2]`。
- `push(3)` -> 新元素继续压入 `inStack` -> `inStack: [3]`
- `pop()` -> `outStack` 不为空，直接弹出 `2`。

这种方法确保了每个元素最多被压入和弹出栈两次（一次在 `inStack`，一次在 `outStack`），因此每个操作的**均摊时间复杂度**是 O (1)。

```js
/**
 * Initialize your data structure here.
 */
var MyQueue = function() {
    // 定义两个栈，inStack 用于入队，outStack 用于出队
    this.inStack = [];
    this.outStack = [];
};

/**
 * Push element x to the back of queue.
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    // 直接将元素压入 inStack
    this.inStack.push(x);
};

/**
 * Removes the element from in front of queue and returns that element.
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    // 如果 outStack 为空，就将 inStack 的所有元素转移到 outStack
    if (this.outStack.length === 0) {
        while (this.inStack.length > 0) {
            this.outStack.push(this.inStack.pop());
        }
    }
    // 从 outStack 弹出栈顶元素
    return this.outStack.pop();
};

/**
 * Get the front element.
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    // 逻辑与 pop 类似，但只是查看，不弹出
    if (this.outStack.length === 0) {
        while (this.inStack.length > 0) {
            this.outStack.push(this.inStack.pop());
        }
    }
    // 返回 outStack 的栈顶元素
    return this.outStack[this.outStack.length - 1];
};

/**
 * Returns whether the queue is empty.
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    // 当两个栈都为空时，队列才是空的
    return this.inStack.length === 0 && this.outStack.length === 0;
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

### 用队列实现栈

使用队列实现栈的下列操作：

- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

注意:

- 你只能使用队列的基本操作-- 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。
- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

方法思路：双队列法

实现这个需求的标准方法是使用**两个队列**，我们可以称之为 `queue1` 和 `queue2`。

1. **`queue1`**：作为主要的存储队列，新元素总是被添加到它的尾部。
2. **`queue2`**：作为辅助队列，用于在执行 `pop` 或 `top` 操作时临时存放元素。

**核心思想**：当需要执行 `pop` 或 `top` 操作时（这两个操作都需要访问 “栈顶”，也就是队列中最后一个入队的元素），我们先将 `queue1` 中除了最后一个元素之外的所有元素都移动到 `queue2` 中。这时，`queue1` 中剩下的那个元素就是我们需要的 “栈顶” 元素。我们可以直接将其弹出（`pop`）或查看（`top`）。之后，为了方便下一次操作，我们可以交换 `queue1` 和 `queue2` 的角色，让 `queue2` 成为新的主队列，`queue1` 成为空的辅助队列。

**举个例子**：

- `push(1)` -> `queue1: [1]`, `queue2: []`
- `push(2)` -> `queue1: [1, 2]`, `queue2: []`
- `top()` -> 需要获取最后一个元素 `2`。
  - 将 `queue1` 中除最后一个元素外的所有元素（即 `1`）移动到 `queue2`。
  - `queue1: [2]`, `queue2: [1]`
  - 弹出 `queue1` 的队首元素 `2` 并返回。
  - 此时 `queue1` 为空，`queue2` 为 `[1]`。我们可以选择交换它们，让 `queue1` 再次成为主队列。
  - `queue1: [1]`, `queue2: []`
- `pop()` -> 需要移除最后一个元素 `2`。
  - 将 `queue1` 中除最后一个元素外的所有元素（即 `1`）移动到 `queue2`。
  - `queue1: [2]`, `queue2: [1]`
  - 弹出 `queue1` 的队首元素 `2` 并返回。
  - 此时 `queue1` 为空，`queue2` 为 `[1]`。我们可以选择交换它们，让 `queue1` 再次成为主队列。
  - `queue1: [1]`, `queue2: `

```js
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    // 初始化两个队列
    this.queue1 = [];
    this.queue2 = [];
};

/**
 * Push element x onto stack.
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    // 新元素总是加入到主队列 queue1 的末尾
    this.queue1.push(x);
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    // 将 queue1 中除最后一个元素外的所有元素转移到 queue2
    while (this.queue1.length > 1) {
        this.queue2.push(this.queue1.shift());
    }
    
    // 此时 queue1 中只剩下一个元素，即栈顶元素
    const topElement = this.queue1.shift();
    
    // 交换 queue1 和 queue2 的角色，让 queue2 成为新的主队列
    [this.queue1, this.queue2] = [this.queue2, this.queue1];
    
    return topElement;
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    // 逻辑与 pop 类似，但我们只是获取值，不弹出
    while (this.queue1.length > 1) {
        this.queue2.push(this.queue1.shift());
    }
    
    // 此时 queue1[0] 就是栈顶元素
    const topElement = this.queue1[0];
    
    // 将这个元素也转移到 queue2，保持队列的一致性
    this.queue2.push(this.queue1.shift());
    
    // 交换 queue1 和 queue2 的角色
    [this.queue1, this.queue2] = [this.queue2, this.queue1];
    
    return topElement;
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    // 因为主队列是 queue1，所以只需要检查 queue1 是否为空
    return this.queue1.length === 0;
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```











### 逆波兰表达式求值

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
  const stack = [];
  for (const token of tokens) {
    // 判断是否为运算符
    if (['+', '-', '*', '/'].includes(token)) {
      // 弹出两个操作数（注意顺序：后弹出的是左操作数）
      const b = Number(stack.pop());
      const a = Number(stack.pop());
      let result;
      
      switch (token) {
        case '+':
          result = a + b;
          break;
        case '-':
          result = a - b;
          break;
        case '*':
          result = a * b;
          break;
        case '/':
          // 整数除法：向零取整（注意 JavaScript 除法的特性）
          result = Math.trunc(a / b); // 或 parseInt(a / b)
          break;
      }
      
      stack.push(result);
    } else {
      // 数字直接入栈（转为 Number 类型）
      stack.push(Number(token));
    }
  }
  // 栈中剩余的唯一元素即为结果
  return stack[0];
};
```

### 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

示例 1：

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

思路：维护一个**单调递减的队列**，队列中存储的是数组元素的**索引**（而非值），队列头部始终是当前滑动窗口的**最大值索引**。

- **入队**：对于当前元素 `nums[i]`，从队列尾部开始，移除所有**值小于 nums [i]** 的元素索引（因为这些元素在当前元素之后，不可能成为后续窗口的最大值，直接淘汰），最后将 `i` 入队。
- **出队**：若队列头部的索引 **超出当前窗口范围**（即 `队列头部索引 <= i - k`），则将其出队（窗口已滑动，该元素不再属于当前窗口）。
- **取最大值**：每次窗口滑动到有效位置（`i >= k - 1`），队列头部索引对应的元素就是当前窗口的最大值。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    const result = [];
    const deque = []; // 单调递减队列，存储元素索引
    
    for (let i = 0; i < nums.length; i++) {
        // 1. 维护队列单调性：移除尾部小于当前元素的索引（这些元素不可能成为后续窗口最大值）
        while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        deque.push(i);
        
        // 2. 移除窗口外的元素（头部索引超出 i - k 范围）
        while (deque[0] <= i - k) {
            deque.shift();
        }
        
        // 3. 当窗口大小达到 k 时，记录当前窗口最大值（队列头部）
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
};
```



### 二叉树的递归遍历

**前序遍历**：

1. 如果当前节点为空，返回空数组。
2. 先访问当前节点（将值存入结果）。
3. 递归遍历左子树。
4. 递归遍历右子树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const result = [];
    
    const preorder = (node) => {
        if (node === null) return;
        result.push(node.val); // 先访问根节点
        preorder(node.left);   // 再遍历左子树
        preorder(node.right);  // 最后遍历右子树
    };
    
    preorder(root);
    return result;
};

// 示例:
// 输入: root = [1,null,2,3]
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);
console.log(preorderTraversal(root1)); // 输出: [1, 2, 3]
```

**中序遍历**

1. 如果当前节点为空（`root === null`），则返回一个空数组。
2. 递归地遍历当前节点的左子树。
3. 将当前节点的值加入到结果数组中。
4. 递归地遍历当前节点的右子树。
5. 返回合并后的结果数组。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    // 初始化一个空数组来存储遍历结果
    const result = [];
    
    // 定义一个递归辅助函数
    const inorder = (node) => {
        // 递归的终止条件：如果节点为空，就返回
        if (node === null) {
            return;
        }
        // 1. 递归遍历左子树
        inorder(node.left);
        // 2. 访问当前节点，将其值加入结果数组
        result.push(node.val);
        // 3. 递归遍历右子树
        inorder(node.right);
    };
    
    // 从根节点开始执行递归遍历
    inorder(root);
    
    // 返回最终的结果数组
    return result;
};

// 示例:
// 输入: root = [1,null,2,3]
// 构建二叉树
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);

console.log(inorderTraversal(root1)); // 输出: [1, 3, 2]
```

**后序遍历**：

1. 如果当前节点为空，返回空数组。
2. 先递归遍历左子树。
3. 再递归遍历右子树。
4. 最后访问当前节点（将值存入结果）。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = [];
    
    const postorder = (node) => {
        if (node === null) return;
        postorder(node.left);   // 先遍历左子树
        postorder(node.right);  // 再遍历右子树
        result.push(node.val);  // 最后访问根节点
    };
    
    postorder(root);
    return result;
};

// 示例:
// 输入: root = [1,null,2,3]
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);
console.log(postorderTraversal(root1)); // 输出: [3, 2, 1]
```

### 二叉树的迭代遍历

**前序遍历**：

1. 初始化栈，将根节点压入栈。
2. 当栈不为空时，弹出栈顶节点，访问它（存入结果）。
3. 因为栈是后进先出，所以先压右子节点，再压左子节点（保证左子树先遍历）。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const result = [];
    const stack = [];
    
    if (root !== null) {
        stack.push(root);
    }
    
    while (stack.length > 0) {
        const node = stack.pop();
        result.push(node.val); // 访问当前节点
        
        // 先压右子树，再压左子树，保证左子树先遍历
        if (node.right !== null) {
            stack.push(node.right);
        }
        if (node.left !== null) {
            stack.push(node.left);
        }
    }
    
    return result;
};

// 示例 1:
// 输入: root = [1,null,2,3]
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);
console.log(preorderTraversal(root1)); // 输出: [1, 2, 3]
```

**中序遍历**：

1. 初始化一个空栈 `stack` 和一个空结果数组 `result`。

2. 初始化一个指针 `current`，指向根节点 `root`。

3. 当 `current` 不为空或栈 `stack` 不为空时，循环执行以下操作：

   a. 将 `current` 节点以及它所有的左子节点依次推入栈中。这个过程相当于递归地访问左子树，直到没有左子节点为止。

   b. 当没有左子节点可推时，从栈中弹出一个节点。这个节点就是我们当前需要 “访问” 的节点。

   c. 将弹出节点的值加入 `result` 数组。

   d. 将 `current` 指针指向弹出节点的**右子节点**，准备处理右子树。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = [];
    const stack = [];
    let current = root;
    
    // 当 current 不为空或栈不为空时，循环继续
    while (current !== null || stack.length > 0) {
        // 1. 将 current 及其所有左子节点压入栈
        while (current !== null) {
            stack.push(current);
            current = current.left;
        }
        
        // 2. 弹出栈顶元素，这是当前需要访问的节点
        current = stack.pop();
        
        // 3. 访问该节点，将其值加入结果数组
        result.push(current.val);
        
        // 4. 转向右子树
        current = current.right;
    }
    
    return result;
};

// 示例 1:
// 输入: root = [1,null,2,3]
// 构建二叉树
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);

console.log(inorderTraversal(root1)); // 输出: [1, 3, 2]
```

**后续遍历**：后序遍历的迭代实现相对复杂，因为需要确保左、右子树都遍历完毕后再访问根节点。可以用一个栈来存储节点，并用一个集合来标记已访问过的节点。

1. 初始化栈，将根节点压入栈。
2. 当栈不为空时，弹出栈顶节点：
   - 如果该节点已访问过，则将其值加入结果。
   - 如果未访问过，则标记为已访问，再将其右子节点、左子节点依次压入栈（顺序与遍历顺序相反）。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = [];
    const stack = [];
    const visited = new Set(); // 标记已访问的节点
    
    if (root !== null) {
        stack.push(root);
    }
    
    while (stack.length > 0) {
        const node = stack.pop();
        
        if (visited.has(node)) {
            // 如果已访问过，则加入结果
            result.push(node.val);
        } else {
            // 标记为已访问
            visited.add(node);
            // 压入当前节点（后续再处理）
            stack.push(node);
            // 先压右子节点，再压左子节点（保证左子树先遍历）
            if (node.right !== null) {
                stack.push(node.right);
            }
            if (node.left !== null) {
                stack.push(node.left);
            }
        }
    }
    
    return result;
};

// 示例 1:
// 输入: root = [1,null,2,3]
const root1 = new TreeNode(1);
root1.right = new TreeNode(2);
root1.right.left = new TreeNode(3);
console.log(postorderTraversal(root1)); // 输出: [3, 2, 1]
```

### 二叉树的统一迭代法

统一迭代法 (使用额外状态标记)

我们用一个数组（在 JavaScript 中可以用数组模拟栈）来存储待处理的元素。每个元素都是一个包含两个部分的数组：`[节点, 是否已处理]`。

核心逻辑：

1. 将根节点入栈，标记为 `未处理` (`[root, false]`)。

2. 当栈不为空时，循环执行：

   a. 弹出栈顶元素 `[node, isProcessed]`。

   b. 如果 `isProcessed` 为 `false`：

   - 这表示我们是第一次访问这个节点。根据遍历顺序的要求，我们需要将它的右子节点、左子节点以及它自身（标记为 `已处理`）重新入栈。入栈顺序与遍历顺序相反。

   c. 如果 `isProcessed` 为 `true`：

   - 这表示我们是在处理完它的左右子树后回退到这个节点的。此时可以安全地处理它，将它的值加入结果列表。

**前序遍历 (根 -> 左 -> 右)**

根据规则，入栈顺序应该是 `右子树 -> 左子树 -> 根节点(标记为已处理)`。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = [];
    const stack = [];
    
    if (root !== null) {
        stack.push([root, false]);
    }
    
    while (stack.length > 0) {
        const [node, isProcessed] = stack.pop();
        
        if (!isProcessed) {
            // 第一次访问，按 右 -> 根(标记) -> 左 的顺序入栈
            if (node.right !== null) {
                stack.push([node.right, false]);
            }
            stack.push([node, true]); // 将当前节点标记为已处理后入栈
            if (node.left !== null) {
                stack.push([node.left, false]);
            }
        } else {
            // 已处理，将值加入结果
            result.push(node.val);
        }
    }
    
    return result;
};
```

**中序遍历 (左 -> 根 -> 右)**

根据规则，入栈顺序应该是 `右子树 -> 根节点(标记为已处理) -> 左子树`。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = [];
    const stack = [];
    
    if (root !== null) {
        stack.push([root, false]);
    }
    
    while (stack.length > 0) {
        const [node, isProcessed] = stack.pop();
        
        if (!isProcessed) {
            // 第一次访问，按 右 -> 根(标记) -> 左 的顺序入栈
            if (node.right !== null) {
                stack.push([node.right, false]);
            }
            stack.push([node, true]); // 将当前节点标记为已处理后入栈
            if (node.left !== null) {
                stack.push([node.left, false]);
            }
        } else {
            // 已处理，将值加入结果
            result.push(node.val);
        }
    }
    
    return result;
};
```

**后序遍历 (左 -> 右 -> 根)**

根据规则，入栈顺序应该是 `根节点(标记为已处理) -> 右子树 -> 左子树`。

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = [];
    const stack = [];
    
    if (root !== null) {
        stack.push([root, false]);
    }
    
    while (stack.length > 0) {
        const [node, isProcessed] = stack.pop();
        
        if (!isProcessed) {
            // 第一次访问，按 根(标记) -> 右 -> 左 的顺序入栈
            stack.push([node, true]); // 将当前节点标记为已处理后入栈
            if (node.right !== null) {
                stack.push([node.right, false]);
            }
            if (node.left !== null) {
                stack.push([node.left, false]);
            }
        } else {
            // 已处理，将值加入结果
            result.push(node.val);
        }
    }
    
    return result;
};
```

### 二叉树的层序遍历

要实现二叉树的层序遍历（即按层从左到右访问节点），可以使用 **广度优先搜索（BFS)** 的思想，借助队列来实现。

思路:

1. 初始化一个队列，并将根节点入队（如果根节点不为空）。
2. 当队列不为空时，记录当前队列的长度（即当前层的节点数）。
3. 循环取出当前层的所有节点：
   - 取出队首节点，将其值加入当前层的结果数组。
   - 如果该节点有左子节点，将左子节点入队。
   - 如果该节点有右子节点，将右子节点入队。
4. 将当前层的结果数组加入最终的结果数组。
5. 重复步骤 2-4，直到队列为空。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    const result = [];
    if (root === null) {
        return result;
    }

    const queue = [root]; // 初始化队列，将根节点入队

    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数
        const currentLevel = []; // 存储当前层的节点值

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift(); // 取出队首节点
            currentLevel.push(node.val); // 将节点值加入当前层

            // 将左右子节点入队（如果有的话）
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }

        result.push(currentLevel); // 将当前层的结果加入最终结果
    }

    return result;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);

console.log(levelOrder(root)); // 输出: [[3], [9, 20], [15, 7]]
```

### 二叉树的层次遍历 II

```
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    const result = [];
    if (root === null) {
        return result;
    }

    const queue = [root]; // 初始化队列，将根节点入队

    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数
        const currentLevel = []; // 存储当前层的节点值

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift(); // 取出队首节点
            currentLevel.push(node.val); // 将节点值加入当前层

            // 将左右子节点入队（如果有的话）
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }

        result.push(currentLevel); // 将当前层的结果加入最终结果
    }

    return result.resolve();
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);

console.log(levelOrder(root)); // 输出: [[3], [9, 20], [15, 7]]
```

### 二叉树的右视图

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    const result = [];
    if (root === null) {
        return result;
    }

    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数量
        
        // 遍历当前层的所有节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            // 判断是否是当前层的最后一个节点
            if (i === levelSize - 1) {
                result.push(node.val);
            }
            
            // 将左右子节点加入队列，为下一层遍历做准备
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
    }

    return result;
};

// 示例 1:
// 输入: root = [1,2,3,null,5,null,4]
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.right = new TreeNode(5);
root.right.right = new TreeNode(4);

console.log(rightSideView(root)); // 输出: [1, 3, 4]
```

### 二叉树的层平均值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {
    const result = [];
    const queue = [];

    if (root !== null) {
        queue.push(root);
    }

    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数量
        let sum = 0; // 用于累加当前层所有节点的值

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            sum += node.val; // 累加节点值

            // 将下一层的节点加入队列
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }

        // 计算当前层的平均值并加入结果数组
        const average = sum / levelSize;
        result.push(average);
    }

    return result;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root1 = new TreeNode(3);
root1.left = new TreeNode(9);
root1.right = new TreeNode(20);
root1.right.left = new TreeNode(15);
root1.right.right = new TreeNode(7);

console.log(averageOfLevels(root1)); // 输出: [3, 14.5, 11]
```

### n叉树的层级遍历

```js
/**
 * // Definition for a Node.
 * function Node(val, children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    const result = [];
    if (!root) return result; // 根节点为空，直接返回

    const queue = [root]; // 队列初始化，存入根节点

    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数量
        const currentLevel = []; // 存储当前层的节点值

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift(); // 取出队首节点
            currentLevel.push(node.val); // 收集当前节点值

            // 将当前节点的所有子节点加入队列（按顺序）
            if (node.children && node.children.length > 0) {
                queue.push(...node.children); // 展开子节点数组，逐个入队
            }
        }

        result.push(currentLevel); // 加入当前层结果
    }

    return result;
};
```

### 在每个树行中找最大值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function(root) {
    const result = [];
    if (root === null) {
        return result;
    }

    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        let currentMax = -Infinity; // 初始化当前层最大值为负无穷

        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            // 更新当前层的最大值
            if (node.val > currentMax) {
                currentMax = node.val;
            }

            // 将下一层的节点加入队列
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }

        // 将当前层的最大值加入结果数组
        result.push(currentMax);
    }

    return result;
};

// 示例 1:
// 输入: root = [1,3,2,5,3,null,9]
const root1 = new TreeNode(1);
root1.left = new TreeNode(3);
root1.right = new TreeNode(2);
root1.left.left = new TreeNode(5);
root1.left.right = new TreeNode(3);
root1.right.right = new TreeNode(9);

console.log(largestValues(root1)); // 输出: [1, 3, 9]
```

### 填充每个节点的下一个右侧节点指针

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function(root) {
    if (root === null) {
        return root;
    }

    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        
        for (let i = 0; i < levelSize; i++) {
            const currentNode = queue.shift();

            // 连接当前层的节点
            // 如果不是当前层的最后一个节点，则 next 指向下一个节点
            if (i < levelSize - 1) {
                currentNode.next = queue[0];
            } else {
                // 如果是当前层的最后一个节点，next 指向 null
                currentNode.next = null;
            }
            
            // 将下一层的节点加入队列
            // 完美二叉树的每个节点都有两个子节点
            if (currentNode.left !== null) {
                queue.push(currentNode.left);
            }
            if (currentNode.right !== null) {
                queue.push(currentNode.right);
            }
        }
    }

    return root;
};
```

### 二叉树的最大深度

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if (root === null) {
        return 0;
    }
    
    const queue = [root];
    let depth = 0;
    
    while (queue.length > 0) {
        // 记录当前层的节点数量
        const levelSize = queue.length;
        
        // 遍历当前层的所有节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            // 将下一层的节点入队
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
        
        // 每遍历完一层，深度加 1
        depth++;
    }
    
    return depth;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root1 = new TreeNode(3);
root1.left = new TreeNode(9);
root1.right = new TreeNode(20);
root1.right.left = new TreeNode(15);
root1.right.right = new TreeNode(7);
console.log(maxDepth(root1)); // 输出: 3
```

### 二叉树的最小深度

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (root === null) {
        return 0;
    }
    
    const queue = [root];
    let depth = 0;
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        depth++; // 开始处理新的一层，深度加 1
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            
            // 找到第一个叶子节点，直接返回当前深度
            if (node.left === null && node.right === null) {
                return depth;
            }
            
            // 将下一层的节点入队
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
    }
    
    return depth;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root1 = new TreeNode(3);
root1.left = new TreeNode(9);
root1.right = new TreeNode(20);
root1.right.left = new TreeNode(15);
root1.right.right = new TreeNode(7);
console.log(minDepth(root1)); // 输出: 2
```

### 翻转二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function(root) {
    if (root === null) {
        return null;
    }

    const queue = [root];

    while (queue.length > 0) {
        // 出队一个节点
        const node = queue.shift();

        // 交换当前节点的左、右子树
        [node.left, node.right] = [node.right, node.left];

        // 将交换后的子节点入队，以便后续处理
        if (node.left !== null) {
            queue.push(node.left);
        }
        if (node.right !== null) {
            queue.push(node.right);
        }
    }

    return root;
};

// 示例 1:
// 输入: root = [4,2,7,1,3,6,9]
const root1 = new TreeNode(4);
root1.left = new TreeNode(2);
root1.right = new TreeNode(7);
root1.left.left = new TreeNode(1);
root1.left.right = new TreeNode(3);
root1.right.left = new TreeNode(6);
root1.right.right = new TreeNode(9);
console.log(invertTree(root1)); 
// 输出的树结构应为:
//       4
//     /   \
//    7     2
//   / \   / \
//  9   6 3   1
```

### 完全二叉树的节点个数

方法1：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    // 递归终止：空节点没有节点
    if (root === null) {
        return 0;
    }
    // 左子树节点数 + 右子树节点数 + 当前节点
    return countNodes(root.left) + countNodes(root.right) + 1;
};
```

方法2：

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    let count = 0
    const queue = []

    if(root !== null){
        queue.push(root)
        count++
    }

    while(queue.length !== 0){
        const size = queue.length
        for(let i=0;i<size;i++){
            const node = queue.shift()
            if(node.left !== null){
                queue.push(node.left)
                count++
            }
            if(node.right !== null){
                queue.push(node.right)
                count++
            }
        }
    }

    return count
};
```

### 平衡二叉树

思路：使用后序遍历

1. 先递归地判断其左子树是否平衡。
2. 再递归地判断其右子树是否平衡。
3. 在回溯的过程中，计算当前节点的高度，并判断当前节点的左右子树高度差是否满足条件。

为了提高效率，我们可以让递归函数返回两种信息：

- 如果子树是平衡的，返回其高度。
- 如果子树是不平衡的，返回一个特殊值（例如 `-1`），以此来终止后续的递归判断。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isBalanced = function(root) {
    // 定义一个递归函数，返回子树的高度，如果不平衡则返回 -1
    const getDepth = (node) => {
        // 递归终止条件：空节点的高度为 0
        if (node === null) {
            return 0;
        }
        
        // 递归计算左子树高度
        const leftDepth = getDepth(node.left);
        // 如果左子树不平衡，直接向上返回 -1
        if (leftDepth === -1) {
            return -1;
        }
        
        // 递归计算右子树高度
        const rightDepth = getDepth(node.right);
        // 如果右子树不平衡，直接向上返回 -1
        if (rightDepth === -1) {
            return -1;
        }
        
        // 检查当前节点的左右子树高度差是否超过 1
        if (Math.abs(leftDepth - rightDepth) > 1) {
            return -1; // 不平衡
        }
        
        // 如果平衡，返回当前子树的高度
        return 1 + Math.max(leftDepth, rightDepth);
    };
    
    // 如果 getDepth 返回的不是 -1，说明树是平衡的
    return getDepth(root) !== -1;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root1 = new TreeNode(3);
root1.left = new TreeNode(9);
root1.right = new TreeNode(20);
root1.right.left = new TreeNode(15);
root1.right.right = new TreeNode(7);
console.log(isBalanced(root1)); // 输出: true
```

### 二叉树的所有路径

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    const result = [];

    // 递归辅助函数，参数为当前节点和当前路径字符串
    const dfs = (node, currentPath) => {
        // 如果节点为空，直接返回
        if (node === null) {
            return;
        }

        // 将当前节点的值加入路径
        // 如果当前路径不为空，需要先加 "->"
        const newPath = currentPath === '' ? `${node.val}` : `${currentPath}->${node.val}`;

        // 判断是否为叶子节点
        if (node.left === null && node.right === null) {
            result.push(newPath); // 找到一条完整路径，加入结果
            return;
        }

        // 递归探索左子树和右子树
        dfs(node.left, newPath);
        dfs(node.right, newPath);
    };

    // 从根节点开始，初始路径为空字符串
    dfs(root, '');

    return result;
};

// 示例 1:
// 输入: root = [1,2,3,null,5]
const root1 = new TreeNode(1);
root1.left = new TreeNode(2);
root1.right = new TreeNode(3);
root1.left.right = new TreeNode(5);
console.log(binaryTreePaths(root1)); // 输出: ["1->2->5", "1->3"]
```

### 对称二叉树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val === undefined ? 0 : val);
 *     this.left = (left === undefined ? null : left);
 *     this.right = (right === undefined ? null : right);
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    // 空树是对称的
    if (root === null) {
        return true;
    }

    const stack = [];
    // 初始化栈，放入根节点的左右孩子
    stack.push(root.left);
    stack.push(root.right);

    while (stack.length > 0) {
        // 每次从栈中取出两个节点进行比较
        const t1 = stack.pop();
        const t2 = stack.pop();

        // 如果两个都为 null，继续下一次循环
        if (t1 === null && t2 === null) {
            continue;
        }
        // 如果一个为 null，另一个不为 null，则不对称
        if (t1 === null || t2 === null) {
            return false;
        }
        // 如果两个节点的值不相等，则不对称
        if (t1.val !== t2.val) {
            return false;
        }

        // 关键：按照对称的顺序将子节点入栈
        // t1的左孩子 应该和 t2的右孩子 对称
        // t1的右孩子 应该和 t2的左孩子 对称
        stack.push(t1.left);
        stack.push(t2.right);
        stack.push(t1.right);
        stack.push(t2.left);
    }

    // 如果循环正常结束，说明所有对称节点都比较过了，且都相等
    return true;
};
```

### 左叶子之和

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    if (root === null) {
        return 0;
    }

    let sum = 0;
    const queue = [root];

    while (queue.length > 0) {
        const node = queue.shift();

        // 检查当前节点的左孩子是否是左叶子
        if (node.left !== null) {
            if (node.left.left === null && node.left.right === null) {
                sum += node.left.val;
            }
            // 将左孩子加入队列，以便处理它的子节点
            queue.push(node.left);
        }

        // 将右孩子加入队列
        if (node.right !== null) {
            queue.push(node.right);
        }
    }

    return sum;
};

// 示例 1:
// 输入: root = [3,9,20,null,null,15,7]
const root1 = new TreeNode(3);
root1.left = new TreeNode(9);
root1.right = new TreeNode(20);
root1.right.left = new TreeNode(15);
root1.right.right = new TreeNode(7);
console.log(sumOfLeftLeaves(root1)); // 输出: 24 (9 + 15)
```

### 找树左下角的值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var findBottomLeftValue = function(root) {
    if (root === null) {
        return null; // 题目保证至少有一个节点，此情况可忽略
    }

    const queue = [root];
    let leftmostValue = root.val; // 初始化，默认为根节点的值

    while (queue.length > 0) {
        const levelSize = queue.length;
        
        // 遍历当前层的所有节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();

            // 如果是当前层的第一个节点，更新 leftmostValue
            if (i === 0) {
                leftmostValue = node.val;
            }

            // 将下一层的节点入队
            if (node.left !== null) {
                queue.push(node.left);
            }
            if (node.right !== null) {
                queue.push(node.right);
            }
        }
    }

    // 循环结束后，leftmostValue 保存的就是最底层最左边节点的值
    return leftmostValue;
};

// 示例 1:
// 输入: root = [2,1,3]
const root1 = new TreeNode(2);
root1.left = new TreeNode(1);
root1.right = new TreeNode(3);
console.log(findBottomLeftValue(root1)); // 输出: 1
```

### 路径总和

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    // 1. 如果节点为空，返回 false
    if (root === null) {
        return false;
    }

    // 2. 如果是叶子节点，检查当前节点值是否等于剩余的目标和
    if (root.left === null && root.right === null) {
        return root.val === targetSum;
    }

    // 3. 递归探索左、右子树
    // 新的目标和是 targetSum 减去当前节点的值
    const remainingSum = targetSum - root.val;
    return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);
};

// 示例 1:
// 输入: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
const root1 = new TreeNode(5);
root1.left = new TreeNode(4);
root1.right = new TreeNode(8);
root1.left.left = new TreeNode(11);
root1.right.left = new TreeNode(13);
root1.right.right = new TreeNode(4);
root1.left.left.left = new TreeNode(7);
root1.left.left.right = new TreeNode(2);
root1.right.right.right = new TreeNode(1);
console.log(hasPathSum(root1, 22)); // 输出: true (5 -> 4 -> 11 -> 2)
```

### 组合问题

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 任何顺序 返回答案。

示例 1：

输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

方法思路：我们可以使用**深度优先搜索（DFS）+ 回溯**的思路，核心是递归地构建所有长度为 `k` 的组合。

1. **递归参数**：需要记录当前可选的起始数字 `start`、当前组合 `path`，以及最终结果集 `result`。
2. **递归终止条件**：当 `path` 的长度等于 `k` 时，说明已找到一个有效组合，将其加入结果集。
3. **递归过程**：从 `start` 开始遍历到 `n`，每次选择一个数字加入 `path`，然后递归处理下一层（起始数字更新为当前数字 + 1），最后回溯（将该数字从 `path` 中移除）。

```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
    const result = []; // 存储最终所有组合
    const path = [];   // 存储当前正在构建的组合

    // 定义递归函数，start 表示当前可选数字的起始值
    const dfs = (start) => {
        // 终止条件：当前组合长度等于 k，说明找到一个有效组合
        if (path.length === k) {
            result.push([...path]); // 深拷贝当前组合，避免引用问题
            return;
        }

        // 遍历可选数字：从 start 到 n
        for (let i = start; i <= n; i++) {
            path.push(i);          // 选择数字 i 加入当前组合
            dfs(i + 1);            // 递归处理下一层（下一个数字从 i+1 开始选）
            path.pop();            // 回溯：将数字 i 从当前组合中移除
        }
    };

    dfs(1); // 从数字 1 开始递归
    return result;
};

// 示例 1 测试
console.log(combine(4, 2)); 
// 输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

```

### 组合总和III

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

- 所有数字都是正整数。
- 解集不能包含重复的组合。

示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]]

示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]]

1. 递归参数：
   - `start`：当前递归层可以选择的数字起始值（用于避免重复组合，例如 `[1,2,3]` 和 `[2,1,3]` 是同一个组合）。
   - `currentSum`：当前路径上所有数字的和。
   - `path`：当前正在构建的组合数组。
2. 递归终止条件：
   - 如果 `path` 的长度等于 `k`：
     - 检查 `currentSum` 是否等于 `n`。如果等于，说明找到了一个有效组合，将 `path` 加入结果集。
     - 无论是否等于，都需要返回，因为已经选够了 `k` 个数字。

3. **递归过程**：
   - 从 `start` 开始遍历数字 `1` 到 `9`。
   - **剪枝**：
     - 如果 `currentSum + i > n`，说明即使选择当前数字 `i`，后续再选择更小的数字（但题目要求数字递增，所以后续数字更大）也无法得到和为 `n` 的组合，可以直接 `break` 循环。
     - 如果 `path.length + (9 - i + 1) < k`，说明剩余的数字（从 `i` 到 `9`）即使全部选择，也凑不够 `k` 个数字，可以直接 `break` 循环。
   - 将数字 `i` 加入 `path`，并更新 `currentSum`。
   - 递归调用 `dfs`，下一次的起始值为 `i + 1`（保证数字不重复使用）。
   - **回溯**：递归调用返回后，将数字 `i` 从 `path` 中移除，并将 `currentSum` 减去 `i`，以便探索其他可能性。

```js
/**
 * @param {number} k
 * @param {number} n
 * @return {number[][]}
 */
var combinationSum3 = function(k, n) {
    const result = [];

    // 定义递归函数
    // start: 下一个可以选择的数字起始值
    // currentSum: 当前路径的和
    // path: 当前构建的路径
    const dfs = (start, currentSum, path) => {
        // 1. 递归终止条件：路径长度已达 k
        if (path.length === k) {
            // 如果当前和等于目标和 n，则找到一个有效组合
            if (currentSum === n) {
                result.push([...path]); // 注意要深拷贝
            }
            return;
        }

        // 2. 遍历可能的数字，从 start 到 9
        // 剪枝：i 的上限可以优化，不需要到9
        // 剩余需要选择的数字个数：k - path.length
        // 剩余可用的最大数字是9，所以 i 的上限是 9 - (k - path.length - 1)
        // 例如，还需要选2个，i最大只能是8 (8,9)
        const need = k - path.length;
        for (let i = start; i <= 9 - need + 1; i++) {
            // 剪枝：如果当前和加上 i 已经超过 n，后续更大的 i 就不用考虑了
            if (currentSum + i > n) {
                break;
            }
            
            // 选择数字 i
            path.push(i);
            
            // 递归探索下一层，下一次从 i+1 开始，并且更新当前和
            dfs(i + 1, currentSum + i, path);
            
            // 3. 回溯：撤销选择，将 i 从 path 中移除
            path.pop();
        }
    };

    // 初始调用：从数字 1 开始，当前和为 0，路径为空
    dfs(1, 0, []);

    return result;
};

// 示例 1:
console.log(combinationSum3(3, 7)); // 输出: [[1,2,4]]
```

### 电话号码的字母组合

方法思路:要解决 “电话号码的字母组合” 问题，我们可以使用**深度优先搜索（DFS）+ 回溯**的方法，逐步构建所有可能的字母组合。

1. **建立数字到字母的映射**：首先定义一个对象，存储每个数字对应的字母集合。
2. **递归参数**：需要记录当前处理的数字索引 `index`、当前构建的字母组合 `path`，以及最终结果集 `result`。
3. **递归终止条件**：当 `index` 等于输入字符串 `digits` 的长度时，说明已处理完所有数字，将当前 `path` 加入结果集。
4. **递归过程**：对于当前数字，遍历其对应的所有字母，将每个字母加入 `path`，然后递归处理下一个数字（`index + 1`），最后回溯（将该字母从 `path` 中移除）。

```js
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    // 处理空输入
    if (digits.length === 0) return [];

    // 数字到字母的映射
    const digitMap = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    };

    const result = []; // 存储最终结果
    const path = [];   // 存储当前构建的字母组合

    // 定义递归函数
    const dfs = (index) => {
        // 终止条件：处理完所有数字
        if (index === digits.length) {
            result.push(path.join(''));
            return;
        }

        // 获取当前数字对应的字母集合
        const letters = digitMap[digits[index]];
        // 遍历所有字母，递归构建组合
        for (let i = 0; i < letters.length; i++) {
            path.push(letters[i]);   // 选择当前字母
            dfs(index + 1);          // 递归处理下一个数字
            path.pop();              // 回溯：移除当前字母
        }
    };

    dfs(0); // 从第0个数字开始递归
    return result;
};

// 示例测试
console.log(letterCombinations("23")); 
// 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

### 数组总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

示例 1：

输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]

方法思路

1. 递归参数：
   - `startIndex`：当前递归层可以选择的数字在 `candidates` 数组中的起始索引。**这是避免重复组合的关键**。
   - `currentSum`：当前路径上所有数字的和。
   - `path`：当前正在构建的组合数组。
2. 递归终止条件：
   - 如果 `currentSum > target`：说明当前路径的和已经超过了目标值，继续下去没有意义，直接返回（剪枝）。
   - 如果 `currentSum === target`：说明找到了一个有效组合，将 `path` 加入结果集，然后返回。
3. 递归过程：
   - 从 `startIndex` 开始遍历 `candidates` 数组。
   - **选择**：将当前数字 `candidates[i]` 加入 `path`，并将 `currentSum` 加上该数字。
   - **递归**：递归调用自身。由于数字可以重复使用，下一次递归的 `startIndex` **仍然是 `i`**，而不是 `i + 1`。
   - **回溯**：递归调用返回后，将当前数字 `candidates[i]` 从 `path` 中移除，并将 `currentSum` 减去该数字，以便探索其他可能性。

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function(candidates, target) {
    const result = [];

    // 定义递归函数
    // startIndex: 下一个可以选择的数字在 candidates 数组中的起始索引
    // currentSum: 当前路径的和
    // path: 当前构建的路径
    const dfs = (startIndex, currentSum, path) => {
        // 1. 递归终止条件
        if (currentSum > target) {
            return; // 和太大，剪枝
        }
        if (currentSum === target) {
            result.push([...path]); // 找到一个有效组合，加入结果集
            return;
        }

        // 2. 遍历 candidates 数组，从 startIndex 开始
        for (let i = startIndex; i < candidates.length; i++) {
            const num = candidates[i];
            
            // 剪枝优化：如果当前数字大于剩余需要的和，后续更大的数字也无需考虑
            if (num > target - currentSum) {
                continue;
            }

            // 选择当前数字
            path.push(num);
            
            // 3. 递归调用
            // 因为数字可以重复使用，所以下一次的 startIndex 仍然是 i
            dfs(i, currentSum + num, path);
            
            // 4. 回溯：撤销选择
            path.pop();
        }
    };

    // 初始调用：从索引 0 开始，当前和为 0，路径为空
    dfs(0, 0, []);

    return result;
};

// 示例 1:
console.log(combinationSum([2, 3, 6, 7], 7));
// 输出: [[2,2,3],[7]]
```

### 数组总和Ⅱ

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,

所求解集为:

[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

方法思路：我们依然使用 **深度优先搜索（DFS）** 结合 **回溯** 的策略，但需要加入一些额外的逻辑来处理上述两个问题。

1. **排序**：首先对 `candidates` 数组进行排序。这是解决重复组合问题的关键。排序后，相同的数字会相邻，我们就可以通过跳过相邻的相同数字来避免产生重复组合。
2. 递归参数：
   - `startIndex`：当前递归层可以选择的数字在 `candidates` 数组中的起始索引。
   - `currentSum`：当前路径上所有数字的和。
   - `path`：当前正在构建的组合数组。
3. 递归终止条件：
   - 如果 `currentSum > target`：剪枝，直接返回。
   - 如果 `currentSum === target`：找到一个有效组合，将 `path` 加入结果集，然后返回。
4. 递归过程：
   - 从 `startIndex` 开始遍历 `candidates` 数组。
   - **跳过重复元素**：如果当前元素与前一个元素相等，并且不是当前层的第一个元素（`i > startIndex`），则跳过当前元素，以避免重复组合。
   - **剪枝**：如果当前数字 `candidates[i]` 大于 `target - currentSum`，则后续更大的数字也无需考虑，直接 `break` 循环。
   - **选择**：将当前数字 `candidates[i]` 加入 `path`，并将 `currentSum` 加上该数字。
   - **递归**：递归调用自身。由于每个数字只能使用一次，下一次递归的 `startIndex` 应该是 `i + 1`。
   - **回溯**：递归调用返回后，将当前数字 `candidates[i]` 从 `path` 中移除，并将 `currentSum` 减去该数字。

```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function(candidates, target) {
    const result = [];
    const path = [];
    
    // 1. 对数组进行排序，以便处理重复元素
    candidates.sort((a, b) => a - b);

    const dfs = (startIndex, currentSum) => {
        // 2. 递归终止条件
        if (currentSum > target) {
            return;
        }
        if (currentSum === target) {
            result.push([...path]);
            return;
        }

        // 3. 遍历 candidates 数组
        for (let i = startIndex; i < candidates.length; i++) {
            const num = candidates[i];

            // 剪枝：如果当前数字已经大于剩余需要的和，后续数字更大，无需考虑
            if (num > target - currentSum) {
                break;
            }

            // 4. 跳过重复元素，避免产生重复组合
            // i > startIndex 确保我们不会跳过同一层的第一个元素
            if (i > startIndex && num === candidates[i - 1]) {
                continue;
            }

            // 选择当前数字
            path.push(num);
            
            // 递归调用，下一次从 i+1 开始，因为数字不能重复使用
            dfs(i + 1, currentSum + num);
            
            // 回溯：撤销选择
            path.pop();
        }
    };

    // 初始调用
    dfs(0, 0);

    return result;
};

// 示例 1:
const candidates = [10, 1, 2, 7, 6, 1, 5];
const target = 8;
console.log(combinationSum2(candidates, target));
// 输出: [[1,1,6],[1,2,5],[1,7],[2,6]]
```

### 分割回文串

给你一个字符串 `s`，请你将 `s` 分割成一些 子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

示例 ：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]

提示：

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

解题思路：

1. **回溯函数**: 我们定义一个递归函数 `backtrack(startIndex)`，它表示从字符串的 `startIndex` 位置开始，寻找所有可能的分割方案。
2. **递归终止条件**: 当 `startIndex` 等于字符串的长度时，说明我们已经成功地遍历了整个字符串，找到了一个有效的分割方案。我们将当前的分割路径（`path`）加入到结果集（`result`）中。
3. **单层递归逻辑**: 从 `startIndex` 开始，我们尝试截取字符串 `s[startIndex...i]`（其中 `i` 从 `startIndex` 到 `s.length - 1`）。
4. **判断回文**: 对于截取的子串 `s[startIndex...i]`，我们需要一个辅助函数来判断它是否是回文串。
5. 递归与回溯:
   - 如果截取的子串是回文串，我们就将其加入到当前的路径（`path`）中。
   - 然后，递归调用 `backtrack(i + 1)`，从新的起始位置 `i + 1` 继续探索。
   - 当递归返回后，我们需要进行 “回溯” 操作，即将刚刚加入路径的子串从 `path` 中移除，以便探索其他可能的分割方式。

```js
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    const result = []; // 存储所有最终的分割方案
    const path = [];   // 存储当前正在构建的分割路径

    /**
     * 判断一个字符串的子串是否为回文
     * @param {string} str 原始字符串
     * @param {number} start 子串起始索引
     * @param {number} end 子串结束索引
     * @returns {boolean} 是否为回文
     */
    function isPalindrome(str, start, end) {
        // 双指针法，从两端向中间逼近
        for (let i = start, j = end; i < j; i++, j--) {
            if (str[i] !== str[j]) {
                return false;
            }
        }
        return true;
    }

    /**
     * 回溯函数
     * @param {number} startIndex 从字符串的哪个索引开始进行分割
     */
    function backtrack(startIndex) {
        // 1. 递归终止条件：当startIndex等于字符串长度时，说明找到了一个完整的分割方案
        if (startIndex === s.length) {
            // 将当前路径的一份拷贝加入结果集
            result.push([...path]); 
            return;
        }

        // 2. 单层递归逻辑：遍历从startIndex开始的所有可能的子串
        for (let i = startIndex; i < s.length; i++) {
            // 3. 处理节点：判断当前子串 s[startIndex..i] 是否是回文
            if (isPalindrome(s, startIndex, i)) {
                // 如果是回文，则将其加入当前路径
                const currentSubstring = s.substring(startIndex, i + 1);
                path.push(currentSubstring);
                
                // 4. 递归：从 i+1 的位置开始继续分割
                backtrack(i + 1);
                
                // 5. 回溯：撤销刚刚的选择，为探索其他路径做准备
                path.pop();
            }
            // 如果不是回文，则跳过，继续尝试下一个更长的子串
        }
    }

    // 从字符串的第0个索引开始启动回溯
    backtrack(0);
    
    return result;
};

// --- 示例测试 ---

// 示例 1
const s1 = "aab";
console.log(`输入: "${s1}"`);
console.log(`输出:`, partition(s1));
// 预期输出: [ [ 'a', 'a', 'b' ], [ 'aa', 'b' ] ]
```

### 复原IP地址

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]

解题思路

1. **问题分析**：我们需要将字符串 `s` 分割成 4 个部分，每个部分都要满足：
   - **范围**：0-255
   - **格式**：不能有前导零，除非这个部分本身就是 "0"
2. **回溯法**：这是解决此类 “找出所有可能组合” 问题的标准方法。
   - 我们定义一个递归函数 `backtrack(startIndex, path)`，其中 `startIndex` 是当前分割的起始位置，`path` 存储了当前已经分割好的 IP 段。
   - **递归终止条件**：当 `path` 中已经有 4 个部分，并且 `startIndex` 等于字符串的长度时，说明我们找到了一个完整且有效的 IP 地址。我们将 `path` 中的部分用 "." 连接起来，加入到结果集中。
   - **单层递归逻辑**：从 `startIndex` 开始，我们尝试截取长度为 1、2、3 的子串（因为 IP 段最大是 255，最多 3 位）。
   - **剪枝与验证**：在截取子串后，我们需要判断它是否是一个有效的 IP 段。如果有效，就将其加入 `path`，并递归调用 `backtrack` 从新的位置开始分割。如果无效，则 “剪枝”，不再继续探索这个分支。
   - **回溯**：递归调用返回后，将刚刚加入 `path` 的 IP 段移除，以便探索其他可能的分割方式。

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function(s) {
    const result = []; // 存储所有有效IP地址的结果集

    /**
     * 判断一个子串是否能成为有效的IP段
     * @param {string} str 待判断的子串
     * @returns {boolean} 是否有效
     */
    function isValidSegment(str) {
        // 1. 长度不能超过3位
        if (str.length > 3) return false;
        // 2. 如果长度大于1，不能以'0'开头 (避免 "01" 这样的情况)
        if (str.length > 1 && str[0] === '0') return false;
        // 3. 转换为数字后，必须在 0-255 之间
        const num = parseInt(str, 10);
        return num >= 0 && num <= 255;
    }

    /**
     * 回溯函数
     * @param {number} startIndex 当前分割的起始位置
     * @param {string[]} path 已收集的IP段数组
     */
    function backtrack(startIndex, path) {
        // 递归终止条件：已经找到4个有效段，并且整个字符串都已使用
        if (path.length === 4) {
            if (startIndex === s.length) {
                // 将path数组用'.'连接成IP地址字符串
                result.push(path.join('.'));
            }
            return;
        }

        // 单层递归逻辑：尝试截取1位、2位、3位的子串
        // 注意：i的上限是 startIndex + 3 和 s.length 中的较小值
        for (let i = startIndex; i < Math.min(startIndex + 3, s.length); i++) {
            const currentSegment = s.substring(startIndex, i + 1);

            // 剪枝操作：如果当前子串不是有效的IP段，则跳过
            if (isValidSegment(currentSegment)) {
                // 做出选择：将有效段加入路径
                path.push(currentSegment);
                
                // 递归：从下一个位置开始继续分割
                backtrack(i + 1, path);
                
                // 回溯：撤销选择，为探索其他路径做准备
                path.pop();
            }
        }
    }

    // 从字符串的第0个索引开始启动回溯
    backtrack(0, []);
    
    return result;
};

// --- 示例测试 ---

// 示例 1
const s1 = "25525511135";
console.log(`输入: "${s1}"`);
console.log(`输出:`, restoreIpAddresses(s1));
// 预期输出: [ '255.255.11.135', '255.255.111.35' ]
```

### 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

解题思路

1. **问题分析**：我们需要生成一个包含数组所有子集的列表。子集的定义是由原数组中的部分或全部元素组成的集合，不考虑元素的顺序，且不能包含重复的元素。
2. 回溯法思路：
   - 我们定义一个递归函数 `backtrack(startIndex, path)`，其中 `startIndex` 表示从数组的哪个索引开始选择元素，`path` 存储了当前正在构建的子集。
   - **递归终止条件**：这个问题比较特殊，它没有一个明确的 “终止点”。因为**每一个 `path` 都是一个有效的子集**，所以我们不需要等到特定条件满足才去收集结果。相反，我们在进入递归函数后，就应该立即将当前的 `path` 加入到结果集中。
   - 单层递归逻辑：从 `startIndex` 开始遍历数组。对于每个元素 `nums[i]`：
     - **做出选择**：将 `nums[i]` 加入到 `path` 中。
     - **递归探索**：调用 `backtrack(i + 1, path)`。注意，这里传入的是 `i + 1` 而不是 `startIndex + 1`，这是为了避免在后续的选择中重复使用之前已经选择过的元素，从而确保子集的唯一性。
     - **撤销选择（回溯）**：递归调用返回后，将刚刚加入 `path` 的元素移除，以便探索其他可能性。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    const result = []; // 存储所有子集的结果集
    const path = [];   // 存储当前正在构建的子集

    /**
     * 回溯函数
     * @param {number} startIndex 从数组的这个索引开始选择元素
     */
    function backtrack(startIndex) {
        // 1. 收集结果：每一个路径都是一个有效的子集
        // 注意：这里要将 path 的一个副本存入 result，而不是 path 本身
        result.push([...path]);

        // 2. 单层递归逻辑：从 startIndex 开始遍历选择
        for (let i = startIndex; i < nums.length; i++) {
            // 做出选择
            path.push(nums[i]);
            
            // 递归探索：下一次从 i+1 的位置开始选择，避免重复
            backtrack(i + 1);
            
            // 撤销选择（回溯）
            path.pop();
        }
    }

    // 从索引 0 开始启动回溯
    backtrack(0);
    
    return result;
};

// --- 示例测试 ---

const nums1 = [1, 2, 3];
console.log(`输入: ${JSON.stringify(nums1)}`);
console.log(`输出: ${JSON.stringify(subsets(nums1))}`);
// 预期输出: [[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]] (顺序可能不同)

console.log('-------------------');

const nums2 = [0];
console.log(`输入: ${JSON.stringify(nums2)}`);
console.log(`输出: ${JSON.stringify(subsets(nums2))}`);
// 预期输出: [[],[0]]
```

### 子集Ⅱ

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

解题思路

1. **排序预处理**：这是解决重复问题的一个常用且有效的技巧。我们首先将数组 `nums` 进行排序。这样一来，所有相同的元素就会被排列在一起。
2. **回溯法**：我们仍然使用回溯法来探索所有可能的子集。
3. 关键剪枝步骤：在递归函数的 `for` 循环中，当我们遇到一个与前一个元素相同的元素时，需要判断是否要跳过当前的选择，以避免生成重复的子集。
   - **剪枝条件**：`if (i > startIndex && nums[i] === nums[i - 1])`
   - 解释：
     - `i > startIndex`：这个条件是关键。它确保了我们只在 “同一层” 的递归中跳过重复元素。也就是说，对于一个包含重复元素的组（如 `[2, 2]`），我们只允许选择第一个 `2` 作为当前步骤的起始点。如果后面的 `2` 与前面的 `2` 相同，并且它们在 `for` 循环中处于同一个 `startIndex` 层次，我们就跳过它。
     - `nums[i] === nums[i - 1]`：简单地检查当前元素是否与前一个元素相同。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsetsWithDup = function(nums) {
    const result = [];
    const path = [];

    // 1. 关键步骤：先对数组进行排序，让相同的元素相邻
    nums.sort((a, b) => a - b);

    /**
     * 回溯函数
     * @param {number} startIndex 从数组的这个索引开始选择元素
     */
    function backtrack(startIndex) {
        // 收集当前路径作为一个子集
        result.push([...path]);

        // 遍历选择
        for (let i = startIndex; i < nums.length; i++) {
            // 2. 关键剪枝：跳过同一层中与前一个元素相同的元素，以避免重复子集
            if (i > startIndex && nums[i] === nums[i - 1]) {
                continue;
            }

            // 做出选择
            path.push(nums[i]);
            
            // 递归探索，下一次从 i+1 开始
            backtrack(i + 1);
            
            // 撤销选择（回溯）
            path.pop();
        }
    }

    backtrack(0);
    return result;
};

// --- 示例测试 ---

const nums1 = [1, 2, 2];
console.log(`输入: ${JSON.stringify(nums1)}`);
console.log(`输出: ${JSON.stringify(subsetsWithDup(nums1))}`);
// 预期输出: [[],[1],[1,2],[1,2,2],[2],[2,2]]
```

### 非递减子序列

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 示例 1：

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

提示：

- `1 <= nums.length <= 15`
- `-100 <= nums[i] <= 100`

解题思路

1. **回溯法**：我们使用回溯法来探索所有可能的递增子序列。
2. **递归函数定义**：定义 `backtrack(startIndex, path)`，其中 `startIndex` 是当前探索的起始位置，`path` 是当前正在构建的子序列。
3. **递归终止条件**：当 `path` 的长度大于等于 2 时，就将其加入到结果集中。注意，这里不需要等到遍历完整个数组才收集结果，因为只要子序列长度达标，它就是一个有效的答案。
4. 单层递归逻辑：
   - 为了避免在同一层递归中选择重复的元素（从而产生重复的子序列），我们需要使用一个 ** 集合（Set）** 来记录当前层已经使用过的元素值。
   - 从 `startIndex` 开始遍历数组：
     - **剪枝 1**：如果当前元素 `nums[i]` 已经在当前层的 `used` 集合中出现过，则跳过，以避免重复。
     - **剪枝 2**：如果当前 `path` 不为空，并且当前元素 `nums[i]` 小于 `path` 的最后一个元素，则说明无法构成递增子序列，跳过。
     - 如果以上条件都不满足，则：
       - 将 `nums[i]` 加入 `used` 集合，表示当前层已使用。
       - 将 `nums[i]` 加入 `path`。
       - 递归调用 `backtrack(i + 1, path)`。
       - **回溯**：将 `nums[i]` 从 `path` 中移除。（注意：`used` 集合不需要回溯，因为它只在当前层有效，下一层会重新创建一个新的 `used` 集合）。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function(nums) {
    const result = []; // 存储所有找到的递增子序列

    /**
     * 回溯函数
     * @param {number} startIndex 从数组的这个索引开始选择下一个元素
     * @param {number[]} path 当前正在构建的子序列
     */
    function backtrack(startIndex, path) {
        // 递归终止条件：只要子序列长度大于等于2，就收集结果
        if (path.length >= 2) {
            result.push([...path]);
            // 注意：这里不 return，因为要继续探索更长的子序列
        }

        // 关键：使用 Set 来记录本层已经使用过的元素，防止重复
        const used = new Set();

        // 单层递归逻辑
        for (let i = startIndex; i < nums.length; i++) {
            const currentNum = nums[i];

            // 剪枝条件1：如果当前元素已经在本层使用过，则跳过
            if (used.has(currentNum)) {
                continue;
            }

            // 剪枝条件2：如果当前路径不为空，且当前元素小于路径最后一个元素，则无法构成递增子序列，跳过
            if (path.length > 0 && currentNum < path[path.length - 1]) {
                continue;
            }

            // 做出选择
            used.add(currentNum); // 标记为已使用
            path.push(currentNum);

            // 递归探索下一个元素，下一次从 i+1 开始
            backtrack(i + 1, path);

            // 回溯：撤销选择
            path.pop();
            // used 不需要回溯，因为它是局部变量，每一层递归都会重新创建
        }
    }

    // 从索引 0 开始启动回溯
    backtrack(0, []);
    
    return result;
};

// --- 示例测试 ---

const nums1 = [4, 6, 7, 7];
console.log(`输入: ${JSON.stringify(nums1)}`);
console.log(`输出: ${JSON.stringify(findSubsequences(nums1))}`);
// 预期输出: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

### 全排序

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

提示：

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

解题思路

1. **问题分析**：我们需要生成一个包含数组所有排列的列表。每个排列都包含原数组的所有元素，且每个元素只出现一次。
2. 回溯法思路：
   - 我们定义一个递归函数 `backtrack(path)`，其中 `path` 存储了当前正在构建的排列。
   - **递归终止条件**：当 `path` 的长度等于原始数组 `nums` 的长度时，说明我们已经成功构建了一个完整的排列。此时，将 `path` 加入到结果集中，并返回。
   - 单层递归逻辑：遍历原始数组 `nums` 中的每一个元素。对于每个元素：
     - **判断是否已使用**：我们需要一个方法来记录哪些元素已经被加入到当前的 `path` 中。这里我们可以使用一个 `used` 数组，`used[i]` 为 `true` 表示 `nums[i]` 已被使用。
     - 如果未使用：
       - **做出选择**：将该元素 `nums[i]` 加入 `path`，并将 `used[i]` 标记为 `true`。
       - **递归探索**：调用 `backtrack(path)` 继续构建下一个位置的元素。
       - **撤销选择（回溯）**：递归调用返回后，将该元素从 `path` 中移除，并将 `used[i]` 标记为 `false`，以便在其他排列中可以再次使用该元素。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const result = []; // 存储所有全排列结果
    const path = [];   // 存储当前正在构建的排列
    const used = new Array(nums.length).fill(false); // 标记元素是否已被使用

    /**
     * 回溯函数
     */
    function backtrack() {
        // 1. 递归终止条件：当前路径长度等于数组长度
        if (path.length === nums.length) {
            result.push([...path]); // 将当前路径的副本加入结果集
            return;
        }

        // 2. 单层递归逻辑：遍历所有元素
        for (let i = 0; i < nums.length; i++) {
            // 剪枝：如果当前元素已被使用，则跳过
            if (used[i]) {
                continue;
            }

            // 做出选择
            used[i] = true; // 标记为已使用
            path.push(nums[i]); // 加入当前路径

            // 递归探索下一个位置
            backtrack();

            // 撤销选择（回溯）
            path.pop(); // 从路径中移除
            used[i] = false; // 取消标记
        }
    }

    // 启动回溯
    backtrack();
    
    return result;
};

// --- 示例测试 ---

const nums1 = [1, 2, 3];
console.log(`输入: ${JSON.stringify(nums1)}`);
console.log(`输出: ${JSON.stringify(permute(nums1))}`);
// 预期输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 全排序Ⅱ

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]

提示：

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

核心思路是：**排序 + 回溯 + 剪枝去重**。通过排序让重复元素相邻，再在回溯中跳过相同元素的重复选择，避免生成重复排列。

1. **排序预处理**：对数组排序，让重复元素相邻，为剪枝做准备；
2. **回溯探索**：用 `path` 记录当前排列，`used` 数组标记元素是否已使用；
3. **剪枝去重**：若当前元素与前一个元素相同，且前一个元素未使用（说明是同一层重复），则跳过当前元素；
4. **递归终止**：当 `path` 长度等于数组长度时，将其加入结果集。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permuteUnique = function(nums) {
    const result = []; // 存储所有不重复的排列
    const path = [];   // 存储当前正在构建的排列
    const used = new Array(nums.length).fill(false); // 标记元素是否已使用

    // 关键步骤：先对数组排序，让重复元素相邻，便于剪枝去重
    nums.sort((a, b) => a - b);

    /**
     * 回溯函数
     */
    function backtrack() {
        // 递归终止条件：当前排列长度等于数组长度
        if (path.length === nums.length) {
            result.push([...path]); // 加入结果集（注意深拷贝）
            return;
        }

        // 遍历所有元素，尝试加入当前排列
        for (let i = 0; i < nums.length; i++) {
            // 剪枝1：元素已使用过，跳过
            if (used[i]) continue;

            // 剪枝2：当前元素与前一个元素相同，且前一个元素未使用（同一层重复），跳过
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) continue;

            // 做出选择：标记元素为已使用，加入当前排列
            used[i] = true;
            path.push(nums[i]);

            // 递归探索下一个位置
            backtrack();

            // 回溯：撤销选择，恢复状态
            path.pop();
            used[i] = false;
        }
    }

    // 启动回溯
    backtrack();
    return result;
};

// 测试示例
const nums = [1, 1, 2];
console.log(permuteUnique(nums));
// 预期输出：[[1,1,2],[1,2,1],[2,1,1]]
```

### 重新安排行程

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

示例 1：

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]

方法思路

1. **图的构建**：首先，我们需要将机票列表转换成一个图的邻接表表示。
   - 我们可以使用一个 `Map`（或对象），其中键是出发机场（`from`），值是一个存储所有到达机场（`to`）的数组。
   - 为了方便地找到字典序最小的路径，我们需要在每次选择下一个目的地时，都优先选择字典序最小的那个。因此，在构建邻接表时，我们可以对每个出发机场的到达机场列表进行 **排序**。
2. **深度优先搜索（DFS）**：
   - 我们从起点 "JFK" 开始进行 DFS。
   - 在每一步，我们从当前机场的邻接表中选择一个目的地（优先选择字典序最小的）。
   - 我们 “使用” 这张机票，即从邻接表中删除或标记这个目的地（这就是回溯的关键）。
   - 然后，我们递归地从这个新的目的地出发，继续探索。
   - 当我们无法继续前进时（即当前机场没有未使用的机票了），我们将当前机场加入到结果路径中。
3. **回溯与路径构建**：
   - DFS 的特性是 “不撞南墙不回头”。当我们走到一条路径的尽头时，这个尽头的机场就是我们行程的最后一站。
   - 我们将其加入结果列表，然后回溯到上一个机场，选择下一个未使用的目的地继续探索。
   - 最终，当所有机票都被使用后，我们得到的结果列表是 **逆序** 的（从最后一站到第一站），因此需要将其反转得到最终答案。

```js
/**
 * @param {string[][]} tickets
 * @return {string[]}
 */
var findItinerary = function(tickets) {
    // 1. 构建图的邻接表
    const graph = new Map();
    
    for (const [from, to] of tickets) {
        if (!graph.has(from)) {
            graph.set(from, []);
        }
        graph.get(from).push(to);
    }

    // 2. 对每个出发地的目的地列表进行排序，以便优先选择字典序小的
    for (const [from, tos] of graph) {
        tos.sort();
    }

    const result = [];

    // 3. 定义 DFS 函数
    // node: 当前所在的机场
    const dfs = (node) => {
        const destinations = graph.get(node);
        
        // 当当前机场还有可到达的目的地时
        while (destinations && destinations.length > 0) {
            // 选择字典序最小的目的地
            const nextNode = destinations.shift();
            // 递归探索下一个目的地
            dfs(nextNode);
        }
        
        // 当没有可去的地方时，将当前机场加入结果（这是路径的最后一站）
        result.push(node);
    };

    // 4. 从 "JFK" 开始深度优先搜索
    dfs("JFK");

    // 5. 因为我们是从最后一站往回加的，所以需要将结果反转
    return result.reverse();
};

// 示例 1:
const tickets1 = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]];
console.log(findItinerary(tickets1));
// 输出: ["JFK","MUC","LHR","SFO","SJC"]
```

### 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。
所以你应该输出 1。

方法思路

为了尽可能满足更多的孩子，我们应该采取以下策略：

1. **排序**：
   - 首先，将孩子们的胃口值 `g` 从小到大进行排序。
   - 然后，将饼干的尺寸 `s` 也从小到大进行排序。
   - 排序的目的是为了让我们能够用最小的饼干去满足最小的胃口，从而留下更大的饼干去满足更大的胃口。
2. **贪心分配**：
   - 我们使用两个指针，`i` 指向当前需要被满足的孩子（从胃口最小的开始），`j` 指向当前可供分配的饼干（从尺寸最小的开始）。
   - 遍历饼干数组：
     - 如果当前饼干 `s[j]` 的尺寸大于或等于当前孩子 `g[i]` 的胃口，那么就把这块饼干分配给这个孩子。此时，我们成功满足了一个孩子，`i` 和 `j` 都向后移动一位。
     - 如果当前饼干 `s[j]` 的尺寸小于当前孩子 `g[i]` 的胃口，那么这块饼干太小了，无法满足任何更贪心的孩子（因为数组是排序好的），所以我们直接放弃这块饼干，`j` 向后移动一位，尝试下一块更大的饼干。
   - 当所有饼干都分配完毕 (`j >= s.length`) 或者所有孩子都被满足 (`i >= g.length`) 时，算法结束。
   - 最终，`i` 的值就是我们能够满足的孩子的最大数量。

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    // 1. 对胃口和饼干尺寸进行排序
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);

    let childIndex = 0; // 指向当前需要被满足的孩子
    let cookieIndex = 0; // 指向当前可供分配的饼干

    // 2. 遍历饼干，尝试满足孩子
    while (childIndex < g.length && cookieIndex < s.length) {
        // 如果当前饼干能满足当前孩子的胃口
        if (s[cookieIndex] >= g[childIndex]) {
            childIndex++; // 孩子被满足，移到下一个孩子
        }
        // 无论饼干是否被使用，都要移到下一块饼干
        cookieIndex++;
    }

    // 3. 成功满足的孩子数量就是 childIndex 的值
    return childIndex;
};

// 示例 1:
const g1 = [1, 2, 3];
const s1 = [1, 1];
console.log(findContentChildren(g1, s1)); // 输出: 1

```

### 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

提示：

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

解题思路：始终保持序列的最后一个 “峰” 尽可能高，或者最后一个 “谷” 尽可能低。这样可以最大化下一次摆动的可能性。

对于摆动序列，我们只关心序列中元素的 “上升” 和 “下降” 趋势的交替变化。我们可以用一个贪心的策略来构建最长的摆动序列：

1. 我们需要记录当前序列的最后一个趋势（是上升还是下降）。
2. 遍历数组，对于每一个新的元素，我们判断它与前一个元素的差值：
   - 如果差值为 0，说明没有变化，我们直接忽略这个元素。
   - 如果差值不为 0，我们判断它的正负（即当前趋势）。
   - 如果当前趋势与上一个趋势**不同**，这说明我们找到了一个新的摆动点。我们将结果长度加一，并更新当前的趋势。
   - 如果当前趋势与上一个趋势**相同**，我们选择 “替换” 掉上一个摆动点。也就是说，我们不增加序列长度，但是更新当前的趋势所对应的最后一个元素为当前元素。这么做的目的是为了给后续的元素提供更大的摆动空间。例如，在序列 `[1, 5, 3, 4]` 中，从 `1->5` (上升)，再到 `5->3` (下降)，这是一个长度为 3 的摆动序列 `[1, 5, 3]`。接下来是 `3->4` (上升)，这个趋势和我们最后记录的趋势（下降）不同，所以序列长度增加到 4，得到 `[1, 5, 3, 4]`。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var wiggleMaxLength = function(nums) {
    // 处理边界情况
    if (nums.length <= 1) {
        return nums.length;
    }

    let maxLength = 1; // 至少有一个元素
    let prevDiff = 0;  // 记录上一个差值

    for (let i = 1; i < nums.length; i++) {
        const currDiff = nums[i] - nums[i - 1];

        // 关键判断：当前差值和上一个差值是否符号相反，并且当前差值不能为0
        // 对于序列开头，prevDiff为0，所以只要currDiff不为0，条件就成立
        if ((currDiff > 0 && prevDiff < 0) || (currDiff < 0 && prevDiff > 0)) {
            maxLength++;
            prevDiff = currDiff; // 只有在摆动时才更新 prevDiff
        } else if (prevDiff === 0 && currDiff !== 0) {
            // 这是序列的第一个摆动
            maxLength++;
            prevDiff = currDiff;
        }
        // 如果 currDiff 和 prevDiff 同号，或者 currDiff 为0，我们什么都不做
    }
    
    return maxLength;
};

// 示例 1
const nums1 = [1, 7, 4, 9, 2, 5];
console.log(wiggleMaxLength(nums1)); // 输出：6
```

### 最大子序和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

示例 1：

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

提示：

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

解题思路：Kadane 算法

Kadane 算法的核心思想是**动态规划**。它通过遍历数组，在每一步都做出一个局部最优的选择，从而最终得到全局最优解。

1. **定义状态**：我们定义 `currentMax` 为以当前元素 `nums[i]` 结尾的最大子数组的和。
2. 状态转移：
   - 将它加入到之前的子数组中，形成一个新的子数组。此时和为 `currentMax + nums[i]`。
   - 从它开始，重新创建一个新的子数组。此时和为 `nums[i]` 本身。
   - 我们选择其中较大的那个作为新的 `currentMax`。即：`currentMax = Math.max(nums[i], currentMax + nums[i])`。
3. **全局最优**：我们用一个变量 `globalMax` 来记录整个遍历过程中 `currentMax` 的最大值。这个 `globalMax` 就是我们要找的答案。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    // 处理边界情况，如果数组为空（根据题目提示，这种情况不会发生）
    if (nums.length === 0) {
        return 0;
    }

    // 初始化当前子数组的最大和以及全局的最大和
    // 都从第一个元素开始
    let currentMax = nums[0];
    let globalMax = nums[0];

    // 从数组的第二个元素开始遍历
    for (let i = 1; i < nums.length; i++) {
        // 核心：对于当前元素，是加入之前的子数组，还是重新开始一个子数组？
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        
        // 更新全局最大和
        if (currentMax > globalMax) {
            globalMax = currentMax;
        }
    }
    
    return globalMax;
};

// 示例 1
const nums1 = [-2, 1, -3, 4, -1, 2, 1, -5, 4];
console.log(maxSubArray(nums1)); // 输出：6
```

### 买股票的最佳时机Ⅱ

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。然而，你可以在 **同一天** 多次买卖该股票，但要确保你持有的股票不超过一股。

返回 你能获得的 **最大** 利润 。

 示例 1：

输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3。
最大总利润为 4 + 3 = 7 。

提示：

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

题思路：贪心算法

这个问题最巧妙的解法是使用**贪心算法**。核心思想是：**只要今天的价格比昨天高，我们就进行一次 “虚拟” 的交易，赚取差价。**

让我们来分析一下示例 `prices = [7,1,5,3,6,4]`：

- 第 2 天价格（1）比第 1 天（7）低，不操作。
- 第 3 天价格（5）比第 2 天（1）高，赚取 `5 - 1 = 4`。
- 第 4 天价格（3）比第 3 天（5）低，不操作。
- 第 5 天价格（6）比第 4 天（3）高，赚取 `6 - 3 = 3`。
- 第 6 天价格（4）比第 5 天（6）低，不操作。

总利润为 `4 + 3 = 7`，与示例结果一致。

为什么这个策略能得到最大利润？

因为股票的价格是波动的，我们无法预测未来。贪心算法的策略是 “见好就收”，抓住每一个微小的上涨机会。虽然在现实中，你不能在同一天既买入又卖出（但题目允许这么做），但这个算法的逻辑等价于：

- 在价格从 `1` 涨到 `5` 的过程中，我们在 `1` 买入，`5` 卖出，利润 `4`。
- 在价格从 `3` 涨到 `6` 的过程中，我们在 `3` 买入，`6` 卖出，利润 `3`。

这个算法的效果和上述理想操作完全一样，但实现起来非常简单。

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let maxProfit = 0;
    
    // 从第二天开始遍历
    for (let i = 1; i < prices.length; i++) {
        // 如果今天的价格比昨天高，就把差价加到总利润里
        if (prices[i] > prices[i - 1]) {
            maxProfit += prices[i] - prices[i - 1];
        }
    }
    
    return maxProfit;
};

// 示例 1
const prices1 = [7, 1, 5, 3, 6, 4];
console.log(maxProfit(prices1)); // 输出：7
```

### 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

示例 ：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

提示：

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

解题思路：贪心算法

解决这个问题的最佳思路是使用**贪心算法**。贪心算法的核心思想是在每一步都做出在当前看来是最好的选择，从而希望导致全局最优解。

具体到这个问题，我们可以跟踪一个变量 `maxReach`，它表示我们从当前位置出发能够到达的**最远索引**。

1. **初始化**：`maxReach = 0`。
2. **遍历数组**：我们遍历数组中的每个索引 `i`。
3. **更新最远可达距离**：对于每个索引 `i`，计算从当前位置 `i` 出发能够到达的最远距离 `i + nums[i]`。如果这个距离大于当前的 `maxReach`，就更新 `maxReach`。
4. **检查是否能到达终点**：在遍历过程中，如果 `maxReach` 已经大于或等于数组的最后一个索引，我们可以直接返回 `true`，因为我们已经证明可以到达终点了。
5. **检查是否卡住**：如果在遍历过程中，发现当前索引 `i` 已经超过了 `maxReach`，这说明我们无法到达当前位置，更不可能到达后面的位置，因此返回 `false`。

**贪心策略的体现**：我们不需要关心到达 `maxReach` 这个最远点的具体路径，只需要知道我们**可以**到达那里。然后，我们基于这个最远点，继续探索更远的地方。

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    // 初始化能够到达的最远距离
    let maxReach = 0;
    const n = nums.length;

    for (let i = 0; i < n; i++) {
        // 如果当前位置已经超过了能到达的最远距离，则无法再前进，返回 false
        if (i > maxReach) {
            return false;
        }
        
        // 更新能够到达的最远距离
        maxReach = Math.max(maxReach, i + nums[i]);
        
        // 如果最远距离已经覆盖了最后一个索引，直接返回 true
        if (maxReach >= n - 1) {
            return true;
        }
    }

    // 循环结束后，检查是否能到达终点（理论上循环内应该已经返回）
    return maxReach >= n - 1;
};

// 示例 1
const nums1 = [2, 3, 1, 1, 4];
console.log(canJump(nums1)); // 输出：true
```

### 跳跃游戏 II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

提示:

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `n - 1`

问题分析

给定一个非负整数数组 `nums`，你最初在索引 `0` 的位置。

- 如果你在索引 `i`，你可以跳转到任意一个索引 `j`，只要 `j <= i + nums[i]` 且 `j < nums.length`。
- 题目保证你总能到达最后一个索引 `nums.length - 1`。
- 你需要计算到达最后一个索引所需的**最少跳跃次数**。

解题思路：贪心算法

这个问题同样可以使用**贪心算法**来高效解决。核心思想是：**在每一步跳跃中，都选择能让我们在下一步跳得最远的那个位置。**

我们可以通过跟踪两个关键变量来实现这个策略：

1. `currentEnd`：表示当前这一轮跳跃所能到达的最远边界。
2. `farthest`：表示在当前这一轮跳跃的所有可选位置中，能够到达的最远位置。
3. `jumps`：记录跳跃的总次数。

算法步骤：

1. 初始化 `jumps = 0`，`currentEnd = 0`，`farthest = 0`。
2. **遍历数组**：`for (let i = 0; i < n - 1; i++)`。注意循环条件是 `i < n - 1`，因为当 `i` 等于 `n-1` 时，我们已经到达终点，不需要再计算跳跃了。
3. **更新最远点**：`farthest = Math.max(farthest, i + nums[i]);`。在每次循环中，我们都计算从当前位置 `i` 能跳到的最远距离，并更新全局的 `farthest`。
4. **触发跳跃**：`if (i === currentEnd)`。当 `i` 走到当前跳跃的边界 `currentEnd` 时，意味着我们必须做出选择并进行一次跳跃了。
   - `jumps++`：跳跃次数加一。
   - `currentEnd = farthest`：将下一次跳跃的边界更新为我们目前能看到的最远距离 `farthest`。这代表着我们选择了能让下一轮跳得最远的那个点作为起跳点。
   - `if (currentEnd >= n - 1) break;`：一个优化，如果新的边界已经超过或等于终点，我们就可以提前结束循环了。
5. **返回结果**：循环结束后，`jumps` 就是到达终点所需的最小跳跃次数。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    let jumps = 0;
    let currentEnd = 0;
    let farthest = 0;
    const n = nums.length;

    // 我们只需要遍历到倒数第二个元素
    for (let i = 0; i < n - 1; i++) {
        // 更新在当前跳跃范围内能到达的最远距离
        farthest = Math.max(farthest, i + nums[i]);

        // 如果到达了当前跳跃的边界，就必须进行一次新的跳跃
        if (i === currentEnd) {
            jumps++;
            // 更新下一次跳跃的边界
            currentEnd = farthest;

            // 提前退出，如果当前边界已经覆盖终点
            if (currentEnd >= n - 1) {
                break;
            }
        }
    }

    return jumps;
};

// 示例 1
const nums1 = [2, 3, 1, 1, 4];
console.log(jump(nums1)); // 输出：2
```

### K次取反后最大化的数组和

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

示例 1：

输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。

提示：

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`

解题思路

1. **贪心策略**：要最大化数组的和，我们应该尽可能地将数组中的负数翻转为正数，因为这会直接增加数组的总和。
2. **处理所有负数**：首先，遍历数组，将所有的负数翻转为正数，直到没有负数可翻或者已经翻转了 `k` 次。
3. 处理剩余的翻转次数：
   - 如果 `k` 是偶数，那么剩余的翻转次数可以通过翻转同一个元素两次来抵消，数组的和不会改变。
   - 如果 `k` 是奇数，那么数组中会有一个元素被多翻转一次。为了最小化对总和的损失，我们应该选择数组中绝对值最小的元素进行翻转。

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var largestSumAfterKNegations = function(nums, k) {
    // 1. 按照绝对值从小到大排序，这样可以优先翻转绝对值较小的负数，或者在最后翻转最小的数
    nums.sort((a, b) => Math.abs(a) - Math.abs(b));
    
    // 2. 遍历数组，将负数翻转为正数
    for (let i = 0; i < nums.length && k > 0; i++) {
        if (nums[i] < 0) {
            nums[i] = -nums[i];
            k--;
        }
    }
    
    // 3. 如果还有剩余的翻转次数，且为奇数，翻转数组中最小的元素
    if (k % 2 === 1) {
        nums.sort((a, b) => a - b); // 从小到大排序
        nums[0] = -nums[0];
    }
    
    // 4. 计算数组的和
    return nums.reduce((sum, num) => sum + num, 0);
};

// 示例 1
const nums1 = [4, 2, 3];
const k1 = 1;
console.log(largestSumAfterKNegations(nums1, k1)); // 输出：5
```

### 加油站

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

示例 1:

输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

提示:

- `n == gas.length == cost.length`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`
- 输入保证答案唯一。

问题分析

给定两个数组 `gas` 和 `cost`：

- `gas[i]` 表示第 `i` 个加油站可以提供的汽油量。
- `cost[i]` 表示从第 `i` 个加油站开往第 `i+1` 个加油站（或绕环后从第 `n-1` 个开往第 `0` 个）所消耗的汽油量。

汽车的油箱容量无限。你需要从某个加油站出发，初始油箱为空。在行驶过程中，油箱里的汽油量不能为负数。

解题思路：贪心算法

解决这个问题的关键 insight 是：

1. **全局可行性**：如果所有加油站的总汽油量 `sum(gas)` 小于总消耗量 `sum(cost)`，那么无论从哪个加油站出发，都**不可能**绕环一周。此时直接返回 `-1`。
2. 局部最优解：如果存在解，那么这个解是唯一的。我们可以通过一次遍历找到这个起始点。
   - 我们维护一个变量 `currentTank`，表示当前油箱里的汽油量。
   - 我们从索引 `0` 开始模拟行驶：
     - 到达第 `i` 个加油站，加上 `gas[i]`。
     - 开往第 `i+1` 个加油站，减去 `cost[i]`。
     - 如果在某个时刻 `currentTank` 变为负数，这说明从我们上一个假设的起始点 `start` 到当前位置 `i` 的这段路程是不可行的。我们必须将起始点重新设置为 `i+1`，并将 `currentTank` 重置为 `0`。因为如果从 `start` 到 `i` 都走不通，那么从 `start` 和 `i` 之间的任何一个点出发，也必然走不通 `i` 这个位置。

```js
/**
 * @param {number[]} gas
 * @param {number[]} cost
 * @return {number}
 */
var canCompleteCircuit = function(gas, cost) {
    const n = gas.length;
    let totalGas = 0;
    let totalCost = 0;
    let currentTank = 0;
    let startStation = 0;

    for (let i = 0; i < n; i++) {
        // 计算总汽油和总消耗，用于最后判断全局可行性
        totalGas += gas[i];
        totalCost += cost[i];

        // 模拟从当前startStation出发，行驶到下一个站后的油箱状态
        currentTank += gas[i] - cost[i];

        // 如果当前油箱油量为负，说明从startStation到i这段路走不通
        // 必须从i+1开始重新尝试
        if (currentTank < 0) {
            startStation = i + 1;
            currentTank = 0; // 重置油箱
        }
    }

    // 最后检查全局是否有解。如果有解，startStation就是唯一的解
    return totalGas >= totalCost ? startStation : -1;
};

// 示例 1
const gas1 = [1, 2, 3, 4, 5];
const cost1 = [3, 4, 5, 1, 2];
console.log(canCompleteCircuit(gas1, cost1)); // 输出：3
```

### 分发糖果

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子中，评分更高的那个会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

示例 1：

输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

解题思路：要解决这个问题，核心是满足两个条件：每个孩子至少 1 颗糖果；相邻孩子中评分高的获得更多糖果。直接同时处理两个条件容易顾此失彼，因此采用**两次遍历**的贪心策略，分别满足单侧约束，最终合并结果。

1. **第一次遍历（从左到右）**：确保每个孩子的糖果数不小于其**左边**评分更低的孩子。
   - 初始化一个与评分数组等长的糖果数组 `candies`，所有元素为 1（满足至少 1 颗糖果的基本要求）。
   - 从左到右遍历，若当前孩子的评分大于左边孩子，则当前孩子的糖果数 = 左边孩子的糖果数 + 1。
   - 此时，数组仅满足 “左邻居约束”，但可能存在 “右邻居评分更高但糖果数更少” 的情况（例如 `[3, 2, 1]` 遍历后为 `[1, 1, 1]`，未满足右邻居约束）。
2. **第二次遍历（从右到左）**：确保每个孩子的糖果数不小于其**右边**评分更低的孩子。
   - 从右到左遍历，若当前孩子的评分大于右边孩子，则当前孩子的糖果数 = max (当前糖果数，右边孩子的糖果数 + 1)。
   - 这一步会修正第一次遍历的不足，同时保留已满足的左邻居约束（例如 `[3, 2, 1]` 第二次遍历后变为 `[3, 2, 1]`）。
3. **计算总糖果数**：遍历糖果数组，累加所有元素之和，即为最少需要准备的糖果数目。

```js
/**
 * @param {number[]} ratings
 * @return {number}
 */
var candy = function(ratings) {
    const n = ratings.length;
    const candies = new Array(n).fill(1); // 初始化每个孩子1颗糖果

    // 第一次遍历：从左到右，满足左邻居约束
    for (let i = 1; i < n; i++) {
        if (ratings[i] > ratings[i - 1]) {
            candies[i] = candies[i - 1] + 1;
        }
    }

    // 第二次遍历：从右到左，满足右邻居约束
    for (let i = n - 2; i >= 0; i--) {
        if (ratings[i] > ratings[i + 1]) {
            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
        }
    }

    // 计算总糖果数
    return candies.reduce((sum, val) => sum + val, 0);
};
```

### 柠檬水找零

解题思路：这个问题可以用**贪心算法**来解决。贪心算法的核心思想是，在每一步都做出当前看来最优的选择，从而希望最终能得到全局最优解。

在找零问题中，“最优选择” 意味着**优先使用面值较大的钞票进行找零**。这样做的好处是尽可能地保留面值较小的钞票（这里是 5 美元），因为小面值的钞票在未来的找零场景中更常用、更灵活。

具体来说，我们需要处理三种顾客支付的情况：

1. **顾客支付 5 美元**：这是最简单的情况。我们不需要找零，只需将手头的 5 美元钞票数量加一。

2. **顾客支付 10 美元**：我们需要找给顾客 5 美元。因此，我们必须检查手头是否至少有一张 5 美元的钞票。

   - 如果有，就找零，将 5 美元的数量减一，同时将 10 美元的数量加一。
   - 如果没有，就无法找零，直接返回 `false`。

3. **顾客支付 20 美元**：我们需要找给顾客 15 美元。这里有两种找零组合：

   - **一张 10 美元 + 一张 5 美元** (优先选择)
   - **三张 5 美元**

   根据贪心策略，我们应该优先尝试第一种组合，因为 10 美元的钞票用途相对单一（只能在找零 20 美元时使用），而 5 美元的钞票用途更广。

   - 首先检查是否有 10 美元和 5 美元的钞票。如果都有，就用掉它们。
   - 如果第一种组合不可行，再检查是否有至少三张 5 美元的钞票。如果有，就用掉三张 5 美元。
   - 如果两种组合都无法满足，就无法找零，返回 `false`。

我们只需要用两个变量来跟踪手头 5 美元和 10 美元钞票的数量即可（20 美元的钞票因为面额太大，无法用于找零，所以无需记录）。

```js
/**
 * @param {number[]} bills
 * @return {boolean}
 */
var lemonadeChange = function(bills) {
    // 初始化手头 5 美元和 10 美元钞票的数量
    let five = 0;
    let ten = 0;

    for (const bill of bills) {
        if (bill === 5) {
            // 情况1：收到5美元，无需找零
            five++;
        } else if (bill === 10) {
            // 情况2：收到10美元，需要找零5美元
            if (five > 0) {
                five--;
                ten++;
            } else {
                // 没有5美元可找零
                return false;
            }
        } else if (bill === 20) {
            // 情况3：收到20美元，需要找零15美元
            // 贪心策略：优先使用 10+5 的组合
            if (ten > 0 && five > 0) {
                ten--;
                five--;
            } else if (five >= 3) {
                // 如果没有10美元，则使用三张5美元
                five -= 3;
            } else {
                // 两种组合都无法满足
                return false;
            }
        }
    }

    // 如果所有顾客都成功找零，则返回true
    return true;
};
```

### 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

示例 1：

 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

提示：

- `1 <= people.length <= 2000`
- `0 <= hi <= 106`
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建

解题思路

这道题的核心在于如何正确地排列这些人，使得每个人前面都有正好 `ki` 个身高大于或等于他的人。

直接思考如何排序整个队列是比较复杂的。我们可以换个角度，**从高到矮**来构建这个队列。

1. **排序规则**：

   - 首先，按照身高 `hi` **从高到低**排序。
   - 如果两个人身高相同，那么按照 `ki` **从小到大**排序。

   **为什么要这样排序？**

   - **从高到低排**：当我们处理一个人时，所有比他高或和他一样高的人都已经被安排好了位置。这时候，他的 `ki` 值就直接告诉我们他应该站在当前队列的哪个位置。因为他前面需要有 `ki` 个更高或一样高的人，而这些人已经都在队列里了。
   - **身高相同，ki 小的在前**：假设两个人身高都是 7，A 的 `ki` 是 0，B 的 `ki` 是 1。如果我们先放 B，那么 B 会放在队列的第 0 位。接下来放 A 时，A 的 `ki` 是 0，也想放在第 0 位，这就会把 B 挤到第 1 位。最终队列是 `[A, B]`，这是正确的。如果我们先放 A，A 在第 0 位，然后放 B，B 的 `ki` 是 1，就会放在第 1 位。结果也是 `[A, B]`。两种顺序结果一样。但为了逻辑统一和代码简洁，我们规定相同身高时 `ki` 小的先处理。

2. **构建队列**：

   - 创建一个空的结果数组 `queue`。
   - 遍历排好序的 `people` 数组。
   - 对于每一个人 `p`，将他插入到 `queue` 数组的第 `p[1]` 个位置。

   **为什么可以直接插入？**因为我们是从高到低处理的，`queue` 里已有的人都比当前人高或一样高。所以，把当前人放在第 `p[1]` 个位置，就保证了他前面恰好有 `p[1]` 个比他高或一样高的人。而他后面的人因为是后处理的，要么比他矮，要么一样高但 `ki` 更大，所以插入操作不会影响后续的正确性。

```js
/**
 * @param {number[][]} people
 * @return {number[][]}
 */
var reconstructQueue = function(people) {
    // 1. 按照身高从高到低排序，如果身高相同，ki小的在前
    people.sort((a, b) => {
        if (b[0] !== a[0]) {
            return b[0] - a[0]; // 身高降序
        } else {
            return a[1] - b[1]; // ki值升序
        }
    });

    const queue = [];
    
    // 2. 遍历排序后的数组，按照ki值将每个人插入到对应的位置
    for (const p of people) {
        queue.splice(p[1], 0, p);
    }

    return queue;
};

// 示例 1
const people1 = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]];
console.log(reconstructQueue(people1));
// 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
```

### 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。

提示:

- `1 <= points.length <= 105`
- `points[i].length == 2`
- `-231 <= xstart < xend <= 231 - 1`

解题思路

要让一支箭引爆更多气球，关键是让气球的 “重叠区域” 尽可能集中。具体步骤如下：

1. **排序规则**：按气球的 `xend`（右边界）从小到大排序。
   - 为什么按右边界排序？因为我们希望每支箭射在当前气球的右边界上 —— 这样可以最大限度覆盖后续可能重叠的气球（后续气球的左边界如果≤当前右边界，就能被这支箭引爆）。
   - 比如：气球 `[1,6]` 和 `[2,8]`，按右边界排序后是 `[1,6]` 在前，箭射在 6 处，既能引爆第一个，也能引爆第二个（2≤6≤8）。
2. **贪心选择**：
   - 初始化弓箭数 `count = 1`（至少需要一支箭），并记录第一支箭的射击位置 `arrowPos = points[0][1]`（第一支箭射在第一个气球的右边界）。
   - 遍历后续气球：
     - 如果当前气球的 `xstart ≤ arrowPos`：说明该气球与前一个气球重叠，当前箭可以同时引爆它，无需新增箭。
     - 如果当前气球的 `xstart > arrowPos`：说明该气球与前一个气球不重叠，需要新增一支箭，且新箭的射击位置设为当前气球的 `xend`（最大化覆盖后续气球）。

关键细节

- 排序时必须按 **右边界升序**，不能按左边界（会导致重叠区域判断不准确）。
- 处理边界重合：比如气球 `[1,2]` 和 `[2,3]`，`x=2` 同时在两个气球的区间内，一支箭即可引爆，排序后右边界 2 在前，箭射在 2 处正好覆盖两者。

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    if (points.length === 0) return 0;

    // 1. 按气球的右边界 xend 从小到大排序
    points.sort((a, b) => a[1] - b[1]);

    let count = 1; // 至少需要一支箭
    let arrowPos = points[0][1]; // 第一支箭射在第一个气球的右边界

    // 2. 遍历后续气球，判断是否需要新增箭
    for (let i = 1; i < points.length; i++) {
        const [xstart] = points[i];
        // 如果当前气球的左边界 > 箭的位置，说明不重叠，需要新增箭
        if (xstart > arrowPos) {
            count++;
            arrowPos = points[i][1]; // 新箭射在当前气球的右边界
        }
        // 否则，当前箭可以引爆该气球，无需操作
    }

    return count;
};

// 示例测试
console.log(findMinArrowShots([[10,16],[2,8],[1,6],[7,12]])); // 输出 2
console.log(findMinArrowShots([[1,2],[3,4],[5,6],[7,8]])); // 输出 4
console.log(findMinArrowShots([[1,2],[2,3],[3,4],[4,5]])); // 输出 2
```

### 无重叠区间

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

示例 1:

输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。

提示:

- `1 <= intervals.length <= 105`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 104`

解题思路

要保留最多不重叠区间，关键是让每个保留的区间「尽可能早地结束」，这样才能给后续区间留出更多空间。具体步骤如下：

1. **排序规则**：按区间的 `endi`（右边界）从小到大排序。
   - 为什么按右边界排序？因为右边界越早，后续能容纳的区间就越多。比如：区间 `[1,2]` 和 `[1,3]`，保留 `[1,2]`（右边界更早），后续能容纳 `[2,3]`；但如果保留 `[1,3]`，就无法容纳 `[2,3]` 了。
2. **贪心选择**：
   - 初始化：保留的区间数量 `count = 1`（至少能保留一个区间），记录当前保留区间的右边界 `lastEnd = intervals[0][1]`（第一个区间的右边界）。
   - 遍历后续区间：
     - 如果当前区间的 `starti >= lastEnd`：说明当前区间和上一个保留的区间不重叠（题目规定「只在一点接触不算重叠」），可以保留该区间。更新 `count` 加 1，同时更新 `lastEnd` 为当前区间的右边界。
     - 如果当前区间的 `starti < lastEnd`：说明当前区间和上一个保留的区间重叠，必须移除该区间（不更新 `count` 和 `lastEnd`）。
3. **计算需要移除的数量**：总区间数 - 保留的区间数 = 需要移除的区间数。

关键细节

- 排序时必须按「右边界升序」，不能按左边界（会导致保留的区间结束过晚，浪费空间）。
- 边界判断：`starti >= lastEnd` 才是不重叠（比如 `[1,2]` 和 `[2,3]`，`starti=2 == lastEnd=2`，不算重叠，可保留）。
- 处理重复区间：比如 `[[1,2],[1,2],[1,2]]`，排序后右边界相同，遍历到第二个和第三个区间时，`starti=1 < lastEnd=2`，都会被移除，最终保留 1 个，需要移除 2 个（符合示例 2）。

```js
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    if (intervals.length === 0) return 0;

    // 1. 按区间的右边界 endi 从小到大排序（核心）
    intervals.sort((a, b) => a[1] - b[1]);

    let keepCount = 1; // 保留的不重叠区间数量
    let lastEnd = intervals[0][1]; // 上一个保留区间的右边界

    // 2. 遍历后续区间，判断是否重叠
    for (let i = 1; i < intervals.length; i++) {
        const [currentStart] = intervals[i];
        // 当前区间的左边界 >= 上一个保留区间的右边界 → 不重叠，保留
        if (currentStart >= lastEnd) {
            keepCount++;
            lastEnd = intervals[i][1]; // 更新右边界为当前区间的右边界
        }
        // 重叠则跳过（移除该区间）
    }

    // 3. 需要移除的数量 = 总区间数 - 保留的数量
    return intervals.length - keepCount;
};

// 示例测试
console.log(eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]])); // 输出 1
console.log(eraseOverlapIntervals([[1,2],[1,2],[1,2]])); // 输出 2
console.log(eraseOverlapIntervals([[1,2],[2,3]])); // 输出 0
```

### 划分字母区间

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 `"ababcc"` 能够被分为 `["abab", "cc"]`，但类似 `["aba", "bcc"]` 或 `["ab", "ab", "cc"]` 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

示例 1：

输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 

提示：

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

解题思路

要让同一字母只出现在一个片段，关键是知道每个字母的「最后一次出现位置」—— 片段的右边界必须至少覆盖到当前片段中所有字符的最后出现位置，否则会有字符跨片段。具体步骤如下：

1. **预处理：记录每个字符的最后出现位置**用一个哈希表（或数组，因为字符是小写字母，共 26 个）存储每个字符在字符串中最后一次出现的索引。比如 `s = "ababcbacadefegdehijhklij"`，`a` 的最后位置是 8，`b` 是 5，`c` 是 7 等。
2. **贪心划分片段**
   - 初始化：`start = 0`（当前片段的起始索引），`end = 0`（当前片段的最小右边界，需要覆盖到当前片段所有字符的最后出现位置）。
   - 遍历字符串的每个字符：
     - 对于当前字符 `s[i]`，更新 `end` 为 `max(end, 最后出现位置[s[i]])` —— 确保当前片段的右边界能覆盖到 `s[i]` 的最后一次出现（否则 `s[i]` 会跨片段）。
     - 当 `i == end` 时：说明当前片段的右边界已经确定（所有字符的最后出现位置都在 `[start, end]` 内），可以划分出一个片段。记录片段长度 `end - start + 1`，并更新 `start = end + 1`（开启下一个片段）。

关键逻辑

- 为什么要找「最后出现位置」？因为如果片段的右边界没到字符的最后出现位置，这个字符后续还会出现，就会跨片段，违反规则。
- 为什么 `i == end` 时划分？此时当前片段的所有字符的最后出现位置都已被覆盖（`end` 是当前片段所有字符最后出现位置的最大值），再往后遍历会包含新的字符，必须划分。

```js
/**
 * @param {string} s
 * @return {number[]}
 */
var partitionLabels = function(s) {
    // 1. 预处理：记录每个字符的最后出现位置（用数组比对象更高效，小写字母对应 0-25）
    const lastPos = new Array(26).fill(0);
    for (let i = 0; i < s.length; i++) {
        // 字符转索引：a->0, b->1, ..., z->25
        const charIndex = s.charCodeAt(i) - 'a'.charCodeAt(0);
        lastPos[charIndex] = i; // 更新为最后出现的索引
    }

    const result = [];
    let start = 0; // 当前片段的起始索引
    let end = 0;   // 当前片段的最小右边界

    // 2. 遍历字符串，贪心划分片段
    for (let i = 0; i < s.length; i++) {
        const charIndex = s.charCodeAt(i) - 'a'.charCodeAt(0);
        // 更新 end 为当前片段所有字符的最后出现位置的最大值
        end = Math.max(end, lastPos[charIndex]);

        // 当 i 到达 end 时，说明当前片段可以划分（所有字符的最后出现位置都在 [start, end] 内）
        if (i === end) {
            result.push(end - start + 1); // 片段长度
            start = end + 1; // 开启下一个片段
        }
    }

    return result;
};

// 示例测试
console.log(partitionLabels("ababcbacadefegdehijhklij")); // 输出 [9,7,8]
console.log(partitionLabels("eccbbbbdec")); // 输出 [10]
```

### 合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

示例 1：

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

提示：

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

这道题的核心思路是 **排序 + 贪心合并**：先按区间的起始位置排序，再依次合并重叠或相邻的区间，最终得到不重叠的区间数组。

解题思路

1. **排序**：将所有区间按起始位置 `starti` 从小到大排序。排序后，重叠的区间会相邻，便于后续合并。
2. 合并：
   - 初始化结果数组，将第一个区间加入结果；
   - 遍历后续区间，与结果数组的最后一个区间比较：
     - 如果当前区间的起始位置 ≤ 结果最后一个区间的结束位置 → 重叠，合并这两个区间（更新结果最后一个区间的结束位置为两者的最大值）；
     - 如果当前区间的起始位置 > 结果最后一个区间的结束位置 → 不重叠，直接将当前区间加入结果数组。

关键逻辑

- **排序的作用**：让重叠或相邻的区间集中在一起，只需依次比较当前区间与结果最后一个区间，无需回溯。
- **合并条件**：当前区间的 `starti` ≤ 结果最后一个区间的 `endi`（包括相邻情况，如 `[1,4]` 和 `[4,5]`）。

```js
/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if (intervals.length === 0) return [];

    // 1. 按区间的起始位置从小到大排序
    intervals.sort((a, b) => a[0] - b[0]);

    const merged = [intervals[0]]; // 初始化结果数组

    // 2. 遍历后续区间，合并重叠部分
    for (let i = 1; i < intervals.length; i++) {
        const last = merged[merged.length - 1]; // 结果数组的最后一个区间
        const current = intervals[i];

        if (current[0] <= last[1]) {
            // 重叠，合并区间：更新结束位置为两者的最大值
            last[1] = Math.max(last[1], current[1]);
        } else {
            // 不重叠，直接加入结果数组
            merged.push(current);
        }
    }

    return merged;
};

// 示例测试
console.log(merge([[1,3],[2,6],[8,10],[15,18]])); // 输出 [[1,6],[8,10],[15,18]]
console.log(merge([[1,4],[4,5]])); // 输出 [[1,5]]
console.log(merge([[4,7],[1,4]])); // 输出 [[1,7]]
```

### 单调递增的数字

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

示例 1:

输入: n = 10
输出: 9

提示:

- `0 <= n <= 109`

解题思路：这道题的核心思路是 **贪心算法 + 字符串处理**：通过从后往前检查数字的单调性，找到第一个违反递增规则的位置，将其减 1 并把后面的所有数字置为 9，最终得到符合要求的最大数。

1. **转换为字符数组**：将数字 `n` 转为字符数组，方便逐位操作（比如修改某一位的值）。
2. **从后往前检查单调性**：遍历字符数组，找到第一个位置 `i` 满足 `digits[i] > digits[i+1]`（违反递增规则）。
3. **调整数字**：将 `digits[i]` 减 1，并把 `i` 后面的所有数字置为 9（这样能保证后面的数字尽可能大，同时整体满足递增）。
4. **处理连续递减的情况**：调整后可能需要往前回溯（比如 `332` 调整后变成 `299`，需要检查前面的位是否仍违反规则）。
5. **转换回数字**：将调整后的字符数组转为数字（注意前导零会被自动忽略）。

关键逻辑：

- 为什么要从后往前检查？因为我们需要找到最右侧的违反位置，调整后能保证前面的数字尽可能大。
- 为什么后面的数字置为 9？比如 `332`，找到 `i=1`（`3 > 2`），将 `digits[1]` 减 1 变为 `2`，后面的 `2` 置为 `9`，得到 `299`（这是小于 332 的最大递增数）。

```js
/**
 * @param {number} n
 * @return {number}
 */
var monotoneIncreasingDigits = function(n) {
    const nums = n.toString().split('')
    let i = nums.length - 2
    // 找到第一个违反递增的位置
    while (i >= 0 && nums[i] <= nums[i+1]) {
        i--
    }
    if (i >= 0) {
        // 把i位置减1
        nums[i] = (Number(nums[i]) - 1).toString()
        // 把i之后的位置设为9
        for (let j = i + 1; j < nums.length; j++) {
            nums[j] = '9'
        }
        // 可能需要再次检查前面的位（比如减1后又违反）
        return monotoneIncreasingDigits(Number(nums.join('')))
    }
    return n
};

// 示例测试
console.log(monotoneIncreasingDigits(10)); // 输出 9
console.log(monotoneIncreasingDigits(1234)); // 输出 1234
console.log(monotoneIncreasingDigits(332)); // 输出 299
console.log(monotoneIncreasingDigits(132)); // 输出 129
console.log(monotoneIncreasingDigits(100)); // 输出 99
```

### 监控二叉树

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

示例 1：![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。

示例 2：![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
提示：

1. 给定树的节点数的范围是 `[1, 1000]`。
2. 每个节点的值都是 0。

方法思路：要解决二叉树监控的最小摄像头问题，核心思路是**后序遍历 + 状态标记**，通过自底向上推导每个节点的最优监控状态，从而最小化摄像头数量。

每个节点有三种状态：

- **状态 0**：节点未被监控（需要父节点覆盖）。
- **状态 1**：节点已被监控（无需父节点覆盖）。
- **状态 2**：节点安装了摄像头（能覆盖父、自身、子节点）。

通过后序遍历，我们从叶子节点向上推导：

1. **叶子节点**：优先设为状态 0（让父节点覆盖，节省摄像头）。
2. **子节点有状态 0**：当前节点必须装摄像头（状态 2），否则子节点无法被覆盖。
3. **子节点有状态 2**：当前节点被覆盖（状态 1）。
4. **子节点均为状态 1**：当前节点设为状态 0（让父节点覆盖）。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minCameraCover = function(root) {
    let result = 0;

    // 后序遍历，返回当前节点的状态：0未覆盖，1已覆盖，2有摄像头
    const traversal = (node) => {
        // 空节点默认已覆盖（无需处理）
        if (!node) return 1;

        const left = traversal(node.left);
        const right = traversal(node.right);

        // 情况1：子节点有未覆盖的，当前节点必须装摄像头
        if (left === 0 || right === 0) {
            result++;
            return 2;
        }

        // 情况2：子节点有摄像头，当前节点已覆盖
        if (left === 2 || right === 2) {
            return 1;
        }

        // 情况3：子节点均已覆盖，当前节点设为未覆盖（让父节点处理）
        return 0;
    };

    // 根节点若未覆盖，需额外装一个摄像头
    if (traversal(root) === 0) {
        result++;
    }

    return result;
};
```

### 斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1

提示：

- `0 <= n <= 30`

方法一：迭代法

利用循环从底向上计算，只保留前两项的值，空间复杂度为 O (1)，时间复杂度为 O (n)。

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    
    let a = 0, b = 1; // a=F(n-2), b=F(n-1)
    for (let i = 2; i <= n; i++) {
        const c = a + b; // F(n) = F(n-1) + F(n-2)
        a = b; // 更新 F(n-2) 为 F(n-1)
        b = c; // 更新 F(n-1) 为 F(n)
    }
    return b;
};

// 测试
console.log(fib(2)); // 1
console.log(fib(3)); // 2
console.log(fib(4)); // 3
console.log(fib(30)); // 832040
```

方法二：递归法

直接根据定义递归计算，但会存在大量重复计算（比如计算 F (5) 时会重复计算 F (3)、F (2) 等），时间复杂度为 O (2ⁿ)，空间复杂度为 O (n)（递归栈深度）。

```js
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n, memo = {}) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    if (memo[n]) return memo[n]; // 缓存中存在则直接返回
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo); // 计算并缓存
    return memo[n];
};

// 测试
console.log(fib(2)); // 1
console.log(fib(3)); // 2
console.log(fib(30)); // 832040
```

### 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶

提示：

- `1 <= n <= 45`

解题思路

1. **状态定义**：设 `dp[i]` 表示爬到第 `i` 阶的不同方法数。
2. **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`（最后一步爬 1 阶或 2 阶）。
3. 初始条件：
   - `dp[1] = 1`（只有 1 阶，只能爬 1 阶）；
   - `dp[2] = 2`（2 阶可以爬两次 1 阶或一次 2 阶）。

方法一：迭代法

无需存储完整的 dp 数组，只需保留前两项的值，时间复杂度 O (n)，空间复杂度 O (1)。

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n === 1) return 1;
    if (n === 2) return 2;
    
    let a = 1, b = 2; // a=dp[i-2], b=dp[i-1]
    for (let i = 3; i <= n; i++) {
        const c = a + b; // dp[i] = dp[i-1] + dp[i-2]
        a = b;
        b = c;
    }
    return b;
};

// 测试
console.log(climbStairs(2)); // 2
console.log(climbStairs(3)); // 3
console.log(climbStairs(4)); // 5
console.log(climbStairs(45)); // 1836311903
```

方法二：递归法（简洁但效率低）

直接根据状态转移方程递归，但存在大量重复计算，时间复杂度 O (2ⁿ)，空间复杂度 O (n)（递归栈）。

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n === 1) return 1;
    if (n === 2) return 2;
    return climbStairs(n - 1) + climbStairs(n - 2);
};
```

方法三：动态规划（数组存储）

用数组存储每一步的结果，直观易懂，时间复杂度 O (n)，空间复杂度 O (n)。

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n === 1) return 1;
    const dp = new Array(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
};
```

### 使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

提示：

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

解题思路

1. **状态定义**：设 `dp[i]` 表示**到达第 `i` 个台阶的最低花费**（注意：到达台阶后还未支付费用，支付费用后才能爬 1 或 2 阶）。
2. 状态转移方程：
   - 要到达第 `i` 个台阶，只能从 `i-1` 或 `i-2` 台阶爬上来：
     - 从 `i-1` 台阶来：需支付 `cost[i-1]`，总花费为 `dp[i-1] + cost[i-1]`；
     - 从 `i-2` 台阶来：需支付 `cost[i-2]`，总花费为 `dp[i-2] + cost[i-2]`；
   - 因此，`dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`。
3. 初始条件：
   - 可以选择从 0 或 1 台阶开始，所以到达 0 或 1 台阶的初始花费为 0（`dp[0] = 0`，`dp[1] = 0`）。
4. **最终目标**：楼梯顶部对应下标为 `cost.length`（比如 `cost` 长度为 3 时，顶部是下标 3），所以结果为 `dp[cost.length]`。

关键逻辑

- 楼梯顶部不是最后一个台阶（`cost[cost.length-1]`），而是最后一个台阶的下一个位置（下标 `cost.length`）。
- 支付台阶 `i` 的费用后，才能从 `i` 爬向 `i+1` 或 `i+2`。

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    const n = cost.length;
    const dp = new Array(n + 1); // dp[i]表示到达第i个台阶的最低花费
    dp[0] = 0; // 初始条件：到达0台阶花费0
    dp[1] = 0; // 初始条件：到达1台阶花费0

    for (let i = 2; i <= n; i++) {
        // 到达i台阶的最低花费 = min(从i-1来的花费, 从i-2来的花费)
        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
    }

    return dp[n]; // 顶部是n台阶（cost.length）
};

// 示例测试
console.log(minCostClimbingStairs([10,15,20])); // 输出 15
console.log(minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1])); // 输出 6
```

### 不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

输入：m = 3, n = 7
输出：28

提示：

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

解题思路

1. **状态定义**：设 `dp[i][j]` 表示从左上角（`(0,0)`）到达网格中 `(i,j)` 位置的不同路径数。
2. 状态转移方程：
   - 机器人只能向下或向右移动，所以到达 `(i,j)` 的路径数等于：
     - 从上方 `(i-1,j)` 来的路径数（`dp[i-1][j]`）；
     - 从左方 `(i,j-1)` 来的路径数（`dp[i][j-1]`）；
   - 因此，`dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
3. 初始条件：
   - 第一行（`i=0`）：只能从左方一直向右走，所以 `dp[0][j] = 1`（所有位置路径数都是 1）；
   - 第一列（`j=0`）：只能从上方一直向下走，所以 `dp[i][0] = 1`（所有位置路径数都是 1）。
4. **最终目标**：到达右下角 `(m-1, n-1)` 的路径数，即 `dp[m-1][n-1]`。

```js
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function(m, n) {
    // 创建 m 行 n 列的二维数组，初始化所有值为 0
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

    // 初始化第一列：所有位置路径数为 1
    for (let i = 0; i < m; i++) {
        dp[i][0] = 1;
    }

    // 初始化第一行：所有位置路径数为 1
    for (let j = 0; j < n; j++) {
        dp[0][j] = 1;
    }

    // 动态规划计算每个位置的路径数
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
};

// 示例测试
console.log(uniquePaths(3, 7)); // 输出 28
console.log(uniquePaths(3, 2)); // 输出 3
console.log(uniquePaths(7, 3)); // 输出 28
console.log(uniquePaths(3, 3)); // 输出 6
```

### 不同路径 II

给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

提示：

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

解题思路

1. **状态定义**：设 `dp[i][j]` 表示从左上角 `(0,0)` 到达 `(i,j)` 的不同路径数（若 `(i,j)` 是障碍物，则 `dp[i][j] = 0`）。
2. 状态转移方程：
   - 若 `obstacleGrid[i][j] = 1`（障碍物）：`dp[i][j] = 0`（无法到达）；
   - 否则：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`（从上方或左方来的路径数之和）。
3. 初始条件：
   - 起点 `(0,0)`：若 `obstacleGrid[0][0] = 1`（起点有障碍物），直接返回 0；否则 `dp[0][0] = 1`；
   - 第一行：若当前位置不是障碍物且左边位置可达（`dp[0][j-1] = 1`），则 `dp[0][j] = 1`；否则为 0（因为只能从左方来）；
   - 第一列：若当前位置不是障碍物且上方位置可达（`dp[i-1][0] = 1`），则 `dp[i][0] = 1`；否则为 0（因为只能从上方来）。

```js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length;
    const n = obstacleGrid[0].length;
    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));

    // 起点有障碍物，直接返回0
    if (obstacleGrid[0][0] === 1) return 0;
    dp[0][0] = 1; // 起点可达

    // 初始化第一列
    for (let i = 1; i < m; i++) {
        // 当前位置不是障碍物且上方位置可达
        dp[i][0] = obstacleGrid[i][0] === 0 && dp[i-1][0] === 1 ? 1 : 0;
    }

    // 初始化第一行
    for (let j = 1; j < n; j++) {
        // 当前位置不是障碍物且左方位置可达
        dp[0][j] = obstacleGrid[0][j] === 0 && dp[0][j-1] === 1 ? 1 : 0;
    }

    // 动态规划计算每个位置的路径数
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (obstacleGrid[i][j] === 1) {
                dp[i][j] = 0; // 障碍物，路径数为0
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]; // 上方+左方路径数
            }
        }
    }

    return dp[m-1][n-1];
};

// 示例测试
console.log(uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]])); // 输出 2
console.log(uniquePathsWithObstacles([[0,1],[0,0]])); // 输出 1
console.log(uniquePathsWithObstacles([[1,0]])); // 输出 0（起点有障碍物）
```

### 整数拆分

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

提示:

- `2 <= n <= 58`

解题思路

规律：

- 当 `n ≥ 2` 时，拆分出的数中，`3` 的乘积效率最高（`3×3 > 2×2×2`，`3×2 > 2×2`）；
- 若 `n` 除以 `3` 余 `1`：则拆出一个 `4`（即 `2+2`），剩余拆为 `3`（因为 `3×1 < 2×2`）；
- 若 `n` 除以 `3` 余 `2`：直接拆为 `3` 和 `2`；
- 若 `n` 能被 `3` 整除：全部拆为 `3`。

方法1：贪心算法

```js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
    if (n === 2) return 1; // 2=1+1，乘积1
    if (n === 3) return 2; // 3=1+2，乘积2

    let result = 1;
    while (n > 4) {
        result *= 3;
        n -= 3;
    }
    // 剩余n为2或4时，直接相乘（4=2+2，乘积4；2直接乘）
    result *= n;
    return result;
};

// 示例测试
console.log(integerBreak(2)); // 1
console.log(integerBreak(10)); // 36（3×3×4）
console.log(integerBreak(8)); // 18（3×3×2）
console.log(integerBreak(7)); // 12（3×4）
```

方法2：动态规划

```js
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
    // 定义dp数组：表示划分后的最大乘积
    const dp = new Array(n+1).fill(0)
    // 1
    if(n < 2){
        return 1
    }
    // 2
    if(n === 2){
        return 1
    }
    // 3
    if(n === 3){
        return 2
    }
    // 后续不划分，因为划分会变小
    dp[1] = 1
    dp[2] = 2
    dp[3] = 3
    // 对4后面的继续赋值
    for(let i=4;i<=n;i++){
        for(let j=1;j<=i/2;j++){
            dp[i] = Math.max(dp[j]*dp[i-j],dp[i])
        }
    }

    // 返回结果
    return dp[n]
};
```

### 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

输入：n = 3
输出：5

提示：

- `1 <= n <= 19`

方法思路：要解决这个问题，我们可以利用 ** 卡特兰数（Catalan Number）** 的数学规律，因为恰好由 `n` 个节点组成的二叉搜索树的数量正好对应第 `n` 个卡特兰数。

卡特兰数的递推公式为：

- 初始条件：`C(0) = 1`，`C(1) = 1`
- 递推关系：`C(n) = Σ（i从0到n-1）C(i) * C(n-1-i)`

简单来说，对于 `n` 个节点的二叉搜索树，若选择第 `i` 个节点作为根，则左子树有 `i-1` 个节点，右子树有 `n-i` 个节点，总数量为左子树数量乘以右子树数量，再对所有可能的根节点求和。

```js
function numTrees(n) {
    // 初始化 dp 数组，dp[i] 表示 i 个节点的二叉搜索树数量
    const dp = new Array(n + 1).fill(0);
    dp[0] = 1; // 0个节点时有一种空树
    dp[1] = 1; // 1个节点时有一种树

    // 计算从 2 到 n 的卡特兰数
    for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            // 以 j 为根，左子树 j-1 个节点，右子树 i-j 个节点
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}
```

### 0-1背包理论基础

题目描述

小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 

小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。

输入描述

第一行包含两个正整数，第一个整数 M 代表研究材料的种类，第二个正整数 N，代表小明的行李空间。

第二行包含 M 个正整数，代表每种研究材料的所占空间。 

第三行包含 M 个正整数，代表每种研究材料的价值。

输出描述

输出一个整数，代表小明能够携带的研究材料的最大价值。

输入示例

```
6 1
2 2 3 1 5 2
2 3 1 5 4 3
```

输出示例

```
5
```

提示信息

小明能够携带 6 种研究材料，但是行李空间只有 1，而占用空间为 1 的研究材料价值为 5，所以最终答案输出 5。 

数据范围：
1 <= N <= 5000
1 <= M <= 5000
研究材料占用空间和价值都小于等于 1000

方法思路：这是一个典型的**0-1 背包问题**，需要在有限的行李空间内选择研究材料，使得总价值最大。由于数据范围较大（M 和 N 均≤5000），需要使用**二维动态规划数组**优化空间复杂度。

1. **状态定义**：`dp[i][j]` 表示**前 i 个物品**中选择，且行李空间为`j`时的最大价值。

2. **初始化**：第一个物品（i=0），只要空间`j ≥ weight[0]`，价值就是`value[0]`（只能选第一个物品）。

3. **状态转移**：

   - 若当前空间`j < weight[i]`：无法选第 i 个物品，`dp[i][j] = dp[i-1][j]`（继承前 i-1 个物品的结果）。

   - 若当前空间`j ≥ weight[i]`：选或不选第 i 个物品，取最大值：

     `dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])`。

```js
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line.trim());
    if (lines.length === 3) {
        solve();
        rl.close();
    }
});

function solve() {
    // 解析输入
    const [M, N] = lines[0].split(' ').map(Number); // M:物品数，N:行李空间
    const weight = lines[1].split(' ').map(Number); // 物品占用空间
    const value = lines[2].split(' ').map(Number);  // 物品价值

    // 初始化二维dp数组：dp[i][j]表示前i个物品，空间j的最大价值
    const dp = Array.from({ length: M }, () => new Array(N + 1).fill(0));

    // 初始化第一个物品（i=0）
    for (let j = weight[0]; j <= N; j++) {
        dp[0][j] = value[0];
    }

    // 遍历后续物品（i从1开始）
    for (let i = 1; i < M; i++) {
        for (let j = 0; j <= N; j++) {
            if (j < weight[i]) {
                // 空间不足，无法选第i个物品，继承前i-1个的结果
                dp[i][j] = dp[i - 1][j];
            } else {
                // 选或不选第i个物品，取最大值
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }

    console.log(dp[M - 1][N]);
}
```

用一维数组来实现

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const read = [];
rl.on('line', (line) => {
    read.push(line.trim());
    if (read.length === 3) {
        rl.close();
        solve(); // 输入读取完成后执行核心逻辑
    }
});

function solve() {
    // 解析输入
    const [M, N] = read[0].split(' ').map(Number); // M:材料种类，N:行李空间
    const weight = read[1].split(' ').map(Number); // 材料占用空间
    const value = read[2].split(' ').map(Number);  // 材料价值

    // 初始化一维dp数组：dp[j]表示空间为j时的最大价值
    const dp = new Array(N + 1).fill(0);

    // 遍历每种材料
    for (let i = 0; i < M; i++) {
        const w = weight[i];
        const v = value[i];
        // 倒序遍历空间，避免重复选择同一材料
        for (let j = N; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }

    console.log(dp[N]); // 输出最大价值
}
```

### 分割和子级

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11 。

提示：

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

方法：要解决这个问题，我们可以用动态规划，将其转化为**子集和问题**：判断是否存在一个子集的和等于数组总和的一半。如果数组总和是奇数，直接返回`false`；如果是偶数，则进一步判断是否能找到和为总和一半的子集。

1. **预处理**：计算数组总和`sum`，若`sum`为奇数，直接返回`false`（无法平分）。目标和`target = sum / 2`。
2. **动态规划定义**：用`dp[i]`表示是否能组成和为`i`的子集。
3. **初始化**：`dp[0] = true`（和为 0 的子集始终存在，即空集）。
4. **状态转移**：遍历每个数字`num`，从`target`倒序遍历到`num`，更新`dp[i] = dp[i] || dp[i - num]`（若`i - num`能组成，则`i`也能组成）。

代码实现

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canPartition = function(nums) {
    // 算出nums的总和
    const sum = nums.reduce((acc, cur) => acc + cur, 0);

    // 如果和是奇数返回false
    if (sum % 2 !== 0) {
        return false;
    }

    // 转化为01背包问题，背包容量target = sum/2
    const target = sum / 2;

    // 定义dp数组，dp[j]表示容量j的背包能装的最大和
    const dp = new Array(target + 1).fill(0); // 容量范围0~target

    // 遍历物品
    for (let i = 0; i < nums.length; i++) {
        // 倒叙遍历背包容量（从target到当前物品重量）
        for (let j = target; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }

    // 判断容量target时的最大和是否等于target
    return dp[target] === target;
};
```

### 最后一块石头的重量Ⅱ

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

提示：

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

解题思路

1. **问题转化**：假设石头总重量为 `sum`，我们需要找到一堆石头的最大重量 `maxWeight`，使得 `maxWeight ≤ sum/2`。最终剩下的石头重量为 `sum - 2*maxWeight`。
2. **动态规划定义**：用 `dp[j]` 表示 “能否凑出重量为 `j` 的石头堆”（或 “重量为 `j` 的石头堆的最大重量”）。
3. **状态转移**：对每个石头，倒序遍历背包容量（避免重复选择），更新 `dp[j] = max(dp[j], dp[j-stones[i]] + stones[i])`。

```js
function lastStoneWeightII(stones) {
    const sum = stones.reduce((acc, cur) => acc + cur, 0);
    const target = Math.floor(sum / 2);
    const dp = new Array(target + 1).fill(0);

    for (const stone of stones) {
        for (let j = target; j >= stone; j--) {
            dp[j] = Math.max(dp[j], dp[j - stone] + stone);
        }
    }

    return sum - 2 * dp[target];
}

// 测试示例
console.log(lastStoneWeightII([2,7,4,1,8,1])); // 输出 1
console.log(lastStoneWeightII([31,26,33,21,40])); // 输出 5
```

### 目标和

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

提示：

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

解题思路

1. **问题转化**：假设所有添加`+`的元素和为`sumP`，添加`-`的元素和为`sumN`，则有：

   - `sumP - sumN = target`

   - `sumP + sumN = sum`（数组总和）

     联立可得：`sumP = (sum + target) / 2`。

     因此问题转化为：**找到和为`sumP`的子集数目**（需满足`sum + target`为偶数且非负）。

2. **动态规划定义**：`dp[j]` 表示 “和为`j`的子集数目”，初始时`dp[0] = 1`（空集和为 0 的情况有 1 种）。

3. **状态转移**：对每个元素，倒序遍历背包容量，更新`dp[j] += dp[j - nums[i]]`（选当前元素时，累加之前和为`j - nums[i]`的子集数目）。

```js
function findTargetSumWays(nums, target) {
    const sum = nums.reduce((acc, cur) => acc + cur, 0);
    // 若sum + target为奇数或绝对值超过sum，无解
    if ((sum + target) % 2 !== 0 || Math.abs(target) > sum) return 0;
    
    const targetSum = (sum + target) / 2;
    const dp = new Array(targetSum + 1).fill(0);
    dp[0] = 1; // 初始状态：和为0的子集有1种（空集）

    for (const num of nums) {
        for (let j = targetSum; j >= num; j--) {
            dp[j] += dp[j - num];
        }
    }

    return dp[targetSum];
}

// 测试示例
console.log(findTargetSumWays([1,1,1,1,1], 3)); // 输出 5
console.log(findTargetSumWays([1], 1)); // 输出 1
```







### 零钱兑换II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

示例 1:

- 输入: amount = 5, coins = [1, 2, 5]
- 输出: 4

解释: 有四种方式可以凑成总金额:

- 5=5
- 5=2+2+1
- 5=2+1+1+1
- 5=1+1+1+1+1

解题思路

使用动态规划：

- 定义`dp[i]`表示凑成金额`i`的组合数
- 初始状态：`dp[0] = 1`（凑成金额 0 的组合数为 1，即不选任何硬币）
- 状态转移：对于每个硬币`coin`，遍历金额从`coin`到`amount`，更新`dp[i] += dp[i - coin]`

```js
function change(amount, coins) {
    // 初始化dp数组，dp[i]表示凑成金额i的组合数
    const dp = new Array(amount + 1).fill(0);
    // 金额0只有一种组合方式：不选任何硬币
    dp[0] = 1;
    
    // 遍历每个硬币
    for (const coin of coins) {
        // 从coin开始遍历金额，确保i - coin >= 0
        for (let i = coin; i <= amount; i++) {
            // 累加组合数
            dp[i] += dp[i - coin];
        }
    }
    
    return dp[amount];
}
```

### 组合总和Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

示例:

- nums = [1, 2, 3]
- target = 4

所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)

请注意，顺序不同的序列被视作不同的组合。

因此输出为 7。

题目分析

这道题是**排列数问题**（顺序不同视为不同组合），与上一题的组合数问题核心区别在于：

- 本题中`(1,2)`和`(2,1)`是不同的组合
- 需要先遍历金额，再遍历数字（与组合数问题的遍历顺序相反）

解题思路

使用动态规划：

- 定义`dp[i]`表示凑成金额`i`的排列数
- 初始状态：`dp[0] = 1`（凑成金额 0 的排列数为 1）
- 状态转移：先遍历金额从 1 到 target，再遍历每个数字，若当前金额≥数字，则`dp[i] += dp[i - num]`

```js
function combinationSum4(nums, target) {
    // 初始化dp数组，dp[i]表示凑成金额i的排列数
    const dp = new Array(target + 1).fill(0);
    // 金额0的排列数为1（基准情况）
    dp[0] = 1;
    
    // 先遍历金额（从1到target）
    for (let i = 1; i <= target; i++) {
        // 再遍历每个数字
        for (const num of nums) {
            // 如果当前金额大于等于数字，则累加排列数
            if (i >= num) {
                dp[i] += dp[i - num];
            }
        }
    }
    
    return dp[target];
}
```

