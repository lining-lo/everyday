## 算法总结

### 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
function search(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    
    while (left <= right) {
        // 计算中间索引（避免溢出：等同于 Math.floor((left + right) / 2)）
        const mid = left + Math.floor((right - left) / 2);
        
        if (nums[mid] === target) {
            return mid; // 找到目标，返回下标
        } else if (nums[mid] < target) {
            left = mid + 1; // 目标在右半部分
        } else {
            right = mid - 1; // 目标在左半部分
        }
    }
    
    return -1; // 未找到目标
}
```

### 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

双指针法思路

1. 定义两个指针：
   - `fast` 指针：遍历整个数组，用于寻找不等于 `val` 的元素。
   - `slow` 指针：指向当前需要填充新元素的位置（即新数组的末尾）。
2. 遍历过程：
   - 当 `fast` 指向的元素不等于 `val` 时，将该元素复制到 `slow` 指向的位置，然后 `slow` 向前移动一步（新数组长度 + 1）。
   - 当 `fast` 指向的元素等于 `val` 时，`fast` 直接跳过（不处理）。
3. **结束条件**：`fast` 遍历完整个数组后，`slow` 的值就是新数组的长度。

```js
function removeElement(nums, val) {
    let slow = 0; // 慢指针：记录新数组的长度，指向待填充位置
    for (let fast = 0; fast < nums.length; fast++) {
        // 当快指针找到不等于val的元素时，复制到慢指针位置
        if (nums[fast] !== val) {
            nums[slow] = nums[fast];
            slow++; // 慢指针前移，更新新数组长度
        }
    }
    return slow; // 慢指针的值就是新数组的长度
}
```

### 有序数组的平方

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

关键思路

原数组是**非递减排序**的，但平方后可能出现 “两边大、中间小” 的情况（因为负数平方后可能比正数大，例如 `[-4, -1, 2, 3]` 平方后为 `[16, 1, 4, 9]`）。因此，可采用**双指针法**从两端向中间遍历，比较两端元素的平方大小，将较大的平方值从新数组的末尾开始填充，最终得到有序结果。

双指针法实现步骤

1. 初始化左指针 `left` 指向数组起点（0），右指针 `right` 指向数组终点（`nums.length - 1`）。
2. 创建结果数组 `result`，长度与原数组相同，初始化索引 `index` 为 `nums.length - 1`（从末尾开始填充）。
3. 比较 `nums[left]` 和 `nums[right]` 的平方:
   - 若 `left` 指向元素的平方更大，将其放入 `result[index]`，并右移 `left`。
   - 否则，将 `right` 指向元素的平方放入 `result[index]`，并左移 `right`。
4. 递减 `index`，重复步骤 3，直到 `left` 超过 `right`。

```javascript
function sortedSquares(nums) {
    const n = nums.length;
    const result = new Array(n); // 结果数组
    let left = 0;
    let right = n - 1;
    let index = n - 1; // 从结果数组末尾开始填充

    while (left <= right) {
        const leftSquare = nums[left] * nums[left];
        const rightSquare = nums[right] * nums[right];

        if (leftSquare > rightSquare) {
            result[index] = leftSquare;
            left++; // 左指针右移
        } else {
            result[index] = rightSquare;
            right--; // 右指针左移
        }
        index--; // 结果数组索引左移
    }

    return result;
}
```

### 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

暴力破解的核心逻辑

1. 外层循环 `i` 定义子数组的起点（从 0 到 n-1）。
2. 内层循环 `j` 从起点 `i` 开始，逐步扩展子数组的终点，同时累加子数组的和。
3. 当子数组的和 `currentSum` 大于等于 `s` 时，计算当前子数组的长度（`j - i + 1`），并与已知的最小长度比较更新。
4. 找到符合条件的子数组后，通过 `break` 退出内层循环（因为继续扩展会使子数组更长，无需考虑）。
5. 遍历结束后，如果始终没有找到符合条件的子数组（`minLength` 仍为 `Infinity`），返回 0，否则返回最小长度。

```js
function minSubArrayLen(s, nums) {
    const n = nums.length;
    let minLength = Infinity; // 初始化最小长度为无穷大

    // 外层循环：遍历所有可能的子数组起点
    for (let i = 0; i < n; i++) {
        let currentSum = 0; // 记录当前子数组的和
        
        // 内层循环：从起点i开始，扩展子数组的终点
        for (let j = i; j < n; j++) {
            currentSum += nums[j]; // 累加当前元素到子数组和中
            
            // 一旦子数组和大于等于s，更新最小长度
            if (currentSum >= s) {
                const currentLength = j - i + 1;
                minLength = Math.min(minLength, currentLength);
                break; // 找到当前起点的最短子数组，无需继续扩展
            }
        }
    }

    // 如果未找到符合条件的子数组，返回0，否则返回最小长度
    return minLength === Infinity ? 0 : minLength;
}
    
```

要解决这个问题，最高效的方法是使用**滑动窗口**（双指针）技术，时间复杂度可以优化到 O (n)，比暴力解法（O (n²)）更高效。

滑动窗口思路

1. 定义两个指针 `left` 和 `right`，分别表示窗口的左右边界，初始都为 0。
2. 移动 `right` 指针扩大窗口，累加元素和 `sum`。
3. 当 `sum >= s` 时，尝试移动 `left` 指针缩小窗口，同时更新最小长度。
4. 重复步骤 2-3，直到 `right` 遍历完整个数组。

```js
function minSubArrayLen(s, nums) {
    let left = 0; // 窗口左边界
    let sum = 0; // 当前窗口的和
    let minLen = Infinity; // 最小子数组长度

    // 移动右边界，扩大窗口
    for (let right = 0; right < nums.length; right++) {
        sum += nums[right];

        // 当窗口和 >= s 时，尝试缩小左边界
        while (sum >= s) {
            // 计算当前窗口长度并更新最小值
            const currentLen = right - left + 1;
            minLen = Math.min(minLen, currentLen);
            
            // 移动左边界，缩小窗口
            sum -= nums[left];
            left++;
        }
    }

    // 如果没找到符合条件的子数组，返回 0
    return minLen === Infinity ? 0 : minLen;
}
    
```

### 螺旋矩阵II

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

要解决这个问题，我们需要生成一个包含 1 到 n² 所有元素的正方形矩阵，且元素按顺时针螺旋排列。核心思路是**模拟顺时针螺旋的填充过程**，通过控制边界逐步缩小填充范围。

解题步骤

1. **初始化矩阵**：创建一个 n×n 的空矩阵，用于存放结果。
2. **定义边界**：设定上、下、左、右四个边界，初始分别为矩阵的顶部（0）、底部（n-1）、左侧（0）、右侧（n-1）。
3. **顺时针填充**：按照 “从左到右→从上到下→从右到左→从下到上” 的顺序循环填充，每完成一轮方向填充就缩小对应边界，直到所有元素（1 到 n²）都被填充完毕。

代码实现

```js
function generateMatrix(n) {
    // 初始化 n×n 的二维数组，填充 0
    const res = new Array(n).fill(0).map(item => new Array(n).fill(0))
    let startx = 0, starty = 0; // 每圈的起始位置
    let loop = Math.floor(n / 2); // 循环的圈数（n为奇数时，中心单独处理）
    const mid = Math.floor(n / 2); // 中心位置索引
    let count = 1; // 填充的数字，从1开始
    let offset = 1; // 每圈边界收缩量
    let i, j;

    while (loop--) {
        i = startx;
        j = starty;

        // 1. 上行：从左到右（左闭右开）
        for (j; j < n - offset; j++) {
            res[i][j] = count++;
        }

        // 2. 右列：从上到下（左闭右开）
        for (i; i < n - offset; i++) {
            res[i][j] = count++;
        }

        // 3. 下行：从右到左（左闭右开）
        for (; j > starty; j--) {
            res[i][j] = count++;
        }

        // 4. 左列：从下到上（左闭右开）
        for (; i > startx; i--) {
            res[i][j] = count++;
        }

        // 下一圈的起始位置内移
        startx++;
        starty++;

        // 边界收缩量增加
        offset++;
    }

    // 如果n是奇数，填充中心元素
    if (n % 2 !== 0) {
        res[mid][mid] = count;
    }

    return res;
}

// 测试示例
console.log(generateMatrix(3)); 
// 输出: [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ]
```

### 区间和

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

输入描述

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。

输出描述

输出每个指定区间内元素的总和。

输入示例

```js
5
1
2
3
4
5
0 1
1 3
```

输出示例

```js
3
9
```

暴力破解的核心思路

1. 读取数组长度和元素，存储为数组 `array`。

2. 对每个输入的区间[l, r]

   （假设 0 开始索引，左闭右闭）：

   - 从索引 `l` 遍历到 `r`，累加每个元素的值。
   - 输出累加结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组

rl.on('line', (line) => {
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 读取数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，切换到读取区间模式
      if (array.length === n) {
        isReadingArray = false;
      }
    }
  } else {
    // 处理区间请求：暴力遍历求和
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    let sum = 0;
    // 从 l 遍历到 r，累加元素
    for (let i = l; i <= r; i++) {
      sum += array[i];
    }
    console.log(sum);
  }
});
```

使用前缀和的解题思路

1. 读取数组长度与元素：先获取数组长度 `n`，再读取 `n` 个整数构建原数组。
2. 构建前缀和数组：前缀和数组 `prefix` 中，`prefix[i]` 表示原数组前 `i` 个元素的和（`prefix[0] = 0`，`prefix[1] = 原数组[0]`，以此类推）。通过前缀和可快速计算任意区间 `[l, r]` 的和：`sum = prefix[r+1] - prefix[l]`（假设区间从 0 开始索引）。
3. 处理区间请求：持续读取输入的区间（每行两个整数，代表区间的起始和结束索引），利用前缀和数组计算并输出每个区间的和，直至输入结束。

```js
const readline = require('readline');

// 创建读取输入的接口
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false
});

let n; // 数组长度
let array = []; // 原数组
let isReadingArray = true; // 标记是否在读取数组阶段
let prefix = []; // 前缀和数组

// 处理每一行输入
rl.on('line', (line) => {
  // 去除行首尾空格，避免空输入干扰
  const trimmedLine = line.trim();
  if (!trimmedLine) return;

  if (isReadingArray) {
    // 第一行输入：数组长度 n
    if (n === undefined) {
      n = parseInt(trimmedLine);
    } else {
      // 后续 n 行：读取数组元素
      array.push(parseInt(trimmedLine));
      // 数组读取完毕后，构建前缀和数组
      if (array.length === n) {
        isReadingArray = false;
        // 构建前缀和：prefix[0] = 0，prefix[1] = array[0]，prefix[2] = array[0]+array[1]...
        prefix[0] = 0;
        for (let i = 0; i < n; i++) {
          prefix[i + 1] = prefix[i] + array[i];
        }
      }
    }
  } else {
    // 读取区间请求：每行两个整数，代表区间 [l, r]（0 开始索引，左闭右闭）
    const [l, r] = trimmedLine.split(/\s+/).map(Number);
    // 区间和 = 前缀和[r+1] - 前缀和[l]
    const sum = prefix[r + 1] - prefix[l];
    console.log(sum);
  }
});
```

### 开发商买地

【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。

要解决这个问题，我们需要将一个 `n×m` 的城市区块按横向或纵向划分为两部分，使两部分的土地总价值之差最小。核心思路是**枚举所有可能的划分方式，计算每种方式的价值差，最终选择最小值**。

暴力解题步骤：

1. 读取输入并解析网格：获取 `n`（行数）和 `m`（列数），以及每个区块的价值，构建二维数组。
2. 计算总价值：先求出所有区块的总价值 `sum`，方便后续计算两部分的差值。
3. 枚举横向划分：
   - 横向划分有 `n-1` 种可能（在第 `k` 行和第 `k+1` 行之间切分，`k` 从 1 到 `n-1`）。
   - 对每种划分，计算上半部分（前 `k` 行）的总价值 `s`，差值为 `|2s - sum|`（因为另一部分价值为 `sum - s`，差值简化为 `|s - (sum - s)|`）。
4. 枚举纵向划分：
   - 纵向划分有 `m-1` 种可能（在第 `k` 列和第 `k+1` 列之间切分，`k` 从 1 到 `m-1`）。
   - 对每种划分，计算左半部分（前 `k` 列）的总价值 `s`，差值同样为 `|2s - sum|`。
5. 找最小差值：从横向和纵向划分的所有差值中，选择最小的那个作为结果。

```js
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
  inputLines.push(line.trim());
}).on('close', () => {
  // 解析输入
  const [n, m] = inputLines[0].split(' ').map(Number);
  const grid = [];
  for (let i = 1; i <= n; i++) {
    grid.push(inputLines[i].split(' ').map(Number));
  }

  // 计算所有区块的总价值
  let totalSum = 0;
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      totalSum += grid[i][j];
    }
  }

  let minDiff = Infinity; // 初始化最小差值为无穷大

  // 1. 枚举横向划分（按行切分）
  let rowSum = 0; // 累计前k行的总价值
  for (let k = 0; k < n - 1; k++) { // 切分位置：第k行后（0-based），共n-1种
    // 累加第k行的价值到rowSum（前k+1行的总和）
    for (let j = 0; j < m; j++) {
      rowSum += grid[k][j];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * rowSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 2. 枚举纵向划分（按列切分）
  let colSum = 0; // 累计前k列的总价值
  for (let k = 0; k < m - 1; k++) { // 切分位置：第k列后（0-based），共m-1种
    // 累加第k列的价值到colSum（前k+1列的总和）
    for (let i = 0; i < n; i++) {
      colSum += grid[i][k];
    }
    // 计算当前划分的差值
    const diff = Math.abs(2 * colSum - totalSum);
    if (diff < minDiff) {
      minDiff = diff;
    }
  }

  // 输出最小差值
  console.log(minDiff);
});
```

用前缀和实现步骤：

1. 计算总行前缀和：`rowPrefix[i]` 表示前 `i` 行的总价值（用于横向分割时快速查询上部分价值）。
2. 计算总列前缀和：`colPrefix[j]` 表示前 `j` 列的总价值（用于纵向分割时快速查询左部分价值）。
3. 遍历所有横向 / 纵向分割线，利用前缀和直接计算两部分的价值差，取最小值。

```js
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const readlineContent = [];
let grid = [];
let totalSum = 0;
let minDiff = Infinity;

rl.on('line', (line) => {
    const processLine = line.trim();
    if (processLine) readlineContent.push(processLine);
});

rl.on('close', () => {
    // 解析n和m
    const [n, m] = readlineContent[0].split(' ').map(Number);
    // 构建网格
    for (let i = 1; i <= n; i++) {
        grid.push(readlineContent[i].split(' ').map(Number));
    }

    // 1. 计算总行前缀和（用于横向分割）
    // rowPrefix[i] = 前i行的总价值（i从0到n，rowPrefix[0]=0，rowPrefix[1]=第0行总和，以此类推）
    const rowPrefix = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        // 第i-1行的总和（累加当前行的所有列）
        let rowSum = 0;
        for (let j = 0; j < m; j++) {
            rowSum += grid[i - 1][j];
        }
        rowPrefix[i] = rowPrefix[i - 1] + rowSum;
    }
    totalSum = rowPrefix[n]; // 总价值 = 前n行的总和

    // 2. 计算总列前缀和（用于纵向分割）
    // colPrefix[j] = 前j列的总价值（j从0到m，colPrefix[0]=0，colPrefix[1]=第0列总和，以此类推）
    const colPrefix = new Array(m + 1).fill(0);
    for (let j = 1; j <= m; j++) {
        // 第j-1列的总和（累加当前列的所有行）
        let colSum = 0;
        for (let i = 0; i < n; i++) {
            colSum += grid[i][j - 1];
        }
        colPrefix[j] = colPrefix[j - 1] + colSum;
    }

    // 3. 横向分割：遍历所有可能的分割线（第i行后，i从1到n-1）
    for (let i = 1; i < n; i++) {
        const upperSum = rowPrefix[i]; // 上部分 = 前i行的总和
        const lowerSum = totalSum - upperSum;
        const diff = Math.abs(upperSum - lowerSum);
        minDiff = Math.min(minDiff, diff);
    }

    // 4. 纵向分割：遍历所有可能的分割线（第j列后，j从1到m-1）
    for (let j = 1; j < m; j++) {
        const leftSum = colPrefix[j]; // 左部分 = 前j列的总和
        const rightSum = totalSum - leftSum;
        const diff = Math.abs(leftSum - rightSum);
        minDiff = Math.min(minDiff, diff);
    }

    console.log(minDiff);
});
```

### 移除链表元素

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

解题思路

1. 虚拟头节点：由于要删除的节点可能是原链表的头节点，引入虚拟头节点（`dummy`）可以避免单独处理头节点的特殊逻辑，其 `next` 指针指向原链表的头节点。
2. 遍历与删除使用指针 `current` 从虚拟头节点开始遍历，检查其下一个节点的值是否为 `val`：
   - 若为 `val`，则通过 `current.next = current.next.next` 跳过该节点（删除操作）。
   - 若不为 `val`，则将 `current` 后移一位，继续检查下一个节点。
3. 返回结果：遍历结束后，虚拟头节点的 `next` 指针即为删除后的新链表头节点。

```js
// 定义链表节点构造函数
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

// 删除链表中所有值为 val 的节点
var removeElements = function(head, val) {
    // 创建虚拟头节点，简化头节点删除逻辑
    const dummy = new ListNode(0);
    dummy.next = head;
    
    let current = dummy; // 从虚拟头节点开始遍历
    
    // 遍历链表，检查当前节点的下一个节点是否需要删除
    while (current.next !== null) {
        if (current.next.val === val) {
            // 下一个节点需删除，跳过该节点
            current.next = current.next.next;
        } else {
            // 下一个节点无需删除，移动 current 指针
            current = current.next;
        }
    }
    
    // 返回删除后的链表头节点（虚拟头节点的 next）
    return dummy.next;
};
```

### 设计链表

在链表类中实现这些功能：

- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

示例：

```js
const linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);    //链表变为1-> 2-> 3
linkedList.get(1);             //返回2
linkedList.deleteAtIndex(1);   //现在链表是1-> 3
linkedList.get(1);             //返回3
```

实现

```js
class MyLinkedList {
  constructor() {
    // 虚拟头节点（简化边界处理）
    this.dummy = new ListNode(0);
    // 记录链表长度（方便快速判断索引有效性）
    this.size = 0;
  }

  /**
   * 获取链表中第 index 个节点的值
   * @param {number} index 目标索引
   * @return {number} 节点值（无效索引返回 -1）
   */
  get(index) {
    // 索引无效的情况（超出范围）
    if (index < 0 || index >= this.size) {
      return -1;
    }

    // 从虚拟头节点的下一个节点开始遍历
    let current = this.dummy.next;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    return current.val;
  }

  /**
   * 在链表头部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtHead(val) {
    // 创建新节点，next 指向原头节点
    const newNode = new ListNode(val, this.dummy.next);
    // 虚拟头节点指向新节点（更新头节点）
    this.dummy.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 在链表尾部添加节点
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtTail(val) {
    // 遍历到最后一个节点
    let current = this.dummy;
    while (current.next !== null) {
      current = current.next;
    }
    // 在尾部添加新节点
    current.next = new ListNode(val);
    // 长度加 1
    this.size++;
  }

  /**
   * 在指定索引前添加节点
   * @param {number} index 目标索引
   * @param {number} val 要添加的节点值
   * @return {void}
   */
  addAtIndex(index, val) {
    // 索引大于长度时不插入
    if (index > this.size) {
      return;
    }
    // 索引小于 0 时，视为在头部插入
    if (index < 0) {
      index = 0;
    }

    // 找到要插入位置的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 创建新节点，插入到 current 后面
    const newNode = new ListNode(val, current.next);
    current.next = newNode;
    // 长度加 1
    this.size++;
  }

  /**
   * 删除指定索引的节点
   * @param {number} index 目标索引
   * @return {void}
   */
  deleteAtIndex(index) {
    // 索引无效时不删除
    if (index < 0 || index >= this.size) {
      return;
    }

    // 找到要删除节点的前一个节点
    let current = this.dummy;
    for (let i = 0; i < index; i++) {
      current = current.next;
    }
    // 跳过要删除的节点（完成删除）
    current.next = current.next.next;
    // 长度减 1
    this.size--;
  }
}

// 链表节点构造函数
class ListNode {
  constructor(val, next) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}
```

### 反转链表

题意：反转一个单链表。

示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

方法 1：迭代法

通过三个指针（`prev`、`current`、`next`）逐步反转链表指针方向，原地完成反转。

```js
/**
 * 定义链表节点
 * @param {number} val 节点值
 * @param {ListNode} next 下一个节点
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 迭代法反转链表
 * @param {ListNode} head 链表头节点
 * @return {ListNode} 反转后的头节点
 */
function reverseList(head) {
  let prev = null; // 初始化前一个节点为 null（反转后尾节点的 next 是 null）
  let current = head; // 当前节点从 head 开始

  while (current !== null) {
    const next = current.next; // 先保存当前节点的下一个节点（防止丢失）
    current.next = prev; // 反转指针：当前节点指向前一个节点
    prev = current; // 前一个节点向后移动（当前节点成为新的前节点）
    current = next; // 当前节点向后移动（处理下一个节点）
  }

  // 循环结束后，prev 就是反转后的头节点（原尾节点）
  return prev;
}
```

步骤解析：以 `1->2->3->null` 为例：

1. 初始：`prev = null`，`current = 1`
2. 第一次循环：`next = 2` → `1.next = null` → `prev = 1` → `current = 2`
3. 第二次循环：`next = 3` → `2.next = 1` → `prev = 2` → `current = 3`
4. 第三次循环：`next = null` → `3.next = 2` → `prev = 3` → `current = null`
5. 结束，返回 `prev = 3`（反转后链表：`3->2->1->null`）

方法 2：递归法

利用递归栈回溯时反转指针，从链表尾部开始逐步反转。

```js
// 构建示例链表：1->2->3->4->5->null
const head = new ListNode(1, 
  new ListNode(2, 
    new ListNode(3, 
      new ListNode(4, 
        new ListNode(5)
      )
    )
  )
);

// 反转链表
const reversedHead = reverseList(head);

// 打印结果（5->4->3->2->1->null）
let current = reversedHead;
while (current !== null) {
  console.log(current.val); // 输出：5 4 3 2 1
  current = current.next;
}
```

### 两两交换链表中的节点

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路解析

以链表 `1->2->3->4->null` 为例，目标是交换成 `2->1->4->3->null`。关键是：

1. 用**虚拟头节点**（dummy）简化边界处理（避免头节点变化的特殊判断）。
2. 每次处理一对节点（如 `1` 和 `2`），需要修改它们前后节点的指向。
3. 用指针跟踪当前待交换节点的前一个节点（`prev`），方便修改指向。

步骤拆解

1. 初始化虚拟头节点 `dummy`，让 `dummy.next = head`（指向原链表头）。
2. 定义 `prev` 指针，初始指向 `dummy`（`prev` 始终是待交换节点对的前一个节点）。
3. 循环条件：`prev.next` 和 `prev.next.next` 都存在（确保有两个节点可交换）。
4. 每次循环交换一对节点：
   - 标记第一个节点 `node1 = prev.next`（如 `1`）。
   - 标记第二个节点 `node2 = prev.next.next`（如 `2`）。
   - 交换指向：`prev.next = node2` → `node1.next = node2.next` → `node2.next = node1`。
   - 移动 `prev` 到交换后的第一个节点（如 `1`），准备处理下一对。

```js
/**
 * 定义链表节点
 * @param {number} val
 * @param {ListNode} next
 */
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

/**
 * 两两交换链表中的节点
 * @param {ListNode} head
 * @return {ListNode}
 */
function swapPairs(head) {
  // 创建虚拟头节点，简化边界处理
  const dummy = new ListNode(0);
  dummy.next = head;
  // prev 指向待交换节点对的前一个节点（初始为 dummy）
  let prev = dummy;

  // 当存在至少两个节点可交换时，进入循环
  while (prev.next !== null && prev.next.next !== null) {
    // 标记待交换的两个节点
    const node1 = prev.next;       // 第一个节点（如 1）
    const node2 = prev.next.next;  // 第二个节点（如 2）

    // 交换节点指向
    prev.next = node2;      // prev 指向第二个节点（如 dummy->2）
    node1.next = node2.next; // 第一个节点指向第二个节点的下一个（如 1->3）
    node2.next = node1;      // 第二个节点指向第一个节点（如 2->1）

    // prev 移动到交换后的第一个节点（为下一次交换做准备）
    prev = node1;
  }

  // 返回虚拟头节点的下一个（新的头节点）
  return dummy.next;
}
```

### 删除链表的倒数第N个节点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

示例 ：

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

方法1：两次遍历

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0, head);
  let length = 0;
  let current = head;

  // 第一次遍历：计算链表长度
  while (current !== null) {
    length++;
    current = current.next;
  }

  // 找到倒数第n个节点的前一个节点（位置为 length - n）
  let prev = dummy;
  for (let i = 0; i < length - n; i++) {
    prev = prev.next;
  }

  // 删除节点
  prev.next = prev.next.next;

  return dummy.next;
}

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

方法二：快慢指针

```js
function ListNode(val, next) {
  this.val = (val === undefined ? 0 : val);
  this.next = (next === undefined ? null : next);
}

var removeNthFromEnd = function(head, n) {
    // 1. 创建一个虚拟头节点，并将其指向链表的真正头节点
    const dummy = new ListNode(0);
    dummy.next = head;

    // 2. 初始化快慢指针，都指向虚拟头节点
    let fast = dummy;
    let slow = dummy;

    // 3. 快指针先向前移动 n+1 步
    // 这样当快指针到达末尾时，慢指针正好在倒数第 n+1 个节点上
    for (let i = 0; i <= n; i++) {
        fast = fast.next;
    }

    // 4. 快慢指针同时向前移动，直到快指针指向 null
    while (fast !== null) {
        fast = fast.next;
        slow = slow.next;
    }

    // 5. 此时 slow.next 就是要删除的倒数第 n 个节点
    // 将 slow 的 next 指针跳过要删除的节点
    slow.next = slow.next.next;

    // 6. 返回虚拟头节点的 next，即新的链表头
    return dummy.next;
};

// 测试示例
const head = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));
const result = removeNthFromEnd(head, 2);

// 输出结果：1->2->3->5
let current = result;
while (current !== null) {
  console.log(current.val);
  current = current.next;
}
```

